{"type":"file-history-snapshot","messageId":"79d208c7-34d5-4af0-9d7b-f1d477d256f2","snapshot":{"messageId":"79d208c7-34d5-4af0-9d7b-f1d477d256f2","trackedFileBackups":{},"timestamp":"2026-02-14T09:46:50.733Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:startup","command":"entire hooks claude-code session-start"},"parentToolUseID":"6ba2eb51-3032-4f74-ae4f-8f95343e3035","toolUseID":"6ba2eb51-3032-4f74-ae4f-8f95343e3035","timestamp":"2026-02-14T09:45:31.804Z","uuid":"9d829e12-c365-4c0a-b3a0-080ac9715df0"}
{"parentUuid":"9d829e12-c365-4c0a-b3a0-080ac9715df0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","type":"user","message":{"role":"user","content":"Re-read @IMPLEMENTATION_PLAN.md top to bottom carefully, and summarize the core agent workflow that this plan will implement in napoli-matcha. \n\nI made several independent changes to this plan and want to double check that this plan is aligned with what I had in mind. Also, it is a long, detailed plan, so I want to be sure it is not contradictory and is aligned to what I had in mind."},"uuid":"79d208c7-34d5-4af0-9d7b-f1d477d256f2","timestamp":"2026-02-14T09:46:50.318Z","thinkingMetadata":{"maxThinkingTokens":31999},"todos":[],"permissionMode":"default"}
{"parentUuid":"79d208c7-34d5-4af0-9d7b-f1d477d256f2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_011NiJuiTzcrVzwiNV1QDpmv","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":23092,"cache_read_input_tokens":16625,"cache_creation":{"ephemeral_5m_input_tokens":23092,"ephemeral_1h_input_tokens":0},"output_tokens":10,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7kPz4weYSMM9i7oEq8T","type":"assistant","uuid":"4bb4e872-4005-48d5-b076-4d30093a11d4","timestamp":"2026-02-14T09:46:53.259Z"}
{"parentUuid":"4bb4e872-4005-48d5-b076-4d30093a11d4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_011NiJuiTzcrVzwiNV1QDpmv","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to re-read the IMPLEMENTATION_PLAN.md (which was already loaded in the system reminder) and provide a summary of the core agent workflow. They also want me to check for contradictions and alignment issues. Let me carefully analyze the plan.\n\nLet me read through it carefully and summarize the core workflow, then identify any potential contradictions or areas of concern.\n\nThe plan describes a multi-agent pipeline for napoli-matcha, adapted from the Horizon CLI Agent. Let me trace through the core workflow:\n\n1. **Spec Agent (Phase 1)** - Front door quality gate\n   - Takes user request → evaluates against 5 quality criteria → asks clarifying questions in a loop → produces structured tickets\n   - Handles variants by duplicating full dependency chains, with each ticket getting a `start_status` for stage-skipping, then writes them to `request_queue/` as markdown files with YAML frontmatter\n\n2. **ClaudeSpawner (Phase 2)** - Local Claude CLI spawner\n   - Used by Spec Agent and future local agents to spawn `claude -p --output-format=stream-json`\n\n3. **Orchestrator (Phase 3)** - Refactored SandboxQueueProcessor\n   - Runs a continuous loop with concurrent worker pool that's stage-aware\n\n, dispatching one stage per worker invocation\n   - Routes tickets through `stagePromptMap` based on status, with key methods like `filterEligible`, `isTerminal`, `dispatchStage`, and `writeResults`\n   - Merges only when a ticket is terminal and no other non-Done tickets depend on it\n\n4. **Entry Point (Phase 4)** - Two modes: `spec` command vs orchestrator loop\n\n5. **Test-Writer (Phase 5)** - Runs after worker in same sandbox\n   - Unit tests for all tickets, integration tests for terminal tickets only\n\nThe task status model tracks 16+ statuses with granular per-stage tracking, flowing from Needs Research through Research In Progress to either a Oneshot or Staged path, eventually reaching Done, with intervention statuses like Blocked and Needs along the way.\n\nKey design choices include stateless workers per stage with no session affinity, group-aware branching that creates feat/{group} branches for variants and feat/{id} for standalone work, dependencies that only block on Done status, and stage-skipping where the Spec Agent sets the initial stage based on ticket quality.\n\nNow I'm noticing a potential timing issue with the test-writer: the plan says it runs inside `executeWorker()` after the worker finishes, but the dispatch pattern is one stage per invocation, so I need to clarify whether test-writer runs after every single stage or only after specific stages like implement and validate.\n\nThere's also a naming inconsistency between Phase 3, which refers to `dispatchStage`, and Phase 5, which still uses `executeWorker()` — I should verify which term is actually being used in the implementation.\n\nAdditionally, Phase 3 mentions that Research/Spec/Plan stages can run without a sandbox using local Claude, but the test-writer logic seems to assume a sandbox environment, so I need to reconcile when exactly a sandbox is needed versus when it's optional.\n\nThe `filterEligible` function signature also shifts between a 3-parameter version that distinguishes actionable tasks from all tasks and a 2-parameter version that doesn't make that distinction, which seems like a design regression. And looking at the stage routing, Research can apparently transition to Oneshot In Progress, but I'm not seeing that reflected in the `stagePromptMap`.\n\nNow I'm realizing there's a deeper issue with how oneshot fits into the orchestrator pattern. The system normally works by setting a \"Needs X\" status, dispatching a worker, and having that worker set \"X In Progress\". But for oneshot, Research would output `next_status: \"Oneshot In Progress\"` directly—which breaks that pattern since \"Oneshot In Progress\" is already an \"In Progress\" status, not a \"Needs\" status. So who actually dispatches the oneshot worker if there's no \"Needs Oneshot\" entry point?\n\nThere's also an unresolved TODO comment in the plan about needing two IDs to track feature requests versus implementation tickets, and I'm starting to examine the prompts for the Queue Reader and Queue Writer agents.\n\nLooking at the orchestrator design, it seems like the orchestrator itself is handling the queue operations—reading actionable tasks and writing results—which makes me wonder if agents 1 and 3 are still meant to be separate Claude invocations or if their logic has been absorbed into the TypeScript layer. The pipeline diagram shows them as distinct agents, but the orchestrator implementation suggests they might be redundant now. Let me trace through the full flow to see where the inconsistency lies.\n\nThe core pipeline looks solid: spec agent creates tickets, the orchestrator reads the queue, filters eligible tasks, dispatches them through worker stages (Research, Plan, Implement, Validate), and writes results back. But I'm spotting several issues that need clarification—the filterEligible function signature isn't consistent, there's a gap in how Oneshot tasks get dispatched, the naming between executeWorker and dispatchStage is confusing, there's an unresolved HTML comment about dual IDs, and most importantly, the role of agents 1 and 3 versus the orchestrator itself needs to be defined clearly.","signature":"EpU6CkYICxgCKkD4mUOoCcSGv9juDar+A/JUSzUix4siuzmoDnqzZHJ2nJo1kB9E9LYcMK1UPNJ6Fjx2kxB1erFDa10WQEKQ0yw+Egzvqa8OjdzbQLKAracaDOgjObwA6DZ/xBMCFCIwgjn64L63A67XaePj7Iinz3R7AAOEJEAxoAfY8PUUjsbAa7fg8mDbsYylnz2nB1A+Kvw4YmWf09mh/t6rahuELabUuh8iu9RAPj2hPmMhpiM1SQ1AZsZ9kBMOag7vhDA6zDy8S6t46v2ssPhJMIwf0X27kvhpqYLyp18xQvS9VVVJGpYz1YFD+TGCrt+5fB4u5ZqiSNGPwZlOH+ujMP/RF9Kaywr3duGgALRjh8Re0+vKhrYq+WngTPvST6MyEQ/b2yKnrLCzoRYk71dGJbATF74R1OxXLqGzgIqDAWRWQgM5PbtuyfbE+hA2dFfnBFlf2h2NZ0KJvJCguC5CHd1l/3pFoj3uGR8fa7viLAgZCHcjR2u/i2H0PWST7KaQhQNOLWzbKUL7x5njzF9M7P9JrtxCTjdQZpB1Cj6x00hp9ksDL4fEBAfMscvAqesOIEKKyBhxdN9tyPJIwV6MzgiMBETjWwCQ1DEVGv631eppFgBjSlGEsNhu8AjjlGK3QpN8M0MvskkyQybX9HRCqOGuROYNZOjKlju8V6mvVpvkzjkb6TeWmRZBgcXsBdEreOmq8utXVC+KUJwIQADgy+Iv6dlxkq6VrZuc5pH6u9LMUr11HwrEEOjELKfFG4mUbj+TxkLauWkl8Xy9qQGPwLka0fmQkSEJRLRv8tDEnlPLj51AvbCfLJCMjFvnDjkhIzwJxtFjsKFlwudzyzzmiPiD7aDtAgYoAMyk2iMLejL33455dNdezv+olnGkjqLJcA5BliWPazwXPJoZ8FvxZMoVl4A6h/WBt/SJiC3uwIvXAGVC6i2pxQeQXI8ADfL5chdr8Tod/iYzPABROWDBT7+IqIlNC5D2ae/AYIvKhVyerrUB4r38saF/wxm7KWWnSxLe1F/IcjaCQQU8kBwdI956cuHvmc3uRuuqnHnJ65a9uJC6KvqWLy7QxEyBL59ysiWddeDlmVs5oIIk67qw7st1Rdjjy71C7xcXsWknKrUO6+Fc9/f9IOGyFi8FjjYF94ajl0JrQ+oVvuP9fXc3raEtI725/QImFkyU2JGhwLKuIom+JxJ8rvgg96EpAwMWCctSUhWzyw2i3gkuADfr1XCFnqaiOuJZ+WMjM2iA0L4rPvO7fjo4dX6t7Xgvt4dNjGGCz389qzXG6EGZCMaj/lKF7FN81XI/2U82ev8DBhciGd2fDT/h938QS5TXAyoP67nlYujW2X8sPS5oVZqvmv827vn1d6NLX47nctXGeD05HLtOHBxqdEcCmvozhxRqDnJ+ohfN0lv/4R+TRo2eAwze0nYkIEJ21oNlBVnRDs7dnw4b3BJ8XALJ7MFzCXC7Xp2TXzYyPGAw5GkEEEO2/iq0Ym4ZzonO575PAPDQdO/Rtv/6GK63ZjIMoCj/Jm/9g3MnyNoTmTiiELGEfJ81Y+7IYf5OZ6wvgq4WbKz4+Heid1rPkT/7SO0uleR96HJ5miMiP/uxl0V0Bxruc3VMIZEMYwWHc98inMwMr5rYjiKg6XlvoVmOjic+n0DximZv4LlmJAl2z03oyoWBJNrTy7XcPwnRJMx0CF398rd8TCdT6x+R+/j5BYt8znB2HpvTZ+R4u1148g6syfdRnMSFutTMXg9bQMyrK2lzzE9C0GPJJGVSQJodUg/uE7f+eITo9RJwfNZIKJnan5yrDVwZTYQHUWygS14UpbP0OIXqmtCmwj+xJsNd0CapGpTAbrqCvrTdKNcH+ue5Hx7iy7Qbd/yx9mzefFgYKfzY3IkphiABr7Y/at7JH/enENYzXu9YAVJArnbY2e6t/krB2nq2/Q1Ip0+HqSeabB1a1BVI2hZvHFq6/nZ9ur6G86Ii4FxPo6TMGXZfgBzIrk1qRCrXX9Y/3F0cfGyO84Z6gPUOf97MOzkrMoAJl9w0j2KB1Re04IrmrKKQHrHELK5KuyGmPlSVWMyXMUxsGDkfBIttSbGmlBOlfIhT5chAxx4oj++8xDtrgb4Hcl6eyww4OkhRkWd+tn4hyPX/DG554aNipB2e1kVBE98cO1BupJDXo6pRKUw+yXkS0S4d5dc2xyrkrt1GFnkITKtQ/5vqp1EzAFx0W1gZp9WPbXjO6fY8XXxSAIK9HwHCSxT1Ou94lk1OH0aDnObK6TsQR8FLA2HyhNRQl7thVmuZDLtnhfG1s6Jj939Fs8K4FIWq6ay7mxfejuDZtiwOfnn/PjydW0vlG1tZPJ3JlbvkTJ2wXImn+K6ZdJJIO/+u02HbdUDCXrNPINtckq+Z4uZAXqNg9BrZGGpK2EXriquozeFWntPCpAfJ1xBobQtlyoWEs2XBs4uZ5UNl2F5+eS/8UeL3UJDvsZzOXaDZKHppvayt+JKLE4gF+JK8nBmAF/Uvt9RKoDDaPJWNjo03dcLqqtlRFpSR8OW1ZARwhIB9M7AS3QxOKjOtEK+mMN/AgC9pYWrUIfBerOYNwjUn8fJIefQROo2mNMeVzpuwLdRmv59DkNKJaEmEqVc+M6PIeqgeDsR1oJof0Qvt6ruXzPycuvrEgDehp172t7MCBsPLF2unM7aKRRtVNuat9xJGAQNtVPLW5dZeYeOiTQp8Zokr1YVj9esLWurARXMvD6Sujpvq5kd/ARN31U+W7iJ7AEKk2iCGZjlLU0yJfHOD0gGK9OJE/OwJnac6VK2LeBk4F+4IC8NzBqvEITjL7ln8guH8x9o9r+mqXETfwID9CZeo8CSKu0i5vT5woICfk94xdWRSvW/hpjYafvQbNzsA+Zl1usEMh24YaOT5/mBqEkuujHtkTL19NEnEPpzTOdbjzC4pgKi4unZQONEZmF08Kt+3Jm4+Zi7sD2wiisYioczD/L2S4CX9L/GmqN1dCayp5qxZpWVgz01lTJDI7D5c+rfQYZmSE5hINJ5VfR1Qz3psQ9/TcI1KUGEU27HYntBCGt6sAwL+kbKb5FNWRmzcrSf4QgUCeXEQ/sM4j/rtxT0MrSgnkKoVY+nEdGeUNfMqt+ih5nQf48vE8jCauDCx9K0pjAMSqaOQGFP01SypelnGJRZlGZf9c72o9Wfz8ZOgM1LZqSWdjixpbrZA53OmIqA6b3U8hD+YTK2dpd7yMa1dhNhwAQNKmDBoxPNBEFtH61PFNDW+2Kx385p+1OdvIwr+9wr/Fb27LIAx4PqQwhT7MyCDvL1dwRilswdX/wP2rM/bz3xDVOIA7eFfTaAc0c+jOPhWmfN7YCGWWeEQRlfRKRcF+8z7kkiEN0fbEqm7Sm6npPXaE0HL2zQ9tN1ADAzVY6mE6KCBj5ntYy/j2p3n07SkC/UwEkZQj4UxhESzGkrBwMkDAHLHyoMBYhkgHMuyHvRXvsM6WmLSRnM0XVKsuDcfMxhJK+vAXBJEEWAm43cH3US6YMguoRxf4UsQ78kzGlVtB7gs3bzfNB3W2dcdjLr9FtXGzaIPpK+nn7n7wBX9dRstYA7eW93wOSPJtITjmjCU8vo0qgOKfLFCEm/0l5WtvJB0CjiLR6c1YstqEn0THgTVGaU9DebUCu8Xqc4XpstFRwkggn3YphvsWxwuln7PfU4/l6BEfylxUeJ1J/TimZ2tEFYNnLFU6gMiHFk/hE4grIYX80zLW/vSfcYBQUG1LF1X6TsysxwT+ePcCRCpvV0dVtZeQ08kuztR55wjg40TNJsLEE1kV/jSv+heH0khMDkkFikAUxBRm1q9iAs19ZHbruM5b5bsz7K4FKHkqvSe7yHuk1SsRG9s//n+qcWZyPR/BwwIcc/pQ3mYBUmqQ/B28c0wbVYVhaMoPLYhVxY98v8RKElJG+YqOD9Ab6egMl5flK4Z2iakoP8bsr89h4L30AfS6Wtd3GwU3cgdnRMw7LN/1Hdxuj5euplzfdGV4rIn35Dta5+sdQBAWoyWDQqEv+HWs6Ltp888jPlZdQfmMY38EeBtzp0PMoV/aKKx7QWDHpwJG/KvO3ISGWHekg361QXu+VvFRetrwEvydIJ7+pxNNyXwf4UUYv4RT/IrUtMpPP9jLizkhJcuF/PhbnAv07jjRDZhPi4YnuQu2I1h0I3TFFvgtd1tu22SrbA2/2TSjkYhmSFGCEhJ3stwma9aqDAUHZlFQ8ZfrHtc+CpfqyvItwu7VVAMecKCx9Vn9b3AIgaq/9p00Re14NlUuRVzxwQhASEMluzOcscXrrz7U8Z8EDGdyX9dRCrKCVR6fBqINO7CGxXy3t5XrjO/DBWl6iHfxISnnAM2ivWKDHpaORK8Q+uCnhaOvUb5ZRn5K8ausn0lhU+gH+9yRy22q47j8oMMpnn+UbTnOnWF9FV7+4vVoVPXtYM/fMlv5JWghQM32P32XlNs28i1AtafkMQMPZZgbgCvysaEh1FrJuzo5v2blYH8emPITWyQEMzLLL91p3WzS1szcmgyo5XXIptuSkddDkwXhjJ0AtWLAsDoeEXeEthxBtRnBcodoEvrVtXWUpAcjiRaab+HCo6ENJNT5WNSZOzHIl52kJ9Ij9ymVPSijCW7IRAuoow3yQfVug/yEWH+2TPRA4R+NQicuALmMoIqymcG42qwMHt2bsfnP3wzErV1hBe2nz3m7qCLDb/ZJqgDFurR+umUGBRHGLVjVA2tYYFWK5aJkB2Dw7pDlH7RgAB+a6ncDUMgR/Pe3ndNc+uy77H9W3D+Ex6/pa95nUZKgD7y1m+DPOxucOLdZS4GdflGb4OvljeH5BrKPhn6i2e3KvsVs4d6maXGqo38AvgCyR5Lm7Uss5C93EAVjaQWS9KlcW949HUWylfl/5tF6NOEvDoc0WOK1Kdsghv51JPzt+SaYQeMdYmj610UEl0utKQLUgOxj8fJ6l+T6T9MtldCWifWbJS8D9sivwqvI1ma364CK8s7zejxiUPMy2QOssur7yIxvZiZplZDeidYFED2Jp9APBDhJJ1MJo/ox7xJ1yjftMeIbFxJ60yRvNY29ppEeiBJ2uaTWBHMKOOGuXpbuaYvnqiD+hfFwWKim+ebZPSK8Rpj6RMgIyGjkBH/B+6qUcd1OONvsqbZ6qgrWAUoDre47Lb5TgJsPRoyY1uFkJbs5ncc8S7mPN9kNi19oHLVtwUoO5ZBUPnncqreOSraUHje4ieWDcl1hKJKBMYS+erA0ViuEAXtH7C6zSexSaPxGdp8BYN2BNbY8X4AKKSDqsIegkgzOqU+JBmQh3j1pLMkgUXxVi9GKuaIaNHjo1/T19itszKCSW4noiQEw5Mo6xLYNWAIYBef+CRWCEeoo0nEajNCCJlq0Y2UGWeWPxhbDNrSFc4A2V47GUt69ASn6q51BlsrpyRw4UZePnia/ZnUTFLlYb1c59A/pIiEAvebc6BiRhCtW8VhgjGDLnF8vG5c0bLX6qWvHdZrhRBls8ggP76P49ev3qWmZXUMQDUBT4SdCBmnciHXHpbmHRhrICFj2uKhMiyzRH2HJB5iC5Cl9E8aEfRroFWpxGw16KjymcRoZsFualpiZOUwrq4HBUuom0ZUie9H9pMXG2p2qQ6t9wP6RSjSI+8MvXyaiUfWFLGQtYy96bjJZLNTgw0R69RGpUp8jYzSlmmZcHP8ScrXbyPmB7uiYmjS9F+t2rAZQ93upnnDVzbJhDMYBiIKhEQXAJNHd7WFxw8/WpSflxOPflXWmyUE1EgsVpCCHVit+/xceZhkJAgM/+XPZhol5a2oM+IAR2ORGHd9UZZFAqikuzE7S5CwRq8AZuSpUqEz8OwAPCjOVyVNHGGqJNkwbb7ORVappTg7drpMMXNRFeJq5e3kLVoH0ZIp3o1v4i68XX4xrtEcBZO0gYOf30JtiiBt4WWK2+msgm5lEV4MUr1i5HHmON20QPWMEQTXwQKo0ITQsoNWfDuvkXNG0Sl0TkXOVuSIcVpMLszGC/R+MzLUU2cNFw9oLAO3lXiksuqn8emZtMNJVgPk7WM9X4ZhJfeU6WIQd6wQwv9TUE7QfzRoD/9chQwmWsoWHZAov2DUvAUxJ37RJmA2FkAvixwescQo7uzI8aJIxJnBtoXpYMrEzpgjCOAoFbwW3ClwuHEmegGMDQ+OEt+zEIM1TBuAlYGLExth5YtPn/BScQL6WBUCwRV8ZvuD0NFwWK68A9rkcmf+5g/YnZOo6Nouu/GVfB4X4kgDPdPKemkJZF7HhB26R8xS6zfppyKf+dkCb22fKVd68Bs3sEK4uEex1BKzWzo8gid6Hh0PVJAI+UuAhRHqMI+2QX8kYxVhMrYQqMTqlmDeF2m+t8kFeeT74sElX4tfr0jjBcRmSnz8fMelAK6IrYT5togTOHMblUbSm02mUG3Qr82k2DkP7O4kgxhSDjXxNNWzUCx+mWjxhZwUnnSPGvrrHdFsCbyVslzzoH8WZb0tb8iklGMDjlo4vgUqKwMSLD3C7kYVg3rEPSLLuFoV2Uuwywuowajv/hAy1/NreHmzJp3BRPYCQkg2DJoLETjsv12WN37PnSpTIMVhtlaJNBiHRvoZ5xOfViiqeKXSfbhB9q6c4yuaZpMddk5Fk8gUv+gFVjC7TC7JLaDrg6vdw6TYwJ9pRjIt8X4ciz2ZDLrY4lJQMmiRaIlej7SYiQvlFxODCZrv9XhUUH7+/9esIWWXfZNR965f5VJAwIuGUJdLOvRLN2tcHCq9Jf+at6KunXwEgtSuKhugrg1laHNNH/u9ZX6VJjMF4aCrl8QhUM1x9L2FRL6bf7bxlkko7qNZlkJb9otIzdKA7QMkRNd3vX/56TIsrcHYN/moLIPUqi+ZWyMDyYMtuXuwrd42t66flg5+WvqlOlsM0iSd40HYuPnxW+PVtje+VcXKu8xl67NTcwd7pyGT7pCWZcfcL94BIiFz0yuO6fIFR1gO1mT9PFrs27aHu4HfYMrXG13xDPdv8uDpROnLksZmN3YwKnbGUgiS+iWbalVCCmCzJ9ZmI5cXd1bGJ32CoNFB8WPGI0u7SvjBEXVneGcS8aDnbVPTAbwPQSoGkEbXnpVRU+QxrVTPrvY0/wfiFVBRDmRI2IqlNFHB47gCGkAJUc3ndkM0ilI62b0qHwj7AzuyBdtY1KNijFVPHn55aLdM6X6EFm7YJTNgfiVfttgScV493m3m4nCDOu1CeE0ToWAgJj056JLoo5EpBNEZGYg67ifwQePA127X4G6+iLBGEHHyg/PcqURFQvDGr7Rnak21gVoEOB6iwCSGfSdKR0ZJSS4qwjlpXu+f4Aeg26vM3T0fS4cwIqvAKCJ0MDjW3cyutYqHYcsuQ0EC42icMtDxHTexge80sa7/3RI5VjVLu6fhQ5uh8/78wDrSvco1yhnRZ3w/TzdHQUkNXFWa1a2/ON7uYcxj09odm4JbKb18gke7393hKtTBMuTXa9F58dTBVdqnwefnCmiTpxFWesxzWj30le30OreeOXffS0Gk1lVfyJ8e5NJVQC+OsCWCOH7CUKIQOJvkgMOqUUuyHx1eyrJUNeoiI4w4zdF7kANRpVGEI3uMqy8M+C0d3TqXu4K6X6u8mNsqatqp9y65BsMnk4wc2lCbeK8k/ETeUaVBkmQHd6CbC+d0c1NaAjL4x5qz323fETzJcuivUyvwt9HQbgheOD8WvBpVELhkHfZXpHjb2ejCVWit64gYM+mB0feFuZvzdmp1I1Dh7ErFYeSyW3diU+XRTHitvYpPnsOZBQbQAe4vVCRYY73cFmn4r7HTPYPpqRtbeuhuTTSBwiNfEhDYujnHKII5NOtL822EyKc0FNpAO/VBmMIxnNOoJmq5WaBzfK152uAXRo+WEoK1rKEjEwzDQ08V9GCTBK29NFEs489xhHy+mJ7EQ8clZRTvxqO6/WNCp0dPsIMy0OWgcby3aHf/dNTCE+H2J9nl25jdGWqE/EIWz/dR0Zye8s3b6q10MjQoz0Ogm3fAXKSDm29UxHD/3wvzW6Z0f74l74rb10FCeQwWboNdNXnf5qOrXJCZAReLo7HLoUYJVftmsR1tgmvgq3W+ysUO+HypobpoXV4quKlwvgOUCIZmz7TG42v6Lwn+5qiRFoX8b77P4BzVmAAXk24cEwsRBhfUIvdqi1cBanOQvBTGqT6yBX5hSsZSQVlvLEMwH+BMxdeckA4Ysef5CcIWfhiZ+vUdVDY5uWddP73ZXsQLStFeAAIVXgtJSoXhPgrtoBm3gQa2t+gANroCJ8qigl5MSBJB8mdB7NjEFUcmKWSen0EyR1Pbz9V9TBskyvbwvEukDWuVnYorQesBiLyMAyDWX5sZ63yffc4QXqBOifB/MhTidnYhzQnojhh50+Gv73JxhZvP5/wmewpMLzDfWAjYtw02hp0hRhT4k4AoZnJf//oyjjiE8fBOo9f0gr/pLeK1HRMTZHkM4nyrSgq2Kog/MEWD0P6L1vxB7rii8DXUPCc/POh2VzhkJ7Dc0b9bmdhzeZKde1ElCtLCL1uYFKL02KUrjnnHCWKCiM53ZrlL52DqdDBbWYlGkvfrbp00rsVlhY2tifyGmnXKlHp/3W5CvFQOfhbRyCIDrEPSVs2syzHdTIYSliihbclSYUn9wzMH3h7lffvxoYbwnjLCCHWtb1yDHiRivoxYKOGgAbSMoYP+4lDm5CpAPXbZ/9qiTFrOzIZm0j4Qif8pU0av887QVv8OzZmKPeclTwoiGPSzsWEDmPRUsYumzCqIEDidVp37xNU/7xdvSe8L2Mjgq8BZbSRHVXTkPP+wN4Iz1pOF1j9ZaV8lcVOfFj1G1womx9+4XlgeKnb1m3z7sTHVHSkMr1QlXlDjVIxtYF3l4aH2lLbi6hT9KVUABVUvg1eHimB521XxiR/mdYBm1Hhd3kmxOaTsTw4kl9/C65OoFDJlapa1E9VFn/ObAi/RU8CfdS3E2sOlG1ZzWTdoidWTDaZb+PvOrsWBpLIW1qZul/GM3/llrkDZin/UgIEiUQt70mS4WwvbbWrSQOxHVDyKGNcAOdkSG02lk3PPE3U/wZomtJGrzx9kYCzu2BtG+iKGwgLm45RZ7kfriXkXixjtvJwIDxtZQvTliDAcLL6/lZQMvfB9EaPAXVybU+eTSkFYapdP9ys83VZ5gDcpZq5V2ZHvOKnk44VMJJULXUhWgjWFvsXTrjC9oNVSxtmvQkAx7Ccehj8N27AatWldA4sG0g2rtHFlGkJ+Q6+ZJbjIS7zbbvV7MZy4qInJbCnzp/1zWU4aGQwhFpIJAk8EGYCvdk1WL3gUK/Jk0JTjo1/n/ykreg7dRzF84XwanSzEhQY7IZ0U7DmmCl8ObZJGhPrGpMvQsqB9MJ4SOujmm5O5xiyNju5h2orWiTGYixVbqNRvAxFWpbd83JilKnxn6AA6Wsm5g+dRevPZjf4JF3Xm4BRZFOMRRmExxi2oWRI178a9JJqFI80Ex7xZQOgFWC585viacZOV9hkWeMUqI5jewdtpSC5/9iVwb0oQVmnHCcvtvmLLnssk1Ee6cQmIzuAaplLo5vv85Relst0QJLdHrZN61l4fpH2sBBuCwv7B/mZrjybqkJljOCgvdMt93dCVfzINCI8REdStgjLNtXJtA7ABAxIODMoOWCH4G8vvgRaST6URactPkhb5S7JjNJWZlXsMyHQCd28dQHB4s2qYWG41SzXk4o7xazykvirv+n7EkfY7E23yg0uQ+zIc8uEQCB8StVWNQAzSUYmxP4kTApOhqHK8dppsEiVb4H0iyUqR2JLVWhLdwDTxRz8dbmJC7oLHfvEIVQT6Zb8OKq6AJFpvWcYeEQOblTA/9oiXyHf3RRdCnRAbK5SlkwrMYUbGWwOMEvVGjYfGrdKYBp20JYHvGzshazzw1x4YAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":23092,"cache_read_input_tokens":16625,"cache_creation":{"ephemeral_5m_input_tokens":23092,"ephemeral_1h_input_tokens":0},"output_tokens":10,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7kPz4weYSMM9i7oEq8T","type":"assistant","uuid":"7eceb7a9-4745-43c5-accf-1bbc101740f1","timestamp":"2026-02-14T09:47:40.491Z"}
{"parentUuid":"7eceb7a9-4745-43c5-accf-1bbc101740f1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_011NiJuiTzcrVzwiNV1QDpmv","type":"message","role":"assistant","content":[{"type":"text","text":"I've read the plan carefully. Here's the core workflow summary, followed by contradictions and open questions I found.\n\n## Core Workflow Summary\n\n**5 phases, 3 runtime contexts:**\n\n1. **Spec Agent** (local Claude via ClaudeSpawner) — Quality gate. Takes a vague user request, evaluates it against 5 criteria, runs a stateless clarification loop with the human until the spec is solid, then writes structured tickets to `request_queue/` as MD files. Can detect variant requests (\"give me 2 versions\") and duplicate the full dependency chain with independent IDs and group names. Each ticket gets a `start_status` judgment that allows stage-skipping (e.g., a well-specified ticket starts at `Needs Plan`, not `Needs Research`).\n\n2. **Orchestrator** (TypeScript, continuous loop in `SandboxQueueProcessor`) — Polls `request_queue/`, topological-sorts on `depends_on`, dispatches **one stage per worker invocation** to eligible tickets (up to N parallel). After each stage completes, parses `WORK_RESULT` for `next_status` and re-dispatches. Dependencies block on `Done` only. Terminal tickets (nothing non-Done depends on them) get a PR + merge; non-terminal grouped tickets just push to their shared `feat/{group}` branch.\n\n3. **Workers** (Claude in Daytona sandbox, stateless) — Each invocation handles exactly one stage using a prompt from `stagePromptMap`. The full pipeline is: Research → (Specification →) Plan → Implement → Validate → Done, with an Oneshot fast-track for simple tasks. Research/Spec/Plan can run locally; Implement/Validate/Oneshot require a sandbox.\n\n4. **Test-Writer** (same sandbox as worker, after Implement/Validate/Oneshot) — Deterministic post-implementation step. Unit tests for all tickets; integration tests only for terminal tickets.\n\n5. **Entry point** — Two modes: `npx tsx src/index.ts spec \"...\"` for Spec Agent, `npx tsx src/index.ts` for Orchestrator loop.\n\n---\n\n## Contradictions & Open Questions\n\n### 1. `filterEligible` signature is inconsistent\n\nPhase 3 first defines it with **3 parameters** (`actionableTasks`, `allTasks`, `active`) at line ~411, with detailed commentary about why both task sets are needed. But the \"filterEligible Update\" section at line ~738 shows a **2-parameter** version (`tasks`, `active`) that only takes one task list. The 2-param version can't distinguish actionable from all tasks, defeating the point of the earlier design.\n\n**Which is intended?** The 3-param version is the correct one based on the surrounding rationale.\n\n### 2. Oneshot dispatch has no entry status\n\nThe `stagePromptMap` maps `Needs *` statuses to prompts. The `TaskStatus` enum has `OneshotInProgress` but no `NeedsOneshot`. The stage transition diagram shows Research routing directly to `Oneshot In Progress`. But the orchestrator pattern is: find `Needs X` → set `X In Progress` → dispatch worker.\n\n**Who dispatches the oneshot worker?** Either:\n- Research itself runs the oneshot inline (contradicts the \"one stage per invocation\" pattern), or\n- There should be a `NeedsOneshot` status + entry in `stagePromptMap` that's missing from the plan\n\n### 3. `executeWorker` vs `dispatchStage` naming conflict\n\nPhase 3 (line ~474) explicitly renames `executeWorker` to `dispatchStage`. But Phase 5 (line ~971) uses `executeWorker()` throughout. These describe different things — `dispatchStage` handles one stage; Phase 5's `executeWorker` creates a sandbox and runs impl + tests. But the naming overlap is confusing.\n\n**Suggest:** Keep `dispatchStage` for Phase 3's one-stage dispatcher. Phase 5's sandbox-level function could be `runSandboxedStage` or similar.\n\n### 4. Agent 1 (Reader) and Agent 3 (Writer) — still Claude agents or absorbed into TypeScript?\n\nThe prompt mapping table lists `agent1-linear-reader.md` and `agent3-linear-writer.md` as needing HIGH adaptation. The pipeline diagram (line ~69) shows them as distinct Claude-powered steps. But the Orchestrator design in Phase 3 handles all their responsibilities in TypeScript: `loadActionableTasks()` replaces agent1, `writeResults()` + `updateTaskStatus()` replaces agent3.\n\n**Are the agent1/agent3 prompts still invoked as Claude calls, or is their logic now pure TypeScript?** The plan seems to have evolved toward TypeScript-native reader/writer but never explicitly deprecated the prompts.\n\n### 5. Unresolved TODO comment (line ~257)\n\nThere's a raw HTML comment:\n> `<!-- I need 2 IDs here, one to track the feature requests from the user, the other to track the tickets for the implementation; for ease of implementation, also create a dir \"feature_requests_id\" to store the feature request... -->`\n\nThis suggests a dual-ID scheme (feature request ID vs ticket ID) and a directory-per-feature-request structure that was never resolved in the plan body. The current plan only has `AGI-{n}` ticket IDs in a flat `request_queue/`.\n\n### 6. Test-Writer scope is ambiguous\n\nPhase 5 says \"Every worker execution is followed by a test-writer step.\" But in the stage-aware model, Research/Spec/Plan stages don't produce code changes worth testing, and they may run locally without a sandbox. The test-writer only makes sense after Implement, Validate, or Oneshot stages.\n\n**The plan probably means:** test-writer runs only after stages that produce code (Implement/Oneshot), not after every stage. But this isn't stated explicitly.\n\n---\n\nWant me to dig into any of these, or should we resolve them one at a time?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":23092,"cache_read_input_tokens":16625,"cache_creation":{"ephemeral_5m_input_tokens":23092,"ephemeral_1h_input_tokens":0},"output_tokens":10,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7kPz4weYSMM9i7oEq8T","type":"assistant","uuid":"2cbac5cb-931f-4bca-9d14-692693332cd1","timestamp":"2026-02-14T09:48:08.380Z"}
{"parentUuid":"2cbac5cb-931f-4bca-9d14-692693332cd1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"47708336-cfdb-432c-af56-5622cbcd0cdf","toolUseID":"47708336-cfdb-432c-af56-5622cbcd0cdf","timestamp":"2026-02-14T09:48:08.425Z","uuid":"66916b2b-6424-422d-b836-50b73378935d"}
{"parentUuid":"66916b2b-6424-422d-b836-50b73378935d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"47708336-cfdb-432c-af56-5622cbcd0cdf","toolUseID":"47708336-cfdb-432c-af56-5622cbcd0cdf","timestamp":"2026-02-14T09:48:08.425Z","uuid":"d833c7b1-2e77-4cc8-abbe-1eeaef1625f2"}
{"parentUuid":"d833c7b1-2e77-4cc8-abbe-1eeaef1625f2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T09:48:08.719Z","uuid":"0c30399f-2c0e-4ebe-85e7-499f96b5489d","toolUseID":"47708336-cfdb-432c-af56-5622cbcd0cdf"}
{"parentUuid":"0c30399f-2c0e-4ebe-85e7-499f96b5489d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","type":"system","subtype":"turn_duration","durationMs":77987,"timestamp":"2026-02-14T09:48:08.724Z","uuid":"c35b7818-fbe4-4601-a37e-8fbcd3db9b6f","isMeta":false}
{"type":"file-history-snapshot","messageId":"2b366dd3-3c7d-4b4d-b2fd-cceb8ee95238","snapshot":{"messageId":"2b366dd3-3c7d-4b4d-b2fd-cceb8ee95238","trackedFileBackups":{},"timestamp":"2026-02-14T09:54:17.217Z"},"isSnapshotUpdate":false}
{"parentUuid":"c35b7818-fbe4-4601-a37e-8fbcd3db9b6f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","type":"user","message":{"role":"user","content":"Dig into all 6 issues and Ask me questions to resolve them one at a time."},"uuid":"2b366dd3-3c7d-4b4d-b2fd-cceb8ee95238","timestamp":"2026-02-14T09:54:16.856Z","thinkingMetadata":{"maxThinkingTokens":31999},"todos":[],"permissionMode":"default"}
{"parentUuid":"2b366dd3-3c7d-4b4d-b2fd-cceb8ee95238","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01BvXkW9BJKLnhCQY9eR7HWh","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":43030,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":43030,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7kxu214uRWUNcovHc5f","type":"assistant","uuid":"08fc0754-cb76-4378-a85b-7be558bfc280","timestamp":"2026-02-14T09:54:19.274Z"}
{"parentUuid":"08fc0754-cb76-4378-a85b-7be558bfc280","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01BvXkW9BJKLnhCQY9eR7HWh","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to dig into each of the 6 issues I identified and ask clarifying questions to resolve them one at a time. Let me start with issue #1 and ask a focused question.","signature":"EtsCCkYICxgCKkANGcO5VaLNoQbjqHklFBxULnbCS16pzhO07thxfNm7IE875qMRDjAMb0nc6d4+m7BXsAr7LJQyYibxzg8ub8aYEgy7Q9/W2ETcjErUiRYaDPdqMTasqDvmpzNT2CIwINgsqbXZEiyafT8I8BoVH8/vSIlLjekM5ZHHcWxtZAbnN9o1LZGeqvHaLQ+FJLlxKsIBP3MVR+LQUZq8FeB269CzIZ4hprQ/EwD5ybHVmcNXnSYbO0KnMh53wog0P602BDmaFV9c9ZrtlSvVTHE1xHGe5aTSHz0Qkt0HByT9bu1DODbPtiWwraAshi1w8ur4dMkpC8hdY3pK0zquCV8G1Nc7pQT3ayvOVb7iLEhX77JrncFq2P2sDZUDd37iqZTvMn5RVoxSgs1q73mNYSA7qNuD51/i0QFI7whO+kGRgoNz5KWArVUlfih3fGM0d6rZ/6GkkvUYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":43030,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":43030,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7kxu214uRWUNcovHc5f","type":"assistant","uuid":"10a3ff55-433d-47e1-b177-f24267bbb735","timestamp":"2026-02-14T09:54:19.972Z"}
{"parentUuid":"10a3ff55-433d-47e1-b177-f24267bbb735","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01BvXkW9BJKLnhCQY9eR7HWh","type":"message","role":"assistant","content":[{"type":"text","text":"Let me start with issue #1. Let me re-read the two conflicting sections to give you precise context."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":43030,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":43030,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7kxu214uRWUNcovHc5f","type":"assistant","uuid":"2d89c7a4-9f0b-4f0e-9881-25c462fb02a7","timestamp":"2026-02-14T09:54:20.793Z"}
{"parentUuid":"2d89c7a4-9f0b-4f0e-9881-25c462fb02a7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01BvXkW9BJKLnhCQY9eR7HWh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UzyQS1UqBTVdwmfHynbKJF","name":"Read","input":{"file_path":"REDACTED.md","offset":406,"limit":50},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":43030,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":43030,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7kxu214uRWUNcovHc5f","type":"assistant","uuid":"1ac97f0f-c0df-4c53-9958-95c0bcedf728","timestamp":"2026-02-14T09:54:21.917Z"}
{"parentUuid":"1ac97f0f-c0df-4c53-9958-95c0bcedf728","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01UzyQS1UqBTVdwmfHynbKJF","parentToolUseID":"toolu_01UzyQS1UqBTVdwmfHynbKJF","uuid":"0c8a8515-5538-4db4-9bfd-5a1a051e9e74","timestamp":"2026-02-14T09:54:21.921Z"}
{"parentUuid":"0c8a8515-5538-4db4-9bfd-5a1a051e9e74","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01UzyQS1UqBTVdwmfHynbKJF","toolUseID":"toolu_01UzyQS1UqBTVdwmfHynbKJF","timestamp":"2026-02-14T09:54:21.978Z","uuid":"81f43123-2a50-4365-82a6-775b8413959f"}
{"parentUuid":"81f43123-2a50-4365-82a6-775b8413959f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01UzyQS1UqBTVdwmfHynbKJF","toolUseID":"toolu_01UzyQS1UqBTVdwmfHynbKJF","timestamp":"2026-02-14T09:54:21.978Z","uuid":"15947d4e-0624-43d2-9686-36f424f86268"}
{"parentUuid":"1ac97f0f-c0df-4c53-9958-95c0bcedf728","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UzyQS1UqBTVdwmfHynbKJF","type":"tool_result","content":"   406→### `filterEligible(actionableTasks, allTasks, active)` — Dependency + Stage Resolution\n   407→\n   408→**Important**: Dependency checks must run against **all tasks** (every status), not just the actionable ones. Otherwise, a dependency in `Research In Progress` (not a `Needs *` status, not in the in-memory `active` map after a restart) would be invisible and incorrectly treated as satisfied.\n   409→\n   410→```typescript\n   411→private filterEligible(\n   412→  actionableTasks: TaskRequest[],\n   413→  allTasks: TaskRequest[],\n   414→  active: Map<string, Promise<void>>\n   415→): TaskRequest[] {\n   416→  return actionableTasks.filter(task => {\n   417→    if (active.has(task.id)) return false;\n   418→    return task.dependsOn.every(depId => {\n   419→      if (active.has(depId)) return false;       // dep running in this process → wait\n   420→      const dep = allTasks.find(t => t.id === depId);\n   421→      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n   422→      return dep.status === TaskStatus.Done;       // only Done = satisfied\n   423→    });\n   424→  });\n   425→}\n   426→```\n   427→\n   428→The `processQueue` loop calls this as:\n   429→\n   430→```typescript\n   431→const actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses only\n   432→const all = await this.loadAllTasks();                 // every status\n   433→const eligible = this.filterEligible(actionable, all, active);\n   434→```\n   435→\n   436→Four states a dependency can be in:\n   437→- **`Done`** — satisfied, proceed\n   438→- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n   439→- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n   440→- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n   441→- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n   442→\n   443→No variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n   444→\n   445→### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n   446→\n   447→A ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n   448→\n   449→```typescript\n   450→private async isTerminal(task: TaskRequest): Promise<boolean> {\n   451→  const allTasks = await this.loadAllTasks();  // all statuses\n   452→  return !allTasks.some(t =>\n   453→    t.id !== task.id &&\n   454→    t.dependsOn.includes(task.id) &&\n   455→    t.status !== TaskStatus.Done"}]},"uuid":"f2f6c8f1-c113-4afa-ad28-8cf85f7e0c6f","timestamp":"2026-02-14T09:54:21.977Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"### `filterEligible(actionableTasks, allTasks, active)` — Dependency + Stage Resolution\n\n**Important**: Dependency checks must run against **all tasks** (every status), not just the actionable ones. Otherwise, a dependency in `Research In Progress` (not a `Needs *` status, not in the in-memory `active` map after a restart) would be invisible and incorrectly treated as satisfied.\n\n```typescript\nprivate filterEligible(\n  actionableTasks: TaskRequest[],\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return actionableTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses only\nconst all = await this.loadAllTasks();                 // every status\nconst eligible = this.filterEligible(actionable, all, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done","numLines":50,"startLine":406,"totalLines":1017}},"sourceToolAssistantUUID":"1ac97f0f-c0df-4c53-9958-95c0bcedf728"}
{"parentUuid":"f2f6c8f1-c113-4afa-ad28-8cf85f7e0c6f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01BvXkW9BJKLnhCQY9eR7HWh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GHYmb1B12ChoQ15a6PXEVy","name":"Read","input":{"file_path":"REDACTED.md","offset":730,"limit":30},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":43030,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":43030,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7kxu214uRWUNcovHc5f","type":"assistant","uuid":"73ae4fa3-37e1-4843-8d4b-e8f9d9f35e6d","timestamp":"2026-02-14T09:54:22.663Z"}
{"parentUuid":"73ae4fa3-37e1-4843-8d4b-e8f9d9f35e6d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01GHYmb1B12ChoQ15a6PXEVy","parentToolUseID":"toolu_01GHYmb1B12ChoQ15a6PXEVy","uuid":"f081c4cf-7e61-4061-bf03-0d4832f98c81","timestamp":"2026-02-14T09:54:22.667Z"}
{"parentUuid":"f081c4cf-7e61-4061-bf03-0d4832f98c81","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01GHYmb1B12ChoQ15a6PXEVy","toolUseID":"toolu_01GHYmb1B12ChoQ15a6PXEVy","timestamp":"2026-02-14T09:54:22.727Z","uuid":"14f7f126-6867-4828-b485-2f14e0dad6c0"}
{"parentUuid":"14f7f126-6867-4828-b485-2f14e0dad6c0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01GHYmb1B12ChoQ15a6PXEVy","toolUseID":"toolu_01GHYmb1B12ChoQ15a6PXEVy","timestamp":"2026-02-14T09:54:22.727Z","uuid":"15f1a349-0f45-4cdf-b11d-4d35376e139e"}
{"parentUuid":"73ae4fa3-37e1-4843-8d4b-e8f9d9f35e6d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GHYmb1B12ChoQ15a6PXEVy","type":"tool_result","content":"   730→\n   731→Tickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n   732→\n   733→### `filterEligible` Update\n   734→\n   735→The previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n   736→\n   737→```typescript\n   738→private filterEligible(\n   739→  tasks: TaskRequest[],\n   740→  active: Map<string, Promise<void>>\n   741→): TaskRequest[] {\n   742→  return tasks.filter(task => {\n   743→    if (active.has(task.id)) return false;\n   744→    if (!this.isActionable(task)) return false;\n   745→    return task.dependsOn.every(depId => {\n   746→      if (active.has(depId)) return false;\n   747→      const dep = tasks.find(t => t.id === depId);\n   748→      return !dep || dep.status === \"Done\";\n   749→    });\n   750→  });\n   751→}\n   752→```\n   753→\n   754→### Two Task Loaders\n   755→\n   756→- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n   757→- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n   758→\n   759→Both are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart."}]},"uuid":"ffa39d13-214c-4194-b2c0-4ca1410a2697","timestamp":"2026-02-14T09:54:22.726Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.","numLines":30,"startLine":730,"totalLines":1017}},"sourceToolAssistantUUID":"73ae4fa3-37e1-4843-8d4b-e8f9d9f35e6d"}
{"parentUuid":"ffa39d13-214c-4194-b2c0-4ca1410a2697","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_012eV253fW7btfCfcGELe2Yv","type":"message","role":"assistant","content":[{"type":"text","text":"Here's the conflict precisely:\n\n**Version A** (line 411): 3-param — `filterEligible(actionableTasks, allTasks, active)`. Iterates over `actionableTasks` (dispatch candidates), but checks dependencies against `allTasks` (every status). This is correct per the rationale at lines 408, 754-759.\n\n**Version B** (line 738): 2-param — `filterEligible(tasks, active)`. Uses a single `tasks` list for both iteration and dependency lookup. If `tasks` is the actionable-only list, dependency checks miss `In Progress` tickets. If `tasks` is the all-tasks list, it tries to dispatch non-actionable tickets (but the `isActionable` guard at line 744 catches that).\n\nInterestingly, Version B *could* work if you always pass `allTasks` and rely on `isActionable()` to filter — but then the \"Two Task Loaders\" section (line 754) says `filterEligible()` uses `loadAllTasks()` for dependency checks, implying the 3-param split is the intended design."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1697,"cache_read_input_tokens":43030,"cache_creation":{"ephemeral_5m_input_tokens":1697,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7kyJYrsF8UWW1Hx3Uvy","type":"assistant","uuid":"818fbcd9-67e5-4a68-95ea-189d25a1fcb7","timestamp":"2026-02-14T09:54:30.956Z"}
{"parentUuid":"818fbcd9-67e5-4a68-95ea-189d25a1fcb7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_012eV253fW7btfCfcGELe2Yv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NJHoVjxsDBSooRKvKhciaX","name":"AskUserQuestion","input":{"questions":[{"question":"For filterEligible, which signature do you want? The 3-param version (separate actionable + all lists) is more explicit but the 2-param version (pass allTasks, guard with isActionable) is simpler and functionally equivalent. Which approach?","header":"filterEligible","options":[{"label":"3-param (explicit)","description":"filterEligible(actionableTasks, allTasks, active) — caller pre-filters, function iterates actionable and checks deps against all. More explicit separation of concerns."},{"label":"2-param (simpler)","description":"filterEligible(allTasks, active) — single list, isActionable() guard inside. Simpler call site, same correctness. Caller just passes loadAllTasks()."},{"label":"Keep both, clarify roles","description":"Keep both versions in the plan as alternatives and decide during implementation."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1697,"cache_read_input_tokens":43030,"cache_creation":{"ephemeral_5m_input_tokens":1697,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7kyJYrsF8UWW1Hx3Uvy","type":"assistant","uuid":"863a3ca5-33e2-4ba6-8142-3d8be0282be6","timestamp":"2026-02-14T09:54:36.260Z"}
{"parentUuid":"863a3ca5-33e2-4ba6-8142-3d8be0282be6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01NJHoVjxsDBSooRKvKhciaX","parentToolUseID":"toolu_01NJHoVjxsDBSooRKvKhciaX","uuid":"efab7aeb-4a9c-47ec-b5b4-efe52b47a0a7","timestamp":"2026-02-14T09:54:36.264Z"}
{"parentUuid":"863a3ca5-33e2-4ba6-8142-3d8be0282be6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). To tell you how to proceed, the user said:\nThe user wants to clarify these questions.\n    This means they may have additional information, context or questions for you.\n    Take their response into account and then reformulate the questions if appropriate.\n    Start by asking them what they would like to clarify.\n\n    Questions asked:\n- \"For filterEligible, which signature do you want? The 3-param version (separate actionable + all lists) is more explicit but the 2-param version (pass allTasks, guard with isActionable) is simpler and functionally equivalent. Which approach?\"\n  (No answer provided)","is_error":true,"tool_use_id":"toolu_01NJHoVjxsDBSooRKvKhciaX"}]},"uuid":"350ced38-bbf0-4b3b-aa82-609f39828734","timestamp":"2026-02-14T09:55:19.876Z","toolUseResult":"Error: The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). To tell you how to proceed, the user said:\nThe user wants to clarify these questions.\n    This means they may have additional information, context or questions for you.\n    Take their response into account and then reformulate the questions if appropriate.\n    Start by asking them what they would like to clarify.\n\n    Questions asked:\n- \"For filterEligible, which signature do you want? The 3-param version (separate actionable + all lists) is more explicit but the 2-param version (pass allTasks, guard with isActionable) is simpler and functionally equivalent. Which approach?\"\n  (No answer provided)","sourceToolAssistantUUID":"863a3ca5-33e2-4ba6-8142-3d8be0282be6"}
{"parentUuid":"350ced38-bbf0-4b3b-aa82-609f39828734","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_015ny7gGdkSRm4GTcUZ8DpMA","type":"message","role":"assistant","content":[{"type":"text","text":"What would you like to clarify about the `filterEligible` question? Do you have additional context about how you envisioned these two sections working together?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":750,"cache_read_input_tokens":44727,"cache_creation":{"ephemeral_5m_input_tokens":750,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7m3Wr9X9HFpGzh94tMm","type":"assistant","uuid":"1128037b-1e99-4ae1-b9e0-56671d8c0a91","timestamp":"2026-02-14T09:55:23.199Z"}
{"parentUuid":"1128037b-1e99-4ae1-b9e0-56671d8c0a91","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"abda17fe-3cb3-46b7-8173-42aadc778711","toolUseID":"abda17fe-3cb3-46b7-8173-42aadc778711","timestamp":"2026-02-14T09:55:23.303Z","uuid":"8f0a7342-da65-4f83-937a-70c3632372e3"}
{"parentUuid":"8f0a7342-da65-4f83-937a-70c3632372e3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"abda17fe-3cb3-46b7-8173-42aadc778711","toolUseID":"abda17fe-3cb3-46b7-8173-42aadc778711","timestamp":"2026-02-14T09:55:23.304Z","uuid":"cca1ca34-9ab9-4a69-a3e2-21acb9e8e696"}
{"parentUuid":"cca1ca34-9ab9-4a69-a3e2-21acb9e8e696","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T09:55:23.587Z","uuid":"0675c587-0ea9-42e4-9e69-a37fc49e2135","toolUseID":"abda17fe-3cb3-46b7-8173-42aadc778711"}
{"type":"file-history-snapshot","messageId":"aeb4e5d6-315e-414a-87b3-5c0087cc8d92","snapshot":{"messageId":"aeb4e5d6-315e-414a-87b3-5c0087cc8d92","trackedFileBackups":{},"timestamp":"2026-02-14T09:56:00.887Z"},"isSnapshotUpdate":false}
{"parentUuid":"0675c587-0ea9-42e4-9e69-a37fc49e2135","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":"Explain the considerations of what filterEligible should achieve and I will use that to determine which version (A/B) i had in mind."},"uuid":"aeb4e5d6-315e-414a-87b3-5c0087cc8d92","timestamp":"2026-02-14T09:56:00.547Z","thinkingMetadata":{"maxThinkingTokens":31999},"todos":[],"permissionMode":"default"}
{"parentUuid":"aeb4e5d6-315e-414a-87b3-5c0087cc8d92","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01ALGoEgZ13pkLcUYU8fvu6w","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":55,"cache_read_input_tokens":45512,"cache_creation":{"ephemeral_5m_input_tokens":55,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7m6Y4A5m49TZpGTznE5","type":"assistant","uuid":"5ba38d40-b9cc-41a2-a9f5-ee287522b2d4","timestamp":"2026-02-14T09:56:02.854Z"}
{"parentUuid":"5ba38d40-b9cc-41a2-a9f5-ee287522b2d4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01ALGoEgZ13pkLcUYU8fvu6w","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to explain the considerations/requirements that filterEligible must satisfy, so they can determine which version matches their intent. Let me lay out the problem clearly.","signature":"EuUCCkYICxgCKkD1koThW30NOLWDu8FCUvsdh7SBLuWdS8IeyTUJhYOSU5IP0d3rR/X5koJNuyK6TJid/3wLE4VmcqP6Aw3OYvCQEgxtmcbx0N4dL4wbgsAaDA8jv7pj4Cr6JH535iIwbBSPCP40jvJUzNw+JH9tPDw9h27tAjkEweB0inAOAMsp/yXjiVXoud6FzPb9mB70KswBouxU+2l0772ZWlUl8R6ONgQmM6zSEZyRf2gVNL/WrD0ysFMh9hgSQd5CyVrEthQPuPo9HAIOoQNfWpkFyorvnZoJuHlan5aide3DmPO7V0RMOaE+XEB7ukCWd+PTLAAnFAjF9hdeCnS1eT5DzDmBncFsbOHoyDyGVBZr4SimLDrYFXQyD2AlzAMC6sEJxTvP0djUrlnpoPMdTXDOTiA8u6zDke1atdPN+58S4YgSRS03TUw+3ldi1tFCTZ6fMbgRjA34zJuoUVsBaVCGGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":55,"cache_read_input_tokens":45512,"cache_creation":{"ephemeral_5m_input_tokens":55,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7m6Y4A5m49TZpGTznE5","type":"assistant","uuid":"474a0092-b23f-4cad-a092-6fc7cf387372","timestamp":"2026-02-14T09:56:03.590Z"}
{"parentUuid":"474a0092-b23f-4cad-a092-6fc7cf387372","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01ALGoEgZ13pkLcUYU8fvu6w","type":"message","role":"assistant","content":[{"type":"text","text":"`filterEligible` has two jobs that operate on different scopes:\n\n**Job 1: \"What can I dispatch?\"** — Only tickets in `Needs *` statuses (excluding intervention statuses like `Needs Human Review`). These are the dispatch candidates. A ticket in `Research In Progress` or `Done` or `Blocked` should never be dispatched.\n\n**Job 2: \"Are this ticket's dependencies satisfied?\"** — For each candidate from Job 1, check its `depends_on` list. A dependency is satisfied only if its status is `Done`. This check must see **every** ticket regardless of status, because:\n\n- A dependency in `Plan In Progress` → not done → block\n- A dependency in `Blocked` → not done → block  \n- A dependency in `Needs Research` → not done → block\n- A dependency not found at all → treat as satisfied (deleted/never existed)\n\nThe critical failure mode: after a process restart, the in-memory `active` map is empty. If dependency checks only look at actionable tickets (`Needs *` statuses), a dependency in `Research In Progress` is invisible — it's not actionable and it's not in `active`. The function would incorrectly treat it as \"not found\" → satisfied → premature dispatch of the dependent ticket.\n\n**So the core requirement is:** iterate over a narrow set (actionable only), but resolve dependencies against a wide set (all statuses).\n\nThe two versions differ only in *where* that narrowing happens:\n\n| | Version A (3-param) | Version B (2-param) |\n|---|---|---|\n| Input | Two pre-filtered lists | One list (all tasks) |\n| Narrowing | Done by caller (`loadActionableTasks`) | Done inside via `isActionable()` guard |\n| Dependency lookup | Searches `allTasks` param | Searches same `tasks` param (which is all tasks) |\n| Call site | `filterEligible(actionable, all, active)` | `filterEligible(all, active)` |\n\nBoth are correct **if Version B receives `allTasks`**. Version B is wrong if someone passes only actionable tasks — the dependency lookup would have blind spots.\n\nVersion A makes the contract explicit in the signature: you *must* pass two lists. Version B is simpler but relies on the caller always passing the full list, with the narrowing hidden inside.\n\nDoes that help you identify which one you had in mind?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":55,"cache_read_input_tokens":45512,"cache_creation":{"ephemeral_5m_input_tokens":55,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7m6Y4A5m49TZpGTznE5","type":"assistant","uuid":"b53b415d-0ae9-446c-84d3-d0f00782955d","timestamp":"2026-02-14T09:56:16.250Z"}
{"parentUuid":"b53b415d-0ae9-446c-84d3-d0f00782955d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"a8d472ba-4d25-4b04-8beb-b60e38862b65","toolUseID":"a8d472ba-4d25-4b04-8beb-b60e38862b65","timestamp":"2026-02-14T09:56:16.268Z","uuid":"eaffc96f-e21d-4ec2-b26a-19b08da3fa0f"}
{"parentUuid":"eaffc96f-e21d-4ec2-b26a-19b08da3fa0f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"a8d472ba-4d25-4b04-8beb-b60e38862b65","toolUseID":"a8d472ba-4d25-4b04-8beb-b60e38862b65","timestamp":"2026-02-14T09:56:16.268Z","uuid":"e82e2906-8564-473a-9512-9fc34b118892"}
{"parentUuid":"e82e2906-8564-473a-9512-9fc34b118892","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T09:56:16.542Z","uuid":"ae881eb1-ff14-46f1-99b9-bbb84f049235","toolUseID":"a8d472ba-4d25-4b04-8beb-b60e38862b65"}
{"type":"file-history-snapshot","messageId":"dff7a339-c38b-491c-844a-bcc9c925566a","snapshot":{"messageId":"dff7a339-c38b-491c-844a-bcc9c925566a","trackedFileBackups":{},"timestamp":"2026-02-14T09:58:55.679Z"},"isSnapshotUpdate":false}
{"parentUuid":"ae881eb1-ff14-46f1-99b9-bbb84f049235","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":"in what scenario will someone pass only actionable tasks? since the user only passes feature requests to the spec-agent and spec-agent determines the start state of a task."},"uuid":"dff7a339-c38b-491c-844a-bcc9c925566a","timestamp":"2026-02-14T09:58:55.320Z","thinkingMetadata":{"maxThinkingTokens":31999},"todos":[],"permissionMode":"default"}
{"parentUuid":"dff7a339-c38b-491c-844a-bcc9c925566a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01Vie6Eizf6mGv2xC4V86sdx","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":168,"cache_read_input_tokens":46180,"cache_creation":{"ephemeral_5m_input_tokens":168,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mKRSQZ7ji89TyD3jtC","type":"assistant","uuid":"ef1b553b-a0c0-407e-a769-adc576b4a05a","timestamp":"2026-02-14T09:58:57.513Z"}
{"parentUuid":"ef1b553b-a0c0-407e-a769-adc576b4a05a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01Vie6Eizf6mGv2xC4V86sdx","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user is asking: in what realistic scenario would someone pass only actionable tasks to filterEligible? They're pointing out that since the Spec Agent controls task creation and initial status, and the orchestrator is the only consumer of filterEligible, there's really only one call site.\n\nLet me think about this...\n\nThe user is right. The orchestrator is the only caller of `filterEligible`. There's no external API where someone else calls it with arbitrary inputs. The call site is fully controlled:\n\n```typescript\nconst actionable = await this.loadActionableTasks();\nconst all = await this.loadAllTasks();\nconst eligible = this.filterEligible(actionable, all, active);\n\n\n```\n\nversus just:\n\n```typescript\nconst all = await this.loadAllTasks();\nconst eligible = this.filterEligible(all, active);\n```\n\nThe concern about someone passing the wrong list is really about a future developer making a mistake at a single, well-documented call site—that's a pretty weak argument for the three-parameter version. The user is leaning toward the simpler two-parameter approach since there's only one caller, that caller always has access to all tasks, and the `isActionable()` guard is straightforward enough.\n\nActually, there's a bigger picture here. With the two-parameter version, you only need `loadAllTasks()`—there's no need for a separate `loadActionableTasks()` method at all, since `isActionable()` handles that filtering inside `filterEligible()`. That's one fewer loader to maintain. But the plan at line 754-759 explicitly justifies having two loaders, so if the user goes with the simpler approach, that section needs to be updated to reflect that you'd only need the one loader.","signature":"EpEPCkYICxgCKkDGyU7FTGZSCxEi/ockhQbzkMA0dmJRgdmhm02ZyHPLbqu46tygcvfN2T6pCqWydtp0GeEGZLeuz86KxzfOXbPnEgwNyKTf3q1aGTa18/QaDIEZdKSQBWWCMDkvUSIwm+J8vrw2YEEBRKvpRHALQfOCRdtZX/MM48qRg1wCBOL+FtKKaR+U2CepeZP/hGFXKvgN0OyWPOV4nNkFIdIXINvJEAZevFX9iK9Ks/iy3e3sOx7U3hrDErhFURUpPBY/bF2ptcEAivYyB40oScusv3w5N41o+LySViE9mJkxlBct9sD1MlaLnAfxb9Ijzkt5U2dssks9yK/mfoFd3rf79LZ1TE6YjBmCkel2miZ7WCnvvn8O4bTf40Ln8vC6mRQdIHjknKX8HrwMopQGnrVi/h26je94XpWdMDvgc6RhL39Wi2FttE6qLJmBf50ZMYfaIevFHJmPcCwGmITqcsyjmI/BXKqKGmg0zxaIsU5NBhQVi9yuT8CZgtL8BjjsVSATi+sYjrLPg3cOD+K+LuV/WlQ8l3N2YygyOqTmfN/rQ8GznxaPzSS5UubDKoV4qpm+4VxGTX2jPwQ87O50ziWy5MceUuI3vkfAf8t2AcZV/aF9ZWo2yN0/ngmvdx6cXq72VoFnP9Ot+WjSWat7JqO+ovYZ3oxAHBwtPuxj5jkMSgMpfKfVMLf5qxTQ0H/iPI4c7HpzANBlACB0bHyJookcvuKYkP2drRluLuSxrBANRhXV1kd5WgRr+I0qd8RVUH6jMsdsQUAbHZQXMtzUeK8zIWRgEmVmM9EqnOfFqG4gWyIov39EWPxVPlkRTR2aBff9j8UB3P5WlrPrNp+wVcbvcWqU6L5INGkSnFWfwdapHPA3IpLkrihapfEsQfR2N7lYWvuoknkIzotAj2BQKs1gZULIq3qi8THsu4/6ox/+WOrg8aXqoafVWvfQX0cFNnPGwroXhmVo9J5yPLW583IHEsKj0wTPbcFVtSIZK9mfF0U2hU1bAclepbOT187AjCKruGrzCj9tdrOm6rMYEq/R1jMTJRArrVXpeS24EtqwlCdn4MjKTkTAKGkqqNpkCrNrCb5cGX6cUdHkmtfjjsHp6rHQ7dY0tJsHxQzr4ZDpyTJjmdNAVGAbAdGJpdvAcF91QdDVmEiNijTQbEsRpBJWrDaBeUqULW/EIvQHU8UXqc/StD0Aa6cv9RE2KnJgbpW22kC1w0DTsj5WAxo436Zv+lbEgjhoM1pSzLzXy3c2pXK4fT1Osg1eAfu3dKPj9FwwJoMsjGY3Obx/bAPn69hZtCminYZQ0XfLuPa5q548SQM1NEug0cnLnl/G3kqJxsM2LYiOex25hLJk978+Bn/LZSwYiw3s4s+GM8XRVc+sFEK8H1n7I9C0aBa4yrn9R3bLPVHDC11yrVhIvaPifMgMvKPRJZ4OW8oIPM/T9RlEix9f6LMupOzfB+kLjL3rml6Op6qgOGai4zZ9Gs5GOHQqQ7hinsWsn83GNWwrIb9wAsatYitWUd7Qsv72RBnAKzHIL93ZHTtSsOdB9oXaF4JLZBgq7VaREn3hC0RKBTqLuo0j0I9pTYnIgE8/0+WTGyYpOLLIAdaXs2o0Dhvaxlc4Qsc7OUhW+Jj6FgxiS5Q0Qe9taULcgCdF1CKFiNwHL2NgAHTg4n3WL28xgtspClbQsjc6ZvBcu34XIypqT3DYvtxCUk/LmvkRS1x1k2rTSHXyjJInDcNASQg5QjkX2OWwi+Q88QNsOfqxSJJvsJGVpeW7qb9VWPl1zW/W567qdGqvBHtGmAqtT1OVl8NpXHAF2j4ZKK+d+zypCxviLCrZwnz9MaotzTiA6duMo0b/yE0FHtjdlacon4tIhvweaCzQj0ktnsvpPBeztso3d6VcKPMQgrdVjQTu0Umo3TI5a66VNDyXpXOIUj3gXATTDuL6X0uqLNOsGGloqJVzB4NwLYu9MSlYN6lqY/RkxWAknMoEEiDTi5JBdwVhprgvAZ9YXTsncnMEYKQ1/VbsO2RXnGZBoYq8ECYsO75aVJqU66VknHj3kKfZbYxt79e5kH+5ILE2JxpeG8OTezZ8TqHDPNRO61ogYPOFIShEz428MrQHTlJjUo6DjJhdle+K1hwv/2hiTwwTvDgVpofzrXRke12EX+U5gUndWpSd+dZH6n6/UYB7gENm1b4MltEpUF1Ci2lFEkuweT9ApVZl68at9uhXKvRlpFfgwjeWhOSWG4wowGYMpscJd18dtD3j2sodc7UtYNuyPDecjhOK+lFQZxWlTu2Mpu4jVlCycp+uFsYYck3+MUpT406md5gNfuruIVH1DyCjjE209CYm8G1w7lgeAZjStWr0DLx15kQaaQLTyJQIJ/cg8Zw8nMN9qs5l3PyhfXWLAqddVT1z6W+rtghjKfUvUz8iKOpCZX2458mVtR882txhlV5CjS3fX2YUUhIUvRKl+ANetiZ0QEiYefivbb0anLFDK3KHwvRC4QgeyljePy/venfpzebiLwzy2Gl5BRM1cRqDVeTZEJXOAwIXvE+3sjmv9fOb5XltHDPfpw9bMX9rpJS0HiIYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":168,"cache_read_input_tokens":46180,"cache_creation":{"ephemeral_5m_input_tokens":168,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mKRSQZ7ji89TyD3jtC","type":"assistant","uuid":"9058c0e7-ff53-4e90-93b8-9f0436a5d38a","timestamp":"2026-02-14T09:59:07.785Z"}
{"parentUuid":"9058c0e7-ff53-4e90-93b8-9f0436a5d38a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01Vie6Eizf6mGv2xC4V86sdx","type":"message","role":"assistant","content":[{"type":"text","text":"You're right — there's no realistic scenario. The orchestrator is the only caller, and it always has access to all tasks. There's no external API surface where someone passes a partial list.\n\nThat realization actually simplifies things further: with Version B, you don't need `loadActionableTasks()` at all. The `isActionable()` guard inside `filterEligible` handles the narrowing, so the orchestrator just calls `loadAllTasks()` once and passes it everywhere — to `filterEligible`, to `isTerminal`, to dependency checks. One loader, one list.\n\nThe \"Two Task Loaders\" section (line 754) becomes unnecessary. The whole flow collapses to:\n\n```typescript\nconst all = await this.loadAllTasks();\nconst eligible = this.filterEligible(all, active);\n```\n\nSo the answer is **Version B (2-param), and drop `loadActionableTasks()` entirely**. Want me to update the plan to reflect this, or should we resolve the other 5 issues first and batch all the edits?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":168,"cache_read_input_tokens":46180,"cache_creation":{"ephemeral_5m_input_tokens":168,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mKRSQZ7ji89TyD3jtC","type":"assistant","uuid":"9923c098-8edb-4897-b558-a59fba3597d2","timestamp":"2026-02-14T09:59:10.561Z"}
{"parentUuid":"9923c098-8edb-4897-b558-a59fba3597d2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"7f8f853a-cc62-40c7-a402-a469cb7f5429","toolUseID":"7f8f853a-cc62-40c7-a402-a469cb7f5429","timestamp":"2026-02-14T09:59:10.586Z","uuid":"0d7a2a47-51fd-4f9d-829d-88727443e33f"}
{"parentUuid":"0d7a2a47-51fd-4f9d-829d-88727443e33f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"7f8f853a-cc62-40c7-a402-a469cb7f5429","toolUseID":"7f8f853a-cc62-40c7-a402-a469cb7f5429","timestamp":"2026-02-14T09:59:10.587Z","uuid":"e64d5b95-191f-4706-98eb-e5c91df37652"}
{"parentUuid":"e64d5b95-191f-4706-98eb-e5c91df37652","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T09:59:10.847Z","uuid":"a0704762-7dc2-4f64-8c0a-dffc8dd641fa","toolUseID":"7f8f853a-cc62-40c7-a402-a469cb7f5429"}
{"type":"file-history-snapshot","messageId":"810d9d03-ebbf-478f-bfbd-1fad51a073b5","snapshot":{"messageId":"810d9d03-ebbf-478f-bfbd-1fad51a073b5","trackedFileBackups":{},"timestamp":"2026-02-14T10:00:28.463Z"},"isSnapshotUpdate":false}
{"parentUuid":"a0704762-7dc2-4f64-8c0a-dffc8dd641fa","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":"before u confirm version B, clarify that all tickets (* In Progress) should never be dispatched, not just Research In Progress as you mentioned above."},"uuid":"810d9d03-ebbf-478f-bfbd-1fad51a073b5","timestamp":"2026-02-14T10:00:28.110Z","thinkingMetadata":{"maxThinkingTokens":31999},"todos":[],"permissionMode":"default"}
{"parentUuid":"810d9d03-ebbf-478f-bfbd-1fad51a073b5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01NZ3GijZwgdSXNBsTS158mZ","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":55,"cache_read_input_tokens":47048,"cache_creation":{"ephemeral_5m_input_tokens":55,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mSGAVNWaRj394z5sK7","type":"assistant","uuid":"d6292531-5315-4945-a705-afd3ddbcf1a2","timestamp":"2026-02-14T10:00:30.900Z"}
{"parentUuid":"d6292531-5315-4945-a705-afd3ddbcf1a2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01NZ3GijZwgdSXNBsTS158mZ","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to confirm that the `isActionable()` guard correctly excludes ALL \"In Progress\" statuses, not just Research In Progress. Let me clarify.\n\nThe `isActionable` function from line 726-728:\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nThis checks `startsWith(\"Needs \")` — so any `* In Progress` status (Research In Progress, Plan In Progress, Implement In Progress, etc.) would NOT pass this check since they don't start with \"Needs \". Same for `Done`, `Blocked`, `Backlog`, `Awaiting Merge`.\n\n\nSo the guard is working correctly and excludes all In Progress statuses. I was just using Research In Progress as an example earlier, not implying it was the only one that matters.","signature":"EusICkYICxgCKkAeBq33BoreKXQLjp2qzvmjCpLQ1x0NhVxphzbVpuFw92KEk78915Jb3kJc2GTerb22FMBvv1pYXX8/2PZ6C0ADEgxxWoCB7/9olHlnaRYaDNIUF5z3Yrn4jgiVqiIwEBdQ/5Awketdw/YKBsxa6hfZ1qgxurvDjAbb8p6c74It367tyBt0KwopI+434yIcKtIH4wUe9XEMN/4lTpvERqixhscbexjQNM8xFVAPFJbpZZOQXBFVH+sW/sa5xMiOfPkIP9GIfraGS+Lom/5qTRrSC80xHvYxlewhIHotFHI2za0syPM8Ys55kmDbOWIEi2OcxCQwZiD3ECGoApKS9I1UGrR1zdb7q7nVRg4TxVljU9hvhT9Hye7K/sh6O3mdzDGYSfTo8mADaFSAGb1AISLyJAeUY2yzXgJeCj6nO2ynWV2dm2udJTlsPqyBuiRJtxgzXSXc40KQ18ilQ2wGlDKbD5D8mg9bbDnnOrx2viQoFUtb8u233QT7rbdHPK4PIrZ1VPzBPf6xSf1cSaEZ0bdqYLF5S1vyOPHuwiYNKDx46FpVFhZGl3idfR2Rp6bWizkiVYYuY6O3Z/oEICrdFW/jlKGJ9HW3EpabhHeAmyHnXHyNCjVPw/izW28bm0rJQhQBKk4/XGTbzcIxw9TgRxPq1ogNNfsDDco1115Kfu2BtlSSPQ0M4U2DFO4jMD0xi+Gbq6+0z0X/4Cn8MQVkevIc4OHJN6lhpMcxGB7tYrdY3hYpv/fsNoVRy2z50gqibob+3OntBzDdJXKhW3VhJGuIzuAKT5+7w5nPRMF3+X/QWq2zjWRPEb47IDgNH3VgV5/dzIzxapMvTFr8IWJ05zIKQHvdSaZEsnsFHgW3+FgMr9FcX7Lmr8zyHaKFbSWs1G+uKyu4dtrPLCZ4g3SSB1bTKPlslEQnlTUdlStO9HnnYGmYAntva00696FM0z4xwl99TCCpLPDrne6cGN/SrMFeWivFsng22HrVVBQEBmgrotGiakVm8xzYfQ25D4MoAnGu3q+asr//U2yeMtCWvMT6diQoxOu4dLip1AUaGZtagiqma+8HGwAMJvxNwdFJY4Pkq01K6p9Q2fD/TxnvNUGy4AUllxGw3eEK5ri6/Jm5yiV3YzqWgeEM2z8IPP74qpEFz7HFK0nfb4ph/yqQ3wiO3TagBLnKLKbqozpvIvBJo3aA4jaiQxg58mmgNItQRplFmZKgYVaU29SaqZdUh3HQGc7iOIfaNXRHJce2I173HDQidOuUdEjD4aY1YPMKWuK4EZ3SvV7UZtsDymHEYtHiZwFRFrfmwV0XClZLiriAQHkhrr66ObDwz5z3ARixHvp/g9Z3uZDUvRmUj6WN/2gdfckifXuUukoZKP7RmuUDilBglR0FCdIY+R7SBq6lqiezH9cbmix6I3gC0FzHFaTmlfaGK4L74lH+utH4Us+MDR1m046C4EolA22lhONVB9QqASNrqJ0X1wmrtdiQURQgxHL7GAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":55,"cache_read_input_tokens":47048,"cache_creation":{"ephemeral_5m_input_tokens":55,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mSGAVNWaRj394z5sK7","type":"assistant","uuid":"8dd63111-6fe9-4e6f-8aa0-d1b4322b0c9f","timestamp":"2026-02-14T10:00:36.199Z"}
{"parentUuid":"8dd63111-6fe9-4e6f-8aa0-d1b4322b0c9f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01NZ3GijZwgdSXNBsTS158mZ","type":"message","role":"assistant","content":[{"type":"text","text":"Yes — the `isActionable()` guard handles this correctly. Looking at line 726:\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\n`startsWith(\"Needs \")` excludes **all** `* In Progress` statuses:\n- `Research In Progress` — no\n- `Specification In Progress` — no\n- `Plan In Progress` — no\n- `Implement In Progress` — no\n- `Validate In Progress` — no\n- `Oneshot In Progress` — no\n\nAnd also excludes `Done`, `Blocked`, `Backlog`, `Awaiting Merge`.\n\nOnly `Needs Research`, `Needs Specification`, `Needs Plan`, `Needs Implement`, `Needs Validate` pass — minus the two intervention statuses (`Needs Human Review`, `Needs Human Decision`).\n\nMy earlier mention of \"Research In Progress\" was just one example of the blind-spot failure mode, not the only case. All `* In Progress` statuses are correctly non-dispatchable.\n\nSo Version B is correct: `filterEligible(allTasks, active)` with `isActionable()` inside. Ready to move to issue #2 (Oneshot dispatch gap)?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":55,"cache_read_input_tokens":47048,"cache_creation":{"ephemeral_5m_input_tokens":55,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mSGAVNWaRj394z5sK7","type":"assistant","uuid":"9565fe8b-abe2-4a77-a6bd-35ab04e03308","timestamp":"2026-02-14T10:00:39.973Z"}
{"parentUuid":"9565fe8b-abe2-4a77-a6bd-35ab04e03308","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"1c0ba7e0-5083-4cdc-b2b3-e077a91eaf41","toolUseID":"1c0ba7e0-5083-4cdc-b2b3-e077a91eaf41","timestamp":"2026-02-14T10:00:40.031Z","uuid":"d415e3bc-7842-4421-a2f3-3b6bde0386d0"}
{"parentUuid":"d415e3bc-7842-4421-a2f3-3b6bde0386d0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"1c0ba7e0-5083-4cdc-b2b3-e077a91eaf41","toolUseID":"1c0ba7e0-5083-4cdc-b2b3-e077a91eaf41","timestamp":"2026-02-14T10:00:40.032Z","uuid":"2520a45a-a49d-4092-9975-73cc76a244c0"}
{"parentUuid":"2520a45a-a49d-4092-9975-73cc76a244c0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T10:00:40.287Z","uuid":"d6f59e3e-197c-459d-9f29-0e534852b1b3","toolUseID":"1c0ba7e0-5083-4cdc-b2b3-e077a91eaf41"}
{"type":"file-history-snapshot","messageId":"8bdce879-34f3-4f17-b352-d00810e2e1ee","snapshot":{"messageId":"8bdce879-34f3-4f17-b352-d00810e2e1ee","trackedFileBackups":{},"timestamp":"2026-02-14T10:01:22.130Z"},"isSnapshotUpdate":false}
{"parentUuid":"d6f59e3e-197c-459d-9f29-0e534852b1b3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":"yes choose Version B and  move on to issue #2 and the rest."},"uuid":"8bdce879-34f3-4f17-b352-d00810e2e1ee","timestamp":"2026-02-14T10:01:21.794Z","thinkingMetadata":{"maxThinkingTokens":31999},"todos":[],"permissionMode":"default"}
{"parentUuid":"8bdce879-34f3-4f17-b352-d00810e2e1ee","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01Ei7W5YNeqhw2LJx687og4Z","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":41,"cache_read_input_tokens":47692,"cache_creation":{"ephemeral_5m_input_tokens":41,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mWDWrft5Xb41XoYoHz","type":"assistant","uuid":"4dc16ad6-1f93-47c1-9341-e450580f1be7","timestamp":"2026-02-14T10:01:24.444Z"}
{"parentUuid":"4dc16ad6-1f93-47c1-9341-e450580f1be7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01Ei7W5YNeqhw2LJx687og4Z","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user confirmed Version B for issue #1. Now let me move to issue #2: Oneshot dispatch gap.\n\nLet me re-read the relevant sections to give precise context.","signature":"EsUCCkYICxgCKkDPo54vcRuRbOx22A0ETDJBEmBq72NsWpl9uzDCrcs0jMqag+ljmw8xhuwCydmvuF/0N+zj1AXP3j7bNnO7NwhLEgx0MHDhqcHQlD+wOykaDEtWMUdWhXpbOij1+SIwFq9d1NcDgM1F5ZqRnCgK88kX+GYzmevmNZWDeBA04qQSnKHMvJn4qruv6SX79tg5KqwBlPuONpCNHowVxcIXY2RC37fFV+NQ+h6y/B/4eaK1RCFThwktkGJJYX4dukuOqpQzM6YDkT/0DkKDiPVwIPUkmrDXWqQT+p2xjv0WCQgQkmjWlI+3MWQr/6+s4wtCA0ddvMZrv074mKdhbAxIKgYvlC/dimDEzENl9hTOn6+B669Dn0xKFPIlFh7YL8H8TRRsRf+n79HVG5zhUu7Sz//pMfN8hw4MKVYwQWiimxgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":41,"cache_read_input_tokens":47692,"cache_creation":{"ephemeral_5m_input_tokens":41,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mWDWrft5Xb41XoYoHz","type":"assistant","uuid":"f9db0d56-5988-4661-a08c-252519c3f4ac","timestamp":"2026-02-14T10:01:25.403Z"}
{"parentUuid":"f9db0d56-5988-4661-a08c-252519c3f4ac","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01Ei7W5YNeqhw2LJx687og4Z","type":"message","role":"assistant","content":[{"type":"text","text":"Noted — Version B confirmed. Now issue #2: **Oneshot dispatch gap**."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":41,"cache_read_input_tokens":47692,"cache_creation":{"ephemeral_5m_input_tokens":41,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mWDWrft5Xb41XoYoHz","type":"assistant","uuid":"b00df59b-d375-4c67-965c-2e1cd9fdcf7d","timestamp":"2026-02-14T10:01:26.074Z"}
{"parentUuid":"b00df59b-d375-4c67-965c-2e1cd9fdcf7d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01Ei7W5YNeqhw2LJx687og4Z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VEqK9CMFVCmDZ3ApZwMr9H","name":"Read","input":{"file_path":"REDACTED.md","offset":588,"limit":70},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":41,"cache_read_input_tokens":47692,"cache_creation":{"ephemeral_5m_input_tokens":41,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mWDWrft5Xb41XoYoHz","type":"assistant","uuid":"2474b3f0-71d4-423f-8dd0-7c2deec2e0e3","timestamp":"2026-02-14T10:01:27.417Z"}
{"parentUuid":"2474b3f0-71d4-423f-8dd0-7c2deec2e0e3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01VEqK9CMFVCmDZ3ApZwMr9H","parentToolUseID":"toolu_01VEqK9CMFVCmDZ3ApZwMr9H","uuid":"081d8373-fa67-4cf3-b197-b54f071bd893","timestamp":"2026-02-14T10:01:27.420Z"}
{"parentUuid":"081d8373-fa67-4cf3-b197-b54f071bd893","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01VEqK9CMFVCmDZ3ApZwMr9H","toolUseID":"toolu_01VEqK9CMFVCmDZ3ApZwMr9H","timestamp":"2026-02-14T10:01:27.480Z","uuid":"1d9efada-9f9f-47dd-96fc-29f638ee528d"}
{"parentUuid":"1d9efada-9f9f-47dd-96fc-29f638ee528d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01VEqK9CMFVCmDZ3ApZwMr9H","toolUseID":"toolu_01VEqK9CMFVCmDZ3ApZwMr9H","timestamp":"2026-02-14T10:01:27.480Z","uuid":"2d7d8a53-b900-4292-989c-c0b85824168d"}
{"parentUuid":"2474b3f0-71d4-423f-8dd0-7c2deec2e0e3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VEqK9CMFVCmDZ3ApZwMr9H","type":"tool_result","content":"   588→### Status Enum\n   589→\n   590→```typescript\n   591→enum TaskStatus {\n   592→  // Entry\n   593→  Backlog              = \"Backlog\",\n   594→\n   595→  // Stage: Research\n   596→  NeedsResearch        = \"Needs Research\",\n   597→  ResearchInProgress   = \"Research In Progress\",\n   598→\n   599→  // Stage: Specification (optional — research decides if needed)\n   600→  NeedsSpecification   = \"Needs Specification\",\n   601→  SpecificationInProgress = \"Specification In Progress\",\n   602→\n   603→  // Stage: Plan\n   604→  NeedsPlan            = \"Needs Plan\",\n   605→  PlanInProgress       = \"Plan In Progress\",\n   606→\n   607→  // Stage: Implement\n   608→  NeedsImplement       = \"Needs Implement\",\n   609→  ImplementInProgress  = \"Implement In Progress\",\n   610→\n   611→  // Stage: Validate\n   612→  NeedsValidate        = \"Needs Validate\",\n   613→  ValidateInProgress   = \"Validate In Progress\",\n   614→\n   615→  // Stage: Oneshot (fast-track, decided during research)\n   616→  OneshotInProgress    = \"Oneshot In Progress\",\n   617→\n   618→  // Terminal\n   619→  Done                 = \"Done\",\n   620→  AwaitingMerge        = \"Awaiting Merge\",\n   621→\n   622→  // Intervention (requires human action)\n   623→  Blocked              = \"Blocked\",\n   624→  NeedsHumanReview     = \"Needs Human Review\",\n   625→  NeedsHumanDecision   = \"Needs Human Decision\",\n   626→}\n   627→```\n   628→\n   629→### Stage Transition Diagram\n   630→\n   631→```\n   632→Backlog\n   633→  │\n   634→  ▼\n   635→Needs Research ──→ Research In Progress\n   636→  │\n   637→  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n   638→  │\n   639→  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n   640→               │\n   641→               └──→ Needs Plan (skip spec if pure backend / no UX)\n   642→                      │\n   643→                      ▼\n   644→                    Plan In Progress ──→ Needs Implement\n   645→                      │\n   646→                      ▼\n   647→                    Implement In Progress ──→ Needs Validate\n   648→                      │\n   649→                      ▼\n   650→                    Validate In Progress ──→ Done / Awaiting Merge\n   651→\n   652→ANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n   653→```\n   654→\n   655→### How the Orchestrator Uses Statuses\n   656→\n   657→The orchestrator dispatches workers based on the current status:"}]},"uuid":"abfc7e61-9de2-4350-98a9-d9cd10688b89","timestamp":"2026-02-14T10:01:27.479Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:","numLines":70,"startLine":588,"totalLines":1017}},"sourceToolAssistantUUID":"2474b3f0-71d4-423f-8dd0-7c2deec2e0e3"}
{"parentUuid":"abfc7e61-9de2-4350-98a9-d9cd10688b89","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01Ei7W5YNeqhw2LJx687og4Z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DURsxfQGyAfwGLpfghDotd","name":"Read","input":{"file_path":"REDACTED.md","offset":680,"limit":20},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":41,"cache_read_input_tokens":47692,"cache_creation":{"ephemeral_5m_input_tokens":41,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mWDWrft5Xb41XoYoHz","type":"assistant","uuid":"2d109092-01ac-49da-8541-3acfc187b8b7","timestamp":"2026-02-14T10:01:28.124Z"}
{"parentUuid":"2d109092-01ac-49da-8541-3acfc187b8b7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01DURsxfQGyAfwGLpfghDotd","parentToolUseID":"toolu_01DURsxfQGyAfwGLpfghDotd","uuid":"a01f2da4-8ac0-424b-a9a1-9f964865eb30","timestamp":"2026-02-14T10:01:28.127Z"}
{"parentUuid":"a01f2da4-8ac0-424b-a9a1-9f964865eb30","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01DURsxfQGyAfwGLpfghDotd","toolUseID":"toolu_01DURsxfQGyAfwGLpfghDotd","timestamp":"2026-02-14T10:01:28.190Z","uuid":"9e37167a-fcf0-4703-b95e-227df58aa552"}
{"parentUuid":"9e37167a-fcf0-4703-b95e-227df58aa552","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01DURsxfQGyAfwGLpfghDotd","toolUseID":"toolu_01DURsxfQGyAfwGLpfghDotd","timestamp":"2026-02-14T10:01:28.190Z","uuid":"e42fdc63-3b3c-4b87-9298-f71bd266e74b"}
{"parentUuid":"2d109092-01ac-49da-8541-3acfc187b8b7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DURsxfQGyAfwGLpfghDotd","type":"tool_result","content":"   680→### WORK_RESULT Stage Output\n   681→\n   682→Each stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n   683→\n   684→```yaml\n   685→WORK_RESULT\n   686→---\n   687→success: true\n   688→stage_completed: research\n   689→workflow: staged          # or \"oneshot\"\n   690→next_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n   691→---\n   692→```\n   693→\n   694→### Intervention Statuses\n   695→\n   696→When a worker cannot proceed, it sets one of three intervention statuses:\n   697→\n   698→| Status | Meaning | Example |\n   699→|--------|---------|---------|"}]},"uuid":"004a642f-9cb9-444b-963d-73680108a9c3","timestamp":"2026-02-14T10:01:28.188Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|","numLines":20,"startLine":680,"totalLines":1017}},"sourceToolAssistantUUID":"2d109092-01ac-49da-8541-3acfc187b8b7"}
{"parentUuid":"004a642f-9cb9-444b-963d-73680108a9c3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01Ar6ixPMGYNtHDNBkkx9NTi","type":"message","role":"assistant","content":[{"type":"text","text":"Here's the problem:\n\nThe `stagePromptMap` (line 660) maps these `Needs *` statuses to prompts:\n\n```\n\"Needs Research\"      → agent2-worker-research.md\n\"Needs Specification\" → agent2-worker-specification.md\n\"Needs Plan\"          → agent2-worker-plan.md\n\"Needs Implement\"     → agent2-worker-implement.md\n\"Needs Validate\"      → agent2-worker-validate.md\n```\n\nThe transition diagram (line 637) shows:\n```\nResearch In Progress ──SIMPLE──→ Oneshot In Progress ──→ Done\n```\n\nBut there's no `NeedsOneshot` status in the enum, and no `\"Needs Oneshot\"` entry in `stagePromptMap`. So after Research decides \"this is simple, go oneshot\" — what `next_status` does it output, and how does the orchestrator dispatch the oneshot worker?\n\nThere are two ways to resolve this:\n\n**Option A: Add `NeedsOneshot` status** — Research outputs `next_status: \"Needs Oneshot\"`, orchestrator maps it to `agent2-worker-oneshot.md`, dispatches a fresh worker. Consistent with the \"one stage per invocation\" pattern. Requires adding one enum value and one `stagePromptMap` entry.\n\n**Option B: Research runs oneshot inline** — When Research determines it's simple, it runs the oneshot implementation within the same invocation (same sandbox). Research outputs `next_status: \"Done\"` directly. Simpler (no extra status), but breaks the \"independent worker per stage\" pattern and means Research sometimes needs a sandbox (for the oneshot code execution) even though the plan says Research can run locally."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1342,"cache_read_input_tokens":47733,"cache_creation":{"ephemeral_5m_input_tokens":1342,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mWfdVAGph47G5wkRwL","type":"assistant","uuid":"3b38c8f8-419a-4fa5-a186-2c6bf2a542be","timestamp":"2026-02-14T10:01:39.777Z"}
{"parentUuid":"3b38c8f8-419a-4fa5-a186-2c6bf2a542be","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01Ar6ixPMGYNtHDNBkkx9NTi","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MoJzuNAiV6Nossh2b7dniK","name":"AskUserQuestion","input":{"questions":[{"question":"How should oneshot be dispatched after Research determines the task is simple?","header":"Oneshot gap","options":[{"label":"Add NeedsOneshot status","description":"Research outputs next_status: \"Needs Oneshot\". Orchestrator dispatches a fresh worker with agent2-worker-oneshot.md. Consistent with one-stage-per-invocation pattern."},{"label":"Research runs oneshot inline","description":"Research detects simple task and runs the implementation in the same invocation. Outputs next_status: \"Done\" directly. Simpler but breaks the stateless worker pattern and requires Research to sometimes have a sandbox."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1342,"cache_read_input_tokens":47733,"cache_creation":{"ephemeral_5m_input_tokens":1342,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mWfdVAGph47G5wkRwL","type":"assistant","uuid":"ec0fb9fc-8030-4959-ba90-1141352eb9e5","timestamp":"2026-02-14T10:01:42.925Z"}
{"parentUuid":"ec0fb9fc-8030-4959-ba90-1141352eb9e5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01MoJzuNAiV6Nossh2b7dniK","parentToolUseID":"toolu_01MoJzuNAiV6Nossh2b7dniK","uuid":"d98ca474-af5a-431d-bc13-50e3f950a73e","timestamp":"2026-02-14T10:01:42.929Z"}
{"parentUuid":"d98ca474-af5a-431d-bc13-50e3f950a73e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01MoJzuNAiV6Nossh2b7dniK","toolUseID":"toolu_01MoJzuNAiV6Nossh2b7dniK","timestamp":"2026-02-14T10:02:00.495Z","uuid":"57af7432-bfb5-4d04-9dcb-60c1f0115f51"}
{"parentUuid":"ec0fb9fc-8030-4959-ba90-1141352eb9e5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"How should oneshot be dispatched after Research determines the task is simple?\"=\"Add NeedsOneshot status\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01MoJzuNAiV6Nossh2b7dniK"}]},"uuid":"ea7bd17e-dbd2-4742-b6ac-a716135d29d3","timestamp":"2026-02-14T10:02:00.493Z","toolUseResult":{"questions":[{"question":"How should oneshot be dispatched after Research determines the task is simple?","header":"Oneshot gap","options":[{"label":"Add NeedsOneshot status","description":"Research outputs next_status: \"Needs Oneshot\". Orchestrator dispatches a fresh worker with agent2-worker-oneshot.md. Consistent with one-stage-per-invocation pattern."},{"label":"Research runs oneshot inline","description":"Research detects simple task and runs the implementation in the same invocation. Outputs next_status: \"Done\" directly. Simpler but breaks the stateless worker pattern and requires Research to sometimes have a sandbox."}],"multiSelect":false}],"answers":{"How should oneshot be dispatched after Research determines the task is simple?":"Add NeedsOneshot status"}},"sourceToolAssistantUUID":"ec0fb9fc-8030-4959-ba90-1141352eb9e5"}
{"parentUuid":"ea7bd17e-dbd2-4742-b6ac-a716135d29d3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01WAbmahdMrknuj3sGTAQG86","type":"message","role":"assistant","content":[{"type":"text","text":"Got it — **Add `NeedsOneshot` to the enum + `stagePromptMap`**. Research outputs `next_status: \"Needs Oneshot\"`, orchestrator dispatches a fresh worker with `agent2-worker-oneshot.md`. Clean and consistent.\n\n---\n\n**Issue #3: `executeWorker` vs `dispatchStage` naming conflict**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":793,"cache_read_input_tokens":49075,"cache_creation":{"ephemeral_5m_input_tokens":793,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mZ3pHPkRKnZ5NssRH3","type":"assistant","uuid":"41f7fa28-365f-46df-917b-154840bf2f05","timestamp":"2026-02-14T10:02:04.057Z"}
{"parentUuid":"41f7fa28-365f-46df-917b-154840bf2f05","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01WAbmahdMrknuj3sGTAQG86","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013wWMJRgZoW8X12nVRvkUrH","name":"Read","input":{"file_path":"REDACTED.md","offset":474,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":793,"cache_read_input_tokens":49075,"cache_creation":{"ephemeral_5m_input_tokens":793,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mZ3pHPkRKnZ5NssRH3","type":"assistant","uuid":"780ed7b9-3b2f-40ef-9ecc-aaec4cb67097","timestamp":"2026-02-14T10:02:04.788Z"}
{"parentUuid":"780ed7b9-3b2f-40ef-9ecc-aaec4cb67097","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_013wWMJRgZoW8X12nVRvkUrH","parentToolUseID":"toolu_013wWMJRgZoW8X12nVRvkUrH","uuid":"511cf3ff-4f91-4166-a1d2-505a96ce681d","timestamp":"2026-02-14T10:02:04.791Z"}
{"parentUuid":"511cf3ff-4f91-4166-a1d2-505a96ce681d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_013wWMJRgZoW8X12nVRvkUrH","toolUseID":"toolu_013wWMJRgZoW8X12nVRvkUrH","timestamp":"2026-02-14T10:02:04.853Z","uuid":"73c4d11e-03ec-4038-83f2-b9dc01e455d3"}
{"parentUuid":"73c4d11e-03ec-4038-83f2-b9dc01e455d3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_013wWMJRgZoW8X12nVRvkUrH","toolUseID":"toolu_013wWMJRgZoW8X12nVRvkUrH","timestamp":"2026-02-14T10:02:04.853Z","uuid":"43db30e7-cc50-410b-9bd0-5fcbec70bced"}
{"parentUuid":"780ed7b9-3b2f-40ef-9ecc-aaec4cb67097","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013wWMJRgZoW8X12nVRvkUrH","type":"tool_result","content":"   474→### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n   475→\n   476→Each invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n   477→\n   478→Key behaviors:\n   479→1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n   480→2. **Branch name** passed to worker prompt uses `branchName(task)`\n   481→3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n   482→4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n   483→5. **`variant_hint`** included in worker prompt when present\n   484→6. Returns parsed WORK_RESULT including `nextStatus` field\n   485→7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot\n   486→8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n   487→\n   488→### `writeResults(task, result)` — Update MD File"}]},"uuid":"e7f4387b-32d7-455e-abed-32c608fbff12","timestamp":"2026-02-14T10:02:04.851Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot\n8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n\n### `writeResults(task, result)` — Update MD File","numLines":15,"startLine":474,"totalLines":1017}},"sourceToolAssistantUUID":"780ed7b9-3b2f-40ef-9ecc-aaec4cb67097"}
{"parentUuid":"e7f4387b-32d7-455e-abed-32c608fbff12","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01WAbmahdMrknuj3sGTAQG86","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NrgD6YTGG4kwmWcPGNABim","name":"Read","input":{"file_path":"REDACTED.md","offset":966,"limit":20},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":793,"cache_read_input_tokens":49075,"cache_creation":{"ephemeral_5m_input_tokens":793,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mZ3pHPkRKnZ5NssRH3","type":"assistant","uuid":"28974565-00ba-44dd-a9e6-a2bebaf24f53","timestamp":"2026-02-14T10:02:05.510Z"}
{"parentUuid":"28974565-00ba-44dd-a9e6-a2bebaf24f53","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01NrgD6YTGG4kwmWcPGNABim","parentToolUseID":"toolu_01NrgD6YTGG4kwmWcPGNABim","uuid":"26ce6279-cef1-43c5-ace8-048fcb57dd03","timestamp":"2026-02-14T10:02:05.512Z"}
{"parentUuid":"26ce6279-cef1-43c5-ace8-048fcb57dd03","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01NrgD6YTGG4kwmWcPGNABim","toolUseID":"toolu_01NrgD6YTGG4kwmWcPGNABim","timestamp":"2026-02-14T10:02:05.575Z","uuid":"8acf33e8-a75c-45ba-89f8-f5d45d97aa5d"}
{"parentUuid":"8acf33e8-a75c-45ba-89f8-f5d45d97aa5d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01NrgD6YTGG4kwmWcPGNABim","toolUseID":"toolu_01NrgD6YTGG4kwmWcPGNABim","timestamp":"2026-02-14T10:02:05.575Z","uuid":"3aa35ab3-e80b-41d1-b460-324fcdd86dc9"}
{"parentUuid":"28974565-00ba-44dd-a9e6-a2bebaf24f53","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NrgD6YTGG4kwmWcPGNABim","type":"tool_result","content":"   966→### Orchestrator Integration\n   967→\n   968→Modify `executeWorker()` to include the test-writer step:\n   969→\n   970→```typescript\n   971→private async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n   972→  const sandbox = await this.createSandbox(task);\n   973→\n   974→  // Step 1: Implementation worker\n   975→  const implResult = await this.runWorkerAgent(sandbox, task);\n   976→\n   977→  // Step 2: Test-writer (same sandbox, deterministic)\n   978→  const isTerminal = await this.isTerminal(task);\n   979→  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n   980→  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n   981→\n   982→  return { impl: implResult, tests: testResult };\n   983→}\n   984→```\n   985→"}]},"uuid":"a7dd1f60-78d5-4618-aa91-d2bd0fdb330e","timestamp":"2026-02-14T10:02:05.573Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n","numLines":20,"startLine":966,"totalLines":1017}},"sourceToolAssistantUUID":"28974565-00ba-44dd-a9e6-a2bebaf24f53"}
{"parentUuid":"a7dd1f60-78d5-4618-aa91-d2bd0fdb330e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01RM1HYVwuGJu3VJAGQ8JWpV","type":"message","role":"assistant","content":[{"type":"text","text":"Phase 3 (line 474) renames `executeWorker` → `dispatchStage` — handles one stage, may or may not use a sandbox.\n\nPhase 5 (line 971) uses `executeWorker` — creates a sandbox, runs implementation + test-writer in sequence.\n\nThese describe different scopes:\n- `dispatchStage` = the general \"run one stage\" method (any stage, sandbox or local)\n- Phase 5's `executeWorker` = specifically the sandboxed stages (Implement/Validate/Oneshot) where the test-writer piggybacks\n\nThe simplest resolution: `dispatchStage` remains the top-level method. For sandboxed stages, `dispatchStage` internally calls a helper (e.g., `runSandboxedStage`) that handles sandbox creation + impl + test-writer. For local stages (Research/Spec/Plan), `dispatchStage` calls `runLocalStage` instead."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":962,"cache_read_input_tokens":49868,"cache_creation":{"ephemeral_5m_input_tokens":962,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mZRUXH3YEhUHU2tbpy","type":"assistant","uuid":"6d547375-2aa5-4ed1-a551-f31e23c5274a","timestamp":"2026-02-14T10:02:12.533Z"}
{"parentUuid":"6d547375-2aa5-4ed1-a551-f31e23c5274a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01RM1HYVwuGJu3VJAGQ8JWpV","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LZbaRscC2Qr7uyiNaya1KF","name":"AskUserQuestion","input":{"questions":[{"question":"For the naming conflict: keep `dispatchStage` as the top-level method, and rename Phase 5's `executeWorker` to something like `runSandboxedStage` (only used for Implement/Validate/Oneshot)?","header":"Naming","options":[{"label":"Yes, dispatchStage + runSandboxedStage","description":"dispatchStage is the top-level router. It calls runSandboxedStage (sandbox + impl + tests) for Implement/Validate/Oneshot, and runLocalStage for Research/Spec/Plan."},{"label":"Keep executeWorker","description":"Don't rename. Use executeWorker for the sandbox path and dispatchStage as an alias or drop it."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":962,"cache_read_input_tokens":49868,"output_tokens":469,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":962},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7mZRUXH3YEhUHU2tbpy","type":"assistant","uuid":"6d906a92-6667-4e75-b9eb-19fad696b7ac","timestamp":"2026-02-14T10:02:25.833Z"}
{"parentUuid":"6d906a92-6667-4e75-b9eb-19fad696b7ac","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01LZbaRscC2Qr7uyiNaya1KF","parentToolUseID":"toolu_01LZbaRscC2Qr7uyiNaya1KF","uuid":"aad5cbbc-7daa-4300-abb3-2229f30be3a3","timestamp":"2026-02-14T10:02:25.838Z"}
{"parentUuid":"6d906a92-6667-4e75-b9eb-19fad696b7ac","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). To tell you how to proceed, the user said:\nThe user wants to clarify these questions.\n    This means they may have additional information, context or questions for you.\n    Take their response into account and then reformulate the questions if appropriate.\n    Start by asking them what they would like to clarify.\n\n    Questions asked:\n- \"For the naming conflict: keep `dispatchStage` as the top-level method, and rename Phase 5's `executeWorker` to something like `runSandboxedStage` (only used for Implement/Validate/Oneshot)?\"\n  (No answer provided)","is_error":true,"tool_use_id":"toolu_01LZbaRscC2Qr7uyiNaya1KF"}]},"uuid":"59484549-bc7f-4313-b61e-a8449ee48e73","timestamp":"2026-02-14T10:03:16.972Z","toolUseResult":"Error: The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). To tell you how to proceed, the user said:\nThe user wants to clarify these questions.\n    This means they may have additional information, context or questions for you.\n    Take their response into account and then reformulate the questions if appropriate.\n    Start by asking them what they would like to clarify.\n\n    Questions asked:\n- \"For the naming conflict: keep `dispatchStage` as the top-level method, and rename Phase 5's `executeWorker` to something like `runSandboxedStage` (only used for Implement/Validate/Oneshot)?\"\n  (No answer provided)","sourceToolAssistantUUID":"6d906a92-6667-4e75-b9eb-19fad696b7ac"}
{"parentUuid":"59484549-bc7f-4313-b61e-a8449ee48e73","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01A4bmCJ8b9Z1AKHNqJM2VEw","type":"message","role":"assistant","content":[{"type":"text","text":"What would you like to clarify about the naming question?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":665,"cache_read_input_tokens":50830,"cache_creation":{"ephemeral_5m_input_tokens":665,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7megYHJ6R62yNhgy3fu","type":"assistant","uuid":"48f1635b-e419-4342-84e6-d700b82ec1fc","timestamp":"2026-02-14T10:03:19.261Z"}
{"parentUuid":"48f1635b-e419-4342-84e6-d700b82ec1fc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"574e2691-bd57-492c-8b1d-35aff919573f","toolUseID":"574e2691-bd57-492c-8b1d-35aff919573f","timestamp":"2026-02-14T10:03:19.290Z","uuid":"15e4ed19-8ffd-486f-aebe-20c64d8a5f70"}
{"parentUuid":"15e4ed19-8ffd-486f-aebe-20c64d8a5f70","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"574e2691-bd57-492c-8b1d-35aff919573f","toolUseID":"574e2691-bd57-492c-8b1d-35aff919573f","timestamp":"2026-02-14T10:03:19.290Z","uuid":"4fa67f14-aa7b-479c-91ea-b23e99c8daca"}
{"parentUuid":"4fa67f14-aa7b-479c-91ea-b23e99c8daca","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T10:03:19.588Z","uuid":"dc580b06-f57e-438a-8660-7c4c049e8b8f","toolUseID":"574e2691-bd57-492c-8b1d-35aff919573f"}
{"parentUuid":"dc580b06-f57e-438a-8660-7c4c049e8b8f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"system","subtype":"turn_duration","durationMs":48807,"timestamp":"2026-02-14T10:03:19.588Z","uuid":"c81850a9-0c77-475b-bd95-cd37f31be513","isMeta":false}
{"type":"file-history-snapshot","messageId":"bc070062-1287-4be7-aa7d-1d0034e43beb","snapshot":{"messageId":"bc070062-1287-4be7-aa7d-1d0034e43beb","trackedFileBackups":{},"timestamp":"2026-02-14T10:04:22.892Z"},"isSnapshotUpdate":false}
{"parentUuid":"c81850a9-0c77-475b-bd95-cd37f31be513","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":"I actually intended for Research/Spec/Plan to also be ran in the sandbox because running it in the Orchestrator locally will block worker agents from claiming the next non-blocking ticket in the queue right?"},"uuid":"bc070062-1287-4be7-aa7d-1d0034e43beb","timestamp":"2026-02-14T10:04:22.548Z","thinkingMetadata":{"maxThinkingTokens":31999},"todos":[],"permissionMode":"default"}
{"parentUuid":"bc070062-1287-4be7-aa7d-1d0034e43beb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01MuvPRQrQ9aCC2JwEgVTYD6","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":67,"cache_read_input_tokens":51508,"cache_creation":{"ephemeral_5m_input_tokens":67,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mjYZSobJbztPRiCGaz","type":"assistant","uuid":"9eae9d53-ae6b-4e92-9d20-219957c5a7c7","timestamp":"2026-02-14T10:04:25.785Z"}
{"parentUuid":"9eae9d53-ae6b-4e92-9d20-219957c5a7c7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01MuvPRQrQ9aCC2JwEgVTYD6","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user is pointing out that if Research/Spec/Plan run locally (in the orchestrator process), they block the orchestrator's event loop, preventing it from dispatching other eligible tickets in parallel. Running all stages in sandboxes keeps the orchestrator free to poll and dispatch.\n\nLet me think about this...\n\nThe orchestrator is a continuous loop that:\n1. Loads tasks\n2. Filters eligible ones\n3. Dispatches workers (up to N parallel)\n4. Waits for any to complete\n5. Repeats\n\nIf Research/Spec/Plan run locally via ClaudeSpawner (which spawns a local `claude` CLI process), they would still be async — the orchestrator awaits them as promises, same as sandbox-based stages. So they wouldn't actually block the event loop in the JavaScript sense.\n\n\nBut they'd still consume one of the N concurrency slots and tie up local machine resources like CPU and memory for the Claude CLI process, whereas sandboxed stages run remotely. The real concern might be about resource contention on the local machine or keeping the dispatch mechanism uniform across all stages for simplicity. 3. The orchestrator's concurrency model treats all dispatched tasks the same way — whether `dispatchStage` runs locally or in a sandbox, it's still a promise in the `active` map counting toward `maxConcurrency`. So local stages would occupy concurrency slots just like remote ones.\n\nThe user's point about simplicity is compelling though: if you're already paying for Daytona sandboxes, running everything there eliminates local resource contention and keeps the orchestrator lean with just one execution path. The tradeoff is that Research/Spec/Plan don't need code modification, so a sandbox feels like overkill, but the operational simplicity might be worth it.\n\nActually, let me reconsider what the user meant by \"blocking.\" If ClaudeSpawner spawns `claude -p` as an async child process with streaming JSON parsing, it shouldn't block the orchestrator loop from dispatching other tasks. Unless they're thinking of a synchronous blocking call, but that doesn't match the implementation. might be a practical concern: if you run N local Claude processes for Research/Spec/Plan stages, plus the orchestrator itself, you're running N+1 Claude instances on the same machine, which could be resource-intensive. Whereas sandboxed stages run remotely.\n\nI think the user's main concern is simpler though: they want all stages to run in sandboxes for uniformity and to keep the orchestrator lightweight. This eliminates the need for separate code paths handling local versus sandboxed execution — everything just goes through `dispatchStage` to create a sandbox. It also cleanly resolves the naming question since there's no distinction to make anymore.\n\nLet me check this understanding with the user and ask the naming question more directly.","signature":"ErofCkYICxgCKkAGyMR4obrUTSIi1YB76c4P3ITyQuKDTfMtTo/WOWuD0bh6Hv0gWSk3e79xOxxyXdR0gLEluxa8311l+rrfuV6wEgyxC9vsiaVi3aG0GM0aDIrq2mKhtumomOFaBCIwdL+xSLntTb6Quysui9zV3a8PUFe1Nni/ImfE7EJUY9O4OPgExC5B1rYlojjJlvpMKqEepx7mLZDPm4GKLGsRQlhgt+xOwV3Hxt2motpIaWiTM1AsixuophPsGlpk9TLpBUZpWVuFJl8kpOM0g4d4dxF7qbLnkPs8O2TE9brGZdyX2R9Pcagkq2ozaY67lV/HML8K3fgNEBfO0ruCzf8uj3BqmcrYg3xIP3xm+KOxEPM0ewC6MLqzLCE4eAqYt3yviqCUKeypqMcTAxIfvKhh5KVkpRWdqgTIa3zYh2xgEEHOAUEluhCcrCvA2HkGEvyNRidVMldZGZECykTzFGq0rHfnPt9ZkwdVKKvWfISoOkNSIt69i65eXtye85kIgOdrnsTf7Ypj2QM5e8xjYT+Rkn3n0BSLqgf000H0KOF9TyoFTJR+hoYBrspJaxMTYOB3C20FjSuUYKVfycQBDWIOLF7aP+45kY0heInPeQbdPRxilYJMr1K80jsUSbLJf4hnYRJlyVCAfQMvEQg8h3UxkewrsFIrfsfuYGXX+jpf6o394QfS7t/ZHLTjAgHC1u4AvakmtGCBlWZVhmfK0U8rLYh+KWZVAxT+nh0JveL9sAAYPww0Dskka2OaH3TmBsulsU11EldwnLvnQ24P2RFUI7VQxQHrpKglavlWy1l0XbMgafasl6/ZgngLML08ceRMtMCB4JUB7mckUQpPXoDSj9QgXZeb+fnbEAtj0khNRWq274PzATW9KmMXqBU1znWXePVKapfjjIxWPjr4FH8abfO9BVA1k2rYLndaI7vsgZA8rbDcODNp96gg1hcm+YpFBjBLUlXjBxGe1Oe74+xLqGW1Q9lhPU/4xWh8fzLRZtYyhPmht8+Dcgvj1LHfIzy+8mrZnEW6TFMr1ltUWXbd/+PA4tkAac5K9L/4VHokOJXQ1QclRJ3bGcAzhKFFWka5rR8qObkGX0R4DBky4soSrS5UgsZ6V0IsO/k1+jFJ5Lho+XvFbAvAuDDS9JqczgTx/a/p9fwAymH810edR8vN1iTTGUyrztd7hGJkbQ3S21Vuz0tvxoTcztAOoI83fvXRxQ51UShcidmLwL6/v8HxD38ey3hGxnHLwOt0y3nRt5PmLkdLvFqjxzDeXxiCckh3vBvRFVxHEiZQfEp7Snfy/CKpTvNBrb5kDF4nxMBfDVyObcYVACanDqGusYOSjQL1kKZrkB8ReGMq7wzAn1wHSr0e5riF9O9UJnH4yVmY++zsXjCCcTddVb8mOXE6PX8yyLBiMBwASaT587FygqAnZLGNZNM9PFw3ms0Qyf2v2/vMVn0YdKOGcCGpCUlCp7mAJ3lWYUG+MoTQsZkSzW+XSPZPVLL0LYuPYrNgbKN1zySbjqjLVQKCnLv6OTYyxj+tFWmbwiviiC+LD3dWJx1EWFS1y/dPMk/GzNC23hAu9izKHSpcAl4PuN83jhGvw5suKa7R9h82Q2zdsGzz5/HHVDYfQDJCq3LNTaPh5lMvGYqGzitSnAWXldUV2lqbwnwuaYgc6Q2iobGgntMVz/Xkr+M9X58hAJCuWk1XqmJkxkf5XdpKYGXtmlWQlpBzr7wD7xW3BduKdSrEwcZR2cZb/erMmBY+Vz9YcTHWzPceWQcfLrZ3p/IewNZk8IjIKfPCsFgr537FAAJhmI5nRZqwAW0zBLyXNk0+wLpRlgtCVLGBSTNRxcLhhoL6A4nc5M2fwQYwsy+qzS8kLlc0gRyeJG1q1b05UapsFks04iHuAZrQ5bhKbsUb20oqbOjp4xLmor/S069k5uQ9gdoAoD/i1GTQRF0dT+v8HBVF5PMFIs07+2MogpHPWPND0We+ef9GY3xNFDALih0JQYxL5KjU/pd5SHLdKycxO9ZduSkusp41t2Z5bOYslqXzU6LAVZnEVd1nNgON3hlTxeOmUwcan8EDREKKSSBuUVzjf5Hi8UNfZ5JI8W38m1MrQP8bQMDpQmhg4FA+TkV5nfVYnmt905DKzMBmX5Ue/YPYUau9hiRL0t4SYTsoz8RkYkXnzj0Npde/y1vXUgNWl6hnuynQs/+G4CmrxBzrWUUtIoEC3BlNSJO+oTFzjm9tzSItaY+q5s8DXy3MAaC9spgw4Rc8qrm85/M+y9YcuAkfLUrloGkCIa/xC51clHSlgijHwCRaA2vYS9IymaCn/MbAjQ+Q0/CnnzdOdKH7F6E/B97OwR6sDYMmj4SApt7TcL0FeDv8PnJ5tcf7PZWUHkWYGQOZ3LLNtkay4R137gwr5wORpc01Pviimcyw+3WFkN0CvbRFV4jz7hpxRWnEIDohonesWxhNHw7E7n41G5sBwjdVGKxA/kIFYtETXtaMvuz+1gMp5Cd4Yt6p26vtTPzHOffLKdSPARqcQIsT7AJykF+bxTv1Zvmf4K9YidI+TnmuHVffA+K0g/mioNvnzdFEqC2LqhnVK764m2mmpGDN+NNERzjPGZHc3I0Yq4Z3m+83LWhGmDsT9rqz826/PgRU7mOQz1sXThQFtNlyNKVUPWCvN4a5IMFuhVdgpTXszf9nVyod/6mb+t1f36ggikScqrhgvfWudhRU5InWrBWSwfs28Ne8d85z1wLOiRTOuaF1w/v9oVSd7DUKLGRnTJZhfYTv7ZMR+7AQUHVDt8R/geti+xBa2IyqxMzf0y4mpOIFYMVCKUYlJsOE3Y8iWWqwcONDHMYhx8W9ojA3VSWq1EVJcNrjd+y1LbggbY5aAew+YF3hc0uhcpK3oa+yxZZCnRh2ZdPUOeMWtS3ZnDog9M6mVjhPlRpqlAilb9rL09lco0TW5qXMUs0bKpGlzyLGkvJco8DL6w21xqY8l42zmmf58LzirAOF9sHsQLvTaKA5vNMR4KrhtSDDetj6qAkLcQ6J5/ZdfS0fQFu7tlyJAzOKSOH81Cdc+tD53E6IsBz2tQtdD147JxDksDr2kDLLwIGeapNiFCwu//hkEvQpDl5ptV0X1QD7hNA0WCcRZHcnxXz2GjvJYhoR08NCCrKSjxcEwedmmaJRuJe9WWhrCsa0D6leHvz4XmIh5DZrxQ35LBKHdn7Vap+IgRmIGAig2o0oKvHp+EdmVermT8kG2boFjdtf0GQxRdxCWokr80FG/YO9AGe2u4I/eTh8/Ijd++mkwgYyciThONuFDzUPAkoc7LdyzXpanXa/Ay2zDlnwRBljj9/QdGl0b1fz9iC3gmryG9AOwYJEYkdYMAIrv3CYI54xWUp6QHF2wR6TYwIdrGxl1+yM0+pd0ZUCm1RhpXFcv4UdVCoYzgVCpecJxPZ8+dPeh54fmDOkklK+TwDa6PKhJyvYacs9YWSqYuVtj3F44rA2OqSCqh1TURZrTd/eJ04FOLE2HF9DFmRGiII/JX1vsiX45lh4RxbhzJBGatxnf5Ahk+jJ2AuKZvwbqwl87+eLuWqyCWrYVQaMIuh4hMgmYxZIhBbGetq83Tateu7x1frKpSZGV9CRy36phXM40nbab8h2cm5hXyJVFgXKoKo1irxqOJiv53KpFMXkuwC5HjoXvQAV9NBoJw3nbAlxRnFuMYtFDTTBWPu/KgABhY5jxwzYl/Vk1gkQ6l8ZQpT0hIl0q3s1LuFeVJek17YPySsEQw+9A3EZfCTZoRKB9FTdZBst7dgQgEzoTdkYwLYTEU2C0pHd0eJHR80Zwx3j+Y17dgJg1rlYvOJTO/beHW8yn54O2R9WBQmAwz/MjJ0dNGeVZiuGWWBiGN4UutfoMNd5SxFC/OV4o9nWcLljRGGQyduzj9RLaMiz0asrxzKW3N9iw092flzeUCzbNrgkf361nBajrNteVcopooUzs/05ttWU61lJ93zMCWnEmtEEB3rFJUvX0oMwujFUTFWeoDBR4xhIN+mClvMwNsnBUoaytLBOXrx5xGkOSY0FgzCBx2tG0hPTEoJDmJ722765F2KDeaNx/eNX5XvS7lY53WA9x2rW/MrLTEgCHkhZBx68hTzlPmHn3auhBbJE2QWyLbdIOLTfh678FN8zmxQP9u/xPEA6LYhKQ7VBKR4Td+JNrL027OijR7BPuRJgabyJkFsHvjlynDaslQ7tjg/S+SA4CAFzYx4459CajG2BvsjwBvWPO1UziYYYWw978p2wgS9aPGh+UvQReyw/srZxF+jiBz182RAeHoSDqnqGF2JKaOSEE9B2O8oP46DZrq+7qoJHN2S56/wWJS6rdlx5ZtgZcjOJRX4RzDMtv2Xs+DZSLXRU4xAC5EUQCFvQKZgWMrEld7OJgk9L1smcpfEf3QQXRt1Bb7+gi+XgbayE17RUnNWRFkEgWmIzIkOY4EqkSnITzhICF6sq006JF3AOVlPi15qTmFslDYu3sDNjuBO2SHSr/3FVX+oHuRBYVm9t8i4aI/PC255D+pv+RxXXJ5HExQ9h98avOrlBf/FHXpwuGar+Y28efefrcxg9cTOx8Aqrfycex87ZRyQtOsO5ja2IaUxbEuEuNZbSDBSD5F//OKmUzoDGYLuOT4kxGzfHIvPYmEGXOa8c5VNAxKGPRvPIc5+ttAQpl1u1gmHxi2q0NXITqyzIXGUX9G4UypnMIX5Zao2Zr52LdQb1NzxHcRhOevRh2hDNn3BJN5gbbW+OwofKzoQqzcvwTuMyVb7jNUPIAE9tlnt4jrIrWhUTfLBMKOfg/w04JvlSkmjRSM29PIDR60vE0g3DJfDvjSWE3RYqnY3DCUs6wpeSkGKURe1LlAky3BcD++2kdvMvhgxj/VfFUvY6LnAjyYWeRrMoBXubUmpDGTJ0JXZ9OTq+p1etnrYMBQt5OlX0QzC99SvXAcBLYACVos8Ci/EwkAzWl3NkR6d1RhDGoy/HjB2p21pzRHwqoz4TlYv8i6ONYP4upiZ74mZEw80wsLcFniNUkndwcvykRXI9nrXET5pd6Y/SPeuRcyRdNwAFunkG3e5XMBJzVinU10+KM7c7+lp9iuNGND7BYLxx3dV0MnL4JW4b3WikqDCuF98EJhQIHfCd7myH76CdH2gZjobao0hdZqjF7IcLCfQrACCpPxNZpbWdjV+zmlF+7K0Seu1jeejAPgneeACwnQnnuhVNuht1Xvfk3TPwT2RIiYp3sl9VksGOnqN4OKKfnyYzqkN2RibkvZ8xqHQ/AFB37xKG8XQ8mJ0Tej4EK9rHsX2yLKDPIDwszwhW7VIqJMFf1tuVAwruVbxvrIDNyUEvwIstQmajEi9FYvftGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":67,"cache_read_input_tokens":51508,"cache_creation":{"ephemeral_5m_input_tokens":67,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mjYZSobJbztPRiCGaz","type":"assistant","uuid":"bb9f8722-8c29-47fd-a73f-b2b35c75c828","timestamp":"2026-02-14T10:04:47.681Z"}
{"parentUuid":"bb9f8722-8c29-47fd-a73f-b2b35c75c828","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01MuvPRQrQ9aCC2JwEgVTYD6","type":"message","role":"assistant","content":[{"type":"text","text":"Good catch. Actually, local ClaudeSpawner calls are async (child process), so they wouldn't block the Node event loop. The orchestrator could still dispatch other tasks while a local Research stage runs. But you'd be running N Claude CLI processes on the local machine, competing for resources with the orchestrator itself.\n\nThat said, running all stages in sandboxes has a cleaner benefit: **uniformity**. One execution path, one dispatch mechanism, no `runLocalStage` vs `runSandboxedStage` split. The orchestrator stays a thin polling/dispatch loop and never runs Claude locally (except the Spec Agent, which is Phase 1's separate entry point).\n\nThis also **eliminates issue #3 entirely**. If all stages run in sandboxes, there's just one method — `dispatchStage` — that always creates a sandbox, runs the stage prompt, and for Implement/Validate/Oneshot also runs the test-writer afterward. No naming conflict because there's no second path."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":67,"cache_read_input_tokens":51508,"cache_creation":{"ephemeral_5m_input_tokens":67,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mjYZSobJbztPRiCGaz","type":"assistant","uuid":"53cba815-82b9-4642-b2d2-27f82dde03f0","timestamp":"2026-02-14T10:04:52.034Z"}
{"parentUuid":"53cba815-82b9-4642-b2d2-27f82dde03f0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01MuvPRQrQ9aCC2JwEgVTYD6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015LxrEbyms7hz3Am2pyZyiP","name":"AskUserQuestion","input":{"questions":[{"question":"Confirm: all worker stages (Research through Validate, including Oneshot) run in Daytona sandboxes. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner. The plan's line 486 ('Research/Spec/Plan can run without a sandbox') should be removed.","header":"All sandboxed?","options":[{"label":"Yes, all stages in sandboxes","description":"Every worker stage runs in a Daytona sandbox. ClaudeSpawner is only used by the Spec Agent (Phase 1). dispatchStage is the single method."},{"label":"No, keep local option","description":"Keep the option for Research/Spec/Plan to run locally for cost savings on stages that don't need code execution."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":67,"cache_read_input_tokens":51508,"cache_creation":{"ephemeral_5m_input_tokens":67,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mjYZSobJbztPRiCGaz","type":"assistant","uuid":"1b850cc3-cb1e-46be-a673-79d2a1bc383d","timestamp":"2026-02-14T10:04:55.853Z"}
{"parentUuid":"1b850cc3-cb1e-46be-a673-79d2a1bc383d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_015LxrEbyms7hz3Am2pyZyiP","parentToolUseID":"toolu_015LxrEbyms7hz3Am2pyZyiP","uuid":"3007afb4-ac7c-444c-8e8e-15600088c56b","timestamp":"2026-02-14T10:04:55.857Z"}
{"parentUuid":"3007afb4-ac7c-444c-8e8e-15600088c56b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_015LxrEbyms7hz3Am2pyZyiP","toolUseID":"toolu_015LxrEbyms7hz3Am2pyZyiP","timestamp":"2026-02-14T10:05:26.709Z","uuid":"e5b6cb43-46da-4170-87d4-d055acffa581"}
{"parentUuid":"1b850cc3-cb1e-46be-a673-79d2a1bc383d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Confirm: all worker stages (Research through Validate, including Oneshot) run in Daytona sandboxes. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner. The plan's line 486 ('Research/Spec/Plan can run without a sandbox') should be removed.\"=\"Yes, all stages in sandboxes\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_015LxrEbyms7hz3Am2pyZyiP"}]},"uuid":"494a6f32-cbfb-4f4f-8b88-b00cf5522779","timestamp":"2026-02-14T10:05:26.707Z","toolUseResult":{"questions":[{"question":"Confirm: all worker stages (Research through Validate, including Oneshot) run in Daytona sandboxes. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner. The plan's line 486 ('Research/Spec/Plan can run without a sandbox') should be removed.","header":"All sandboxed?","options":[{"label":"Yes, all stages in sandboxes","description":"Every worker stage runs in a Daytona sandbox. ClaudeSpawner is only used by the Spec Agent (Phase 1). dispatchStage is the single method."},{"label":"No, keep local option","description":"Keep the option for Research/Spec/Plan to run locally for cost savings on stages that don't need code execution."}],"multiSelect":false}],"answers":{"Confirm: all worker stages (Research through Validate, including Oneshot) run in Daytona sandboxes. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner. The plan's line 486 ('Research/Spec/Plan can run without a sandbox') should be removed.":"Yes, all stages in sandboxes"}},"sourceToolAssistantUUID":"1b850cc3-cb1e-46be-a673-79d2a1bc383d"}
{"parentUuid":"494a6f32-cbfb-4f4f-8b88-b00cf5522779","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_0117EUvYHBRJY6Sg8giayZvk","type":"message","role":"assistant","content":[{"type":"text","text":"Confirmed — all stages sandboxed, issue #3 resolved by elimination. Moving on.\n\n---\n\n**Issue #4: Agent 1 (Reader) and Agent 3 (Writer) — still Claude agents or absorbed into TypeScript?**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1553,"cache_read_input_tokens":51575,"cache_creation":{"ephemeral_5m_input_tokens":1553,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mpFTgu5QeoY9Ln2nQy","type":"assistant","uuid":"25ab293a-e9cd-475c-aee6-077718496393","timestamp":"2026-02-14T10:05:30.348Z"}
{"parentUuid":"25ab293a-e9cd-475c-aee6-077718496393","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_0117EUvYHBRJY6Sg8giayZvk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01X9Uf27LHYq7nUDPGFa7nYe","name":"Read","input":{"file_path":"REDACTED.md","offset":59,"limit":25},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1553,"cache_read_input_tokens":51575,"cache_creation":{"ephemeral_5m_input_tokens":1553,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mpFTgu5QeoY9Ln2nQy","type":"assistant","uuid":"175018b0-9f43-4007-abf0-0d2bb81336d9","timestamp":"2026-02-14T10:05:31.136Z"}
{"parentUuid":"175018b0-9f43-4007-abf0-0d2bb81336d9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01X9Uf27LHYq7nUDPGFa7nYe","parentToolUseID":"toolu_01X9Uf27LHYq7nUDPGFa7nYe","uuid":"86c19416-ec30-4d63-9312-5dfe2a594d27","timestamp":"2026-02-14T10:05:31.139Z"}
{"parentUuid":"86c19416-ec30-4d63-9312-5dfe2a594d27","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01X9Uf27LHYq7nUDPGFa7nYe","toolUseID":"toolu_01X9Uf27LHYq7nUDPGFa7nYe","timestamp":"2026-02-14T10:05:31.197Z","uuid":"d76d386d-a482-4c1f-a93f-b54e6a2de694"}
{"parentUuid":"d76d386d-a482-4c1f-a93f-b54e6a2de694","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01X9Uf27LHYq7nUDPGFa7nYe","toolUseID":"toolu_01X9Uf27LHYq7nUDPGFa7nYe","timestamp":"2026-02-14T10:05:31.197Z","uuid":"98fb9059-4b14-4e58-bc9d-9e535ea3a4ff"}
{"parentUuid":"175018b0-9f43-4007-abf0-0d2bb81336d9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01X9Uf27LHYq7nUDPGFa7nYe","type":"tool_result","content":"    59→### How Prompts Are Used in the Pipeline\n    60→\n    61→```\n    62→User request\n    63→  │\n    64→  ▼\n    65→agent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n    66→  │ Clarification loop until spec meets 5 quality criteria\n    67→  │ Writes tickets to request_queue/\n    68→  ▼\n    69→agent1-linear-reader.md (Queue Reader — IN SANDBOX, adapted for local queue)\n    70→  │ Reads ticket from queue, claims it, outputs context for worker\n    71→  ▼\n    72→agent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n    73→  │ 6-stage pipeline: research → spec → plan → implement → validate\n    74→  │ (or oneshot fast-track)\n    75→  ▼\n    76→agent2-worker-test.md (Test Writer — IN SAME SANDBOX, after worker)\n    77→  │ Writes tests for the implementation, commits to same branch\n    78→  ▼\n    79→agent3-linear-writer.md (Queue Writer — IN SANDBOX, adapted for local queue)\n    80→  │ Parses WORK_RESULT, updates MD file with results + status\n    81→  ▼\n    82→Orchestrator decides: terminal? → PR + merge. Non-terminal? → push, next ticket.\n    83→```"}]},"uuid":"4fcd4c7e-9731-40b3-acc3-1f46066bdf43","timestamp":"2026-02-14T10:05:31.196Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to request_queue/\n  ▼\nagent1-linear-reader.md (Queue Reader — IN SANDBOX, adapted for local queue)\n  │ Reads ticket from queue, claims it, outputs context for worker\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after worker)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nagent3-linear-writer.md (Queue Writer — IN SANDBOX, adapted for local queue)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  ▼\nOrchestrator decides: terminal? → PR + merge. Non-terminal? → push, next ticket.\n```","numLines":25,"startLine":59,"totalLines":1017}},"sourceToolAssistantUUID":"175018b0-9f43-4007-abf0-0d2bb81336d9"}
{"parentUuid":"4fcd4c7e-9731-40b3-acc3-1f46066bdf43","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_0117EUvYHBRJY6Sg8giayZvk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DLoAYEAMgGPwnMF1Ct6kgz","name":"Read","input":{"file_path":"REDACTED.md","offset":860,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1553,"cache_read_input_tokens":51575,"cache_creation":{"ephemeral_5m_input_tokens":1553,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mpFTgu5QeoY9Ln2nQy","type":"assistant","uuid":"29523b5c-f430-4784-8ab9-0a64fa38ccd9","timestamp":"2026-02-14T10:05:31.883Z"}
{"parentUuid":"29523b5c-f430-4784-8ab9-0a64fa38ccd9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01DLoAYEAMgGPwnMF1Ct6kgz","parentToolUseID":"toolu_01DLoAYEAMgGPwnMF1Ct6kgz","uuid":"63450b26-0486-4aae-9df6-f6b04be55f30","timestamp":"2026-02-14T10:05:31.886Z"}
{"parentUuid":"63450b26-0486-4aae-9df6-f6b04be55f30","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01DLoAYEAMgGPwnMF1Ct6kgz","toolUseID":"toolu_01DLoAYEAMgGPwnMF1Ct6kgz","timestamp":"2026-02-14T10:05:31.947Z","uuid":"c3044815-5662-4b2e-bc7f-6d1d51fa4e3e"}
{"parentUuid":"c3044815-5662-4b2e-bc7f-6d1d51fa4e3e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01DLoAYEAMgGPwnMF1Ct6kgz","toolUseID":"toolu_01DLoAYEAMgGPwnMF1Ct6kgz","timestamp":"2026-02-14T10:05:31.947Z","uuid":"8f419119-b5f3-4533-913b-f27e8c25c2c9"}
{"parentUuid":"29523b5c-f430-4784-8ab9-0a64fa38ccd9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DLoAYEAMgGPwnMF1Ct6kgz","type":"tool_result","content":"   860→\n   861→| File | Change |\n   862→|------|--------|\n   863→| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n   864→| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n   865→| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n   866→| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n   867→| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n   868→| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n   869→| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n   870→| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n   871→| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n   872→| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n   873→\n   874→---"}]},"uuid":"70786b61-6412-4e79-aae6-2a35949227ee","timestamp":"2026-02-14T10:05:31.946Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---","numLines":15,"startLine":860,"totalLines":1017}},"sourceToolAssistantUUID":"29523b5c-f430-4784-8ab9-0a64fa38ccd9"}
{"parentUuid":"70786b61-6412-4e79-aae6-2a35949227ee","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_013m36PESfxPW5mSb6xuLRv2","type":"message","role":"assistant","content":[{"type":"text","text":"The pipeline diagram (line 69-80) shows agent1 and agent3 as separate Claude invocations inside the sandbox:\n- **Agent 1** reads the ticket from the queue, claims it, outputs context for the worker\n- **Agent 3** parses WORK_RESULT, updates the MD file with results + status\n\nThe Files table (line 870-871) lists both prompts as needing adaptation.\n\nBut the orchestrator design in Phase 3 handles these responsibilities in TypeScript:\n- `loadAllTasks()` + `filterEligible()` replaces agent1's \"read queue, claim ticket\" logic\n- `writeResults()` + `updateTaskStatus()` replaces agent3's \"parse WORK_RESULT, update MD\" logic\n\nSo there's a contradiction: the pipeline diagram and files table say agent1/agent3 are Claude agents with prompts, but the orchestrator code does their jobs in TypeScript."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1281,"cache_read_input_tokens":53128,"cache_creation":{"ephemeral_5m_input_tokens":1281,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mpdj9DZBScUcEdEPrZ","type":"assistant","uuid":"2521b935-35cb-486b-a6db-fdc85de87a7a","timestamp":"2026-02-14T10:05:38.819Z"}
{"parentUuid":"2521b935-35cb-486b-a6db-fdc85de87a7a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_013m36PESfxPW5mSb6xuLRv2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011BY1eC7ADJ6SgVEw3FXoyf","name":"AskUserQuestion","input":{"questions":[{"question":"Agent 1 (Queue Reader) and Agent 3 (Queue Writer) — should these remain as Claude-powered agents invoked in the sandbox, or should their logic be absorbed into the TypeScript orchestrator?","header":"Agent 1 & 3","options":[{"label":"Absorb into TypeScript","description":"Queue reading, ticket claiming, WORK_RESULT parsing, and MD file updates are all deterministic operations. No LLM reasoning needed. The orchestrator handles it in TypeScript. Drop agent1/agent3 prompts."},{"label":"Keep as Claude agents","description":"Keep agent1 and agent3 as separate Claude invocations in the sandbox, matching the Horizon pattern. Useful if you want the LLM to handle ambiguous parsing or conflict resolution."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1281,"cache_read_input_tokens":53128,"output_tokens":461,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":1281},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7mpdj9DZBScUcEdEPrZ","type":"assistant","uuid":"cc9e5a34-6359-467e-8c35-d6118c5aee2b","timestamp":"2026-02-14T10:05:42.893Z"}
{"parentUuid":"cc9e5a34-6359-467e-8c35-d6118c5aee2b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_011BY1eC7ADJ6SgVEw3FXoyf","parentToolUseID":"toolu_011BY1eC7ADJ6SgVEw3FXoyf","uuid":"ca632935-cbe6-4af8-9aba-f552ad8899f0","timestamp":"2026-02-14T10:05:42.898Z"}
{"parentUuid":"cc9e5a34-6359-467e-8c35-d6118c5aee2b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). To tell you how to proceed, the user said:\nThe user wants to clarify these questions.\n    This means they may have additional information, context or questions for you.\n    Take their response into account and then reformulate the questions if appropriate.\n    Start by asking them what they would like to clarify.\n\n    Questions asked:\n- \"Agent 1 (Queue Reader) and Agent 3 (Queue Writer) — should these remain as Claude-powered agents invoked in the sandbox, or should their logic be absorbed into the TypeScript orchestrator?\"\n  (No answer provided)","is_error":true,"tool_use_id":"toolu_011BY1eC7ADJ6SgVEw3FXoyf"}]},"uuid":"5a2c02f5-0629-4c52-b0c1-6f96e600d9c3","timestamp":"2026-02-14T10:06:31.843Z","toolUseResult":"Error: The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). To tell you how to proceed, the user said:\nThe user wants to clarify these questions.\n    This means they may have additional information, context or questions for you.\n    Take their response into account and then reformulate the questions if appropriate.\n    Start by asking them what they would like to clarify.\n\n    Questions asked:\n- \"Agent 1 (Queue Reader) and Agent 3 (Queue Writer) — should these remain as Claude-powered agents invoked in the sandbox, or should their logic be absorbed into the TypeScript orchestrator?\"\n  (No answer provided)","sourceToolAssistantUUID":"cc9e5a34-6359-467e-8c35-d6118c5aee2b"}
{"parentUuid":"5a2c02f5-0629-4c52-b0c1-6f96e600d9c3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_012ZYMdMruG8UCXgX17pMaCc","type":"message","role":"assistant","content":[{"type":"text","text":"What would you like to clarify about the agent 1/agent 3 question?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":649,"cache_read_input_tokens":54409,"cache_creation":{"ephemeral_5m_input_tokens":649,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7mu3gQbs1aoCA68q9rk","type":"assistant","uuid":"7694017f-e203-47b6-8fc1-04ab5e5407d4","timestamp":"2026-02-14T10:06:34.035Z"}
{"parentUuid":"7694017f-e203-47b6-8fc1-04ab5e5407d4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"b806b52c-cc3d-44d6-b8c7-5fe3c767e87a","toolUseID":"b806b52c-cc3d-44d6-b8c7-5fe3c767e87a","timestamp":"2026-02-14T10:06:34.057Z","uuid":"d0ea178c-23ee-4b3a-a1dd-68566f88d4a5"}
{"parentUuid":"d0ea178c-23ee-4b3a-a1dd-68566f88d4a5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"b806b52c-cc3d-44d6-b8c7-5fe3c767e87a","toolUseID":"b806b52c-cc3d-44d6-b8c7-5fe3c767e87a","timestamp":"2026-02-14T10:06:34.057Z","uuid":"a5da8bcd-02ce-4e59-a7f9-0981b9972f16"}
{"parentUuid":"a5da8bcd-02ce-4e59-a7f9-0981b9972f16","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T10:06:34.331Z","uuid":"9519137e-5843-4b06-a734-911c805d994a","toolUseID":"b806b52c-cc3d-44d6-b8c7-5fe3c767e87a"}
{"parentUuid":"9519137e-5843-4b06-a734-911c805d994a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"system","subtype":"turn_duration","durationMs":51704,"timestamp":"2026-02-14T10:06:34.332Z","uuid":"d1c1fc04-9f62-4233-a8ea-258a3a410972","isMeta":false}
{"type":"file-history-snapshot","messageId":"2a4ab85b-53ba-4c56-bba6-1e43f1128955","snapshot":{"messageId":"2a4ab85b-53ba-4c56-bba6-1e43f1128955","trackedFileBackups":{},"timestamp":"2026-02-14T10:09:05.540Z"},"isSnapshotUpdate":false}
{"parentUuid":"d1c1fc04-9f62-4233-a8ea-258a3a410972","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":"Is Agent 1 still required to reason about which tickets to prioritize and claim before others? My intention was for the spec agent to do so deterministically with running IDs of tickets, but would it be more robust to use an Agent to also \"double check\" this?\n\nFor Agent 3, would an LLM still be useful to parse the WORK_RESULT logic from the worker agent's completed work or in the new design this is already done?"},"uuid":"2a4ab85b-53ba-4c56-bba6-1e43f1128955","timestamp":"2026-02-14T10:09:05.190Z","thinkingMetadata":{"maxThinkingTokens":31999},"todos":[],"permissionMode":"default"}
{"parentUuid":"2a4ab85b-53ba-4c56-bba6-1e43f1128955","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01S3vNrkdH9etythr6rjfRom","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":121,"cache_read_input_tokens":55078,"cache_creation":{"ephemeral_5m_input_tokens":121,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7n6NsNqqQDXaCz7koyQ","type":"assistant","uuid":"eea9fa10-9728-469f-8c5c-6fab55f4dd7c","timestamp":"2026-02-14T10:09:07.646Z"}
{"parentUuid":"eea9fa10-9728-469f-8c5c-6fab55f4dd7c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01S3vNrkdH9etythr6rjfRom","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user is asking two specific questions:\n\n1. **Agent 1 (Reader)**: Is LLM reasoning needed for ticket prioritization/claiming, or does the deterministic ID-based ordering + dependency graph from the Spec Agent already handle this?\n\n2. **Agent 3 (Writer)**: Is LLM reasoning needed for parsing WORK_RESULT, or is the structured format already parseable with simple TypeScript?\n\nLet me think about both:\n\n**Agent 1 - Prioritization/Claiming:**\n- The Spec Agent produces tickets with explicit `depends_on` fields and sequential `AGI-{n}` IDs\n- The orchestrator's `filterEligible` already handles: dependency satisfaction (block on non-Done deps), actionability (only `Needs *` statuses), and concurrency limits\n\n\n- A topological sort on `depends_on` gives deterministic ordering, and the `active` map prevents double-claiming\n- An LLM could theoretically prioritize between equally eligible tickets, but the plan doesn't define priority fields, so the current design just goes FIFO by ID among eligible ones\n- Adding an LLM \"double check\" would introduce latency and cost on every dispatch cycle, plus risk non-determinism if the model makes different decisions on retry\n\n**Agent 3 - WORK_RESULT parsing:**\n- The WORK_RESULT format is structured YAML between delimiters, so it's straightforward to parse with TypeScript string operations and regex without needing LLM reasoning\n- Unlike Horizon where agent3 generated natural language comments for Linear, napoli-matcha just updates YAML frontmatter and appends structured markdown to files\n- Malformed WORK_RESULT output is better handled through validation and error handling than by invoking another LLM, so both agents can be absorbed into TypeScript","signature":"EpsRCkYICxgCKkDYnWHF4vX+QTxWlsFuvIPPKzK/Ax5Mz2KhtEDmdGpeTv0CWfx+TJI0w7Q6ydty38fjHeB/P5ekjjhlk33Gwr5OEgzyCkwC0RxiGD/fgXIaDHSzSczxG4NUgMUxYCIw0nF2RpY6VYH1g/udgfevwokJGf0rL6zBB1mNY9cI2O98NEilECoYNjdygkSFPqiFKoIQpGq44d4JphcecYUijKyKAzaoC7qecEIEbQXuU62h+ia2MK47/7bXO6AeyIi26ePiPkcsXi7EtbTRis7beL+ZPCuGRVVBOAe1v+BV2WwQylecq/WNg6AILGyQn24vVPHWsKKcCz7Ffuezdi193/8rU1uUqcNXnPB36q9kF80WpXHRjewDgYrKGIV5wDniQ8XgCf7g9Qiq2TbyS/fXcF2EBs5qwInSTVfeoXQ5v9Uh3vSuTPDkkt50mbBMLKc+c1y3yf5I0WKwY/R9m6T0LQnUVJ47cOUeuUgskhM6wXBNqTNjw+phrUJhUPuMkcsvogveALxdH2i/uEH6uZ6rZzvufOTi600iZfjtKbb82D9Sf+pxmdfwl5V3P0rYnYvnBgGaSAuXTfZBjCCqVowa4kpI4b/mv3GmhF99Ad55MNxwuLMacvoRPDwl5LZiBjPxotwKQryFJC3qn2lDS6YNEIFtmVC7t0ANqoSgktTrI0LLFx1EvQacDz6RptyxxjSzSSwfCEySMRvo9KngEwAhT1++hTR+uHH2LnUJ5ckHBYVEW7qBv2G6yEgWrApixYw6NplkYLGaQiGgGXbFCjYcuS487DDWo7cZuqZrRL9GbHgy+HxNU4ui7aZZE82j+Y2i4IKAVIdURzOBZZRM7LrhapuZaBq009tNtZ6RvXlnhov99sD1bQ3nMVh8OMOPC4ltWZFPdpJublC+5siQEXr6A++CfETXkfDW29/O+EuDaaYs/o2/TJQNJyagPR6JoxBx17Lktqt6pz7W/1PI1+Xt3Dqtpkx92cU+Iuq161f3WBpEaCdsmB0+YFGIIduR6Lvm1Mm6voLSvAuq4BkMrM7hFmm8g9ys0rJmK21MQWjUZj5LqtwBemYDCZQnb0pwBNG4YfmFPc3xBa+DZjwYFvun8PnijfvW/5eGNzIs9KBHxNPRT/7lz7VCWJTThJjoUy1ljzEcTe9dPjoPVFKMb/oxqZlxk9YD2XHMM/LZJ+xLX+lGXa+fGhYFB01znMZ5hf6+dvNtk+wL2fDD9RFjjv1AccHsi7vW1uyURHzbSEJd7uYsGnfKMm3SYDPtlUl3mKcMyqkOCwkp+ox5HAnO5PA6+jRWccKRfhdON67XqMGPda6ixNRhVgoKG4svb4QzI6BgkF24pIFPVbgtBbWe2RXWRywoS1Sq1T9iDQTPHlnChose0YnoyYzoFxBV8272Iq5NSRmG1e5BF/tYlz/B9xLWGFe3CDnl/wDYjmdxJQERFkDTVHPbIWanW58zfDSedICvo0VEAKWImHPb0+mnlUfIfmhX2xiErUssXsySaCiKrWCJ4PoL9PBd5YhNj71hdzwP4eEYSqzgoVNDDPZY07457q53uTCOnsfu1acqKgjQOrPKGw5O61JyG4HbkyEEVe9g8KFYxK07BgnjqoOzSVIoNXYA8/AMIue2x/XeOHkGU4TS6KJhFNDDs7ILfuyDRTjYRYoVYwD9teQ2MLZUOUJzrU8hRgOcNLXAQNqXm4c/2Y2ZSjPETA1Fd74S7gtvkI5dzvAsfPpSUBmno0f062LHsEdEWFc6hGQYYEcVQ5iUzIbAzCeFjROY2Mnd5ubxzRCydR0fwd+7zSol1+LYUrnTPDOMLUw8J7Ns6N61bpUCuXsIcmdn/8BUkJWvOFWNSzZ76KEqvmK9GNh0zZL/dgktIm0d6vXuV1tUxCB14t68ojQVYge3w2x4LVcPCbnI2IABVDKgiCzCMPAlEG7+K3JBgR+mmUL8eExCOjljkeCaL30S8Qd34xB3jOfJPPRwRKVMG/6yPtTXoEU8SG27nIGT3uBXYLaM3/ePNYqVgPcbKKzFYtM9Nkl5ZkE6B+FLUdc5RW1JicnQ4ahqrGIsy3d7nw/vzfvPQ9UlL3+J+r8AxYr5E9RRHHYzop9TE8sTIdWbOiFSUVoehkLIUeWp7Q8oGXoRzbVl6r/dA39JUGUcBOsOMMAsgTJMYUvCFeM08rlbp21SLrGbUdnjFj8YKxnPJT79Q4+yI052PgMOcpJ3N4EFdNOJ2+pTwN2o1n7NMLqZHKNgbTwL0iFgBHIYNZkPGdrReMm/i9kqi/0Flm5TN6M98kvrLd2u+9Pl6HGQ2U5AfjVKiDZuK7whTKinIbpMSOfJulqluQBOuVFk+8Z+YW8Hg5RyD3LWNLmvfe6keE9uclOq8Nh4bdDaagq20AW7k8oPpCrhj9lGGemmKtZVA6TB8xQJIEVeox7ZrlTFBtKUydseLZWznMfEh2pyPVJXbqCKgRwOJZtUJW3Ir4GpUCCa3NPe2LOOj0QRVnUmHr+gkMbEPOydutM6+Kh6SZjXv1pJpxhc1cJhnmSwUcmrO3ddW9plxUumBvSXvsKhwKz8g212yPkuZot5Cetw6Um/Edm+aZT6fFSx/S/AJvg32NUKC7gqSQCsggPiQU9sMDk3QUwTVhGhk+9H8vaWthvF/25eUupQWelW7AzUbCUaWaEuGi2NcauGajaUf6YK5gpuu8XscmwdW2vSiqaTMZ3KaW2LIH8ZZICEXrU7A0iXlW6LSIkrJvQN93+cWy2t0DaOG8m3SYJTv9+qNCWgpo8xQeSoWZwOLnX0rQ9zhJi24j+4pAjnyZCA7bmtfsdXF2JRYhg8nSEZBYZRPdB85rPxuk+PE+PvArsJdmP4CpcCv2Pq/pNy86MId1dEQG4HWIRg6fv3ae99Y+YzssnSJO0O8l5afg6vXNjKyfokePSn1jKGh77dcxgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":121,"cache_read_input_tokens":55078,"cache_creation":{"ephemeral_5m_input_tokens":121,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7n6NsNqqQDXaCz7koyQ","type":"assistant","uuid":"fd141a31-22af-44e9-afd9-5ac3be0ee003","timestamp":"2026-02-14T10:09:21.463Z"}
{"parentUuid":"fd141a31-22af-44e9-afd9-5ac3be0ee003","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01S3vNrkdH9etythr6rjfRom","type":"message","role":"assistant","content":[{"type":"text","text":"Good questions. Let me break down what each agent would actually reason about vs. what's already deterministic.\n\n**Agent 1 — Prioritization/Claiming:**\n\nThe orchestrator already handles this deterministically:\n- `filterEligible` checks dependency satisfaction (only `Done` deps pass) and actionability (`Needs *` statuses only)\n- `depends_on` encodes the execution order — topological sort is deterministic\n- The `active` map prevents double-claiming\n- Among equally eligible tickets (no deps on each other), the plan processes them by ID order (lowest first)\n\nThe only scenario where an LLM adds value is **prioritizing between equally eligible tickets** — e.g., \"AGI-5 and AGI-8 are both eligible, but AGI-8 is more urgent.\" But the plan has no priority field, and the Spec Agent already controls ordering via `depends_on`. An LLM double-check here adds latency and cost on every dispatch cycle, and introduces non-determinism (it might prioritize differently on retry).\n\n**Agent 3 — WORK_RESULT parsing:**\n\nThe WORK_RESULT format is structured YAML between delimiters:\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nnext_status: \"Needs Plan\"\n---\n```\n\nThis is straightforward: find delimiters → extract YAML → parse → read `next_status`. No natural language understanding needed.\n\nIn Horizon, agent3 did more — it composed formatted Linear comments, which required LLM writing. But in napoli-matcha, \"writing results\" means updating YAML frontmatter (`status: Done`) and appending structured markdown. That's string templating, not reasoning.\n\nThe one edge case: malformed WORK_RESULT from a worker that went off-script. But that's better handled by validation + retry/intervention status than by another LLM call.\n\n**My recommendation:** Both are deterministic enough to absorb into TypeScript. The Spec Agent's dependency graph and structured WORK_RESULT format already solved the problems agent1/agent3 were designed for in Horizon's less-structured Linear environment.\n\nWant me to proceed with \"absorb both into TypeScript\" or do you see a case I'm missing?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":121,"cache_read_input_tokens":55078,"cache_creation":{"ephemeral_5m_input_tokens":121,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7n6NsNqqQDXaCz7koyQ","type":"assistant","uuid":"fe0b292f-10a2-46a9-8721-76d8ca68f2a9","timestamp":"2026-02-14T10:09:30.162Z"}
{"parentUuid":"fe0b292f-10a2-46a9-8721-76d8ca68f2a9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"ccd094ca-ceff-4d8e-8b5a-4d1efb8dd05b","toolUseID":"ccd094ca-ceff-4d8e-8b5a-4d1efb8dd05b","timestamp":"2026-02-14T10:09:30.206Z","uuid":"da595e73-811b-4d3d-93a0-d515cae16c9f"}
{"parentUuid":"da595e73-811b-4d3d-93a0-d515cae16c9f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"ccd094ca-ceff-4d8e-8b5a-4d1efb8dd05b","toolUseID":"ccd094ca-ceff-4d8e-8b5a-4d1efb8dd05b","timestamp":"2026-02-14T10:09:30.207Z","uuid":"090b40d4-4371-4e6b-8230-ca700cb6fb78"}
{"parentUuid":"090b40d4-4371-4e6b-8230-ca700cb6fb78","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T10:09:30.461Z","uuid":"f3702d72-5f82-4d9b-ba99-c1fff60aa7e9","toolUseID":"ccd094ca-ceff-4d8e-8b5a-4d1efb8dd05b"}
{"type":"file-history-snapshot","messageId":"506a09e3-765f-460d-a476-048d5166d3e8","snapshot":{"messageId":"506a09e3-765f-460d-a476-048d5166d3e8","trackedFileBackups":{},"timestamp":"2026-02-14T10:10:54.359Z"},"isSnapshotUpdate":false}
{"parentUuid":"f3702d72-5f82-4d9b-ba99-c1fff60aa7e9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":"ok proceed with TypeScript"},"uuid":"506a09e3-765f-460d-a476-048d5166d3e8","timestamp":"2026-02-14T10:10:54.022Z","thinkingMetadata":{"maxThinkingTokens":31999},"todos":[],"permissionMode":"default"}
{"parentUuid":"506a09e3-765f-460d-a476-048d5166d3e8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01GMeuQ8hPu6i8L8VDXeDxqs","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":29,"cache_read_input_tokens":56244,"cache_creation":{"ephemeral_5m_input_tokens":29,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nEQ6WrVnUgdZEorJjs","type":"assistant","uuid":"cd4e688e-c0d2-488b-80a2-e4ab0d2a3a3a","timestamp":"2026-02-14T10:10:56.364Z"}
{"parentUuid":"cd4e688e-c0d2-488b-80a2-e4ab0d2a3a3a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01GMeuQ8hPu6i8L8VDXeDxqs","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"User confirmed: absorb agent1 and agent3 into TypeScript. Moving to issue #5.","signature":"EvUBCkYICxgCKkBnSt6jYsLVulhEWGverrbXrbGnkp6tytSdFQD0L70N0Wv8O+8KY78ks9BTSBJu/jyTikPXf/s9ke6398YaY+jIEgzMNfyy1KPC0U80cS0aDOF7kNWd83ZeLBs3XSIwI2cZFREmDKIM4HesNhiUffEuiXoT16MepSZ9Z6eZQCIPorLlhlqa1T/K+KWBBxIpKl0AwP5FRwaZxnCS7NvJsmY9r5GVg9dCE3VCMTgu2AYgf+iwG/T9gPc5iuGeUEsvP5ienRInG9y3x62f3SRjH23SovI0CK+UFQYdqBGdpmKSgfB0FbwVeHWBC06BBqYYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":29,"cache_read_input_tokens":56244,"cache_creation":{"ephemeral_5m_input_tokens":29,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nEQ6WrVnUgdZEorJjs","type":"assistant","uuid":"f08bfff3-5f21-4b5d-a4e4-fd0aab2e7f33","timestamp":"2026-02-14T10:10:56.905Z"}
{"parentUuid":"f08bfff3-5f21-4b5d-a4e4-fd0aab2e7f33","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01GMeuQ8hPu6i8L8VDXeDxqs","type":"message","role":"assistant","content":[{"type":"text","text":"Confirmed — agent1 and agent3 absorbed into TypeScript, their prompts dropped from the files table.\n\n---\n\n**Issue #5: Unresolved TODO comment about dual IDs (line 257)**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":29,"cache_read_input_tokens":56244,"cache_creation":{"ephemeral_5m_input_tokens":29,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nEQ6WrVnUgdZEorJjs","type":"assistant","uuid":"4ed2a2b6-dbcf-47d0-91dc-3f4189ad0b3f","timestamp":"2026-02-14T10:10:58.089Z"}
{"parentUuid":"4ed2a2b6-dbcf-47d0-91dc-3f4189ad0b3f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01GMeuQ8hPu6i8L8VDXeDxqs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018CL7iSt9d8SKgh5Jmi1NJt","name":"Read","input":{"file_path":"REDACTED.md","offset":255,"limit":25},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":29,"cache_read_input_tokens":56244,"cache_creation":{"ephemeral_5m_input_tokens":29,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nEQ6WrVnUgdZEorJjs","type":"assistant","uuid":"1550c5b9-f4fc-46df-ae19-1bd19edcf28b","timestamp":"2026-02-14T10:10:58.794Z"}
{"parentUuid":"1550c5b9-f4fc-46df-ae19-1bd19edcf28b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_018CL7iSt9d8SKgh5Jmi1NJt","parentToolUseID":"toolu_018CL7iSt9d8SKgh5Jmi1NJt","uuid":"f04356ee-bd8d-4d06-b28c-8b1ce9d1654b","timestamp":"2026-02-14T10:10:58.797Z"}
{"parentUuid":"f04356ee-bd8d-4d06-b28c-8b1ce9d1654b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_018CL7iSt9d8SKgh5Jmi1NJt","toolUseID":"toolu_018CL7iSt9d8SKgh5Jmi1NJt","timestamp":"2026-02-14T10:10:58.853Z","uuid":"11e841b9-97d3-400d-b217-2ab375959d06"}
{"parentUuid":"11e841b9-97d3-400d-b217-2ab375959d06","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_018CL7iSt9d8SKgh5Jmi1NJt","toolUseID":"toolu_018CL7iSt9d8SKgh5Jmi1NJt","timestamp":"2026-02-14T10:10:58.853Z","uuid":"c4b54413-55c5-4c11-8801-23c86d0f5b04"}
{"parentUuid":"1550c5b9-f4fc-46df-ae19-1bd19edcf28b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018CL7iSt9d8SKgh5Jmi1NJt","type":"tool_result","content":"   255→### Writing Tickets\n   256→\n   257→<!-- I need 2 IDs here, one to track the feature requests from the user, the other to track the tickets for the implementation; for ease of implementation, also create a dir \"feature_requests_id\" to store the feature request. If a feature request has variants requsted by the user, create a separate directory to store each \"group\" of tickets per variant -->\n   258→After the spec is complete, writes each ticket as an MD file to `request_queue/`:\n   259→\n   260→```markdown\n   261→---\n   262→id: AGI-8\n   263→title: Add auth middleware\n   264→description: >-\n   265→  Create Express middleware that validates JWT tokens on protected routes.\n   266→  Success criteria: unauthorized requests return 401, valid tokens pass through.\n   267→repo: 'https://github.com/user/repo'\n   268→depends_on: []\n   269→group: dashboard-v2\n   270→variant_hint: >-\n   271→  Use a data-dense table layout. Prioritize information density over whitespace.\n   272→number_of_sandboxes: 1\n   273→status: Needs Plan\n   274→---\n   275→```\n   276→\n   277→The `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n   278→\n   279→### Integration with Existing ID Scheme"}]},"uuid":"67f8a934-3bc8-4990-8be7-0c4ab5df2082","timestamp":"2026-02-14T10:10:58.852Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"### Writing Tickets\n\n<!-- I need 2 IDs here, one to track the feature requests from the user, the other to track the tickets for the implementation; for ease of implementation, also create a dir \"feature_requests_id\" to store the feature request. If a feature request has variants requsted by the user, create a separate directory to store each \"group\" of tickets per variant -->\nAfter the spec is complete, writes each ticket as an MD file to `request_queue/`:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme","numLines":25,"startLine":255,"totalLines":1017}},"sourceToolAssistantUUID":"1550c5b9-f4fc-46df-ae19-1bd19edcf28b"}
{"parentUuid":"67f8a934-3bc8-4990-8be7-0c4ab5df2082","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01XZiPPwSgMsXVRbBtLENxsr","type":"message","role":"assistant","content":[{"type":"text","text":"The TODO comment describes wanting:\n1. **A feature request ID** — tracks the original user request (e.g., \"Build a dashboard with auth, 2 versions\")\n2. **Ticket IDs** — the individual `AGI-{n}` implementation tickets decomposed from that request\n3. **A directory per feature request** — `feature_requests/{id}/` to store the original request and group its tickets\n4. **Separate directories per variant group** if variants were requested\n\nCurrently the plan only has the flat `request_queue/` with `AGI-{n}` ticket IDs. There's no concept of a parent feature request.\n\nThis raises a practical question: do you actually need the feature request ID now, or is it future-proofing? The `group` field already ties variant chains together, and the original user request text could just be stored in each ticket's description."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":586,"cache_read_input_tokens":56273,"cache_creation":{"ephemeral_5m_input_tokens":586,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nEjPsWcx2vVnj7Reqb","type":"assistant","uuid":"8edaa98b-b40f-481f-8ccb-501cb6c0c371","timestamp":"2026-02-14T10:11:06.584Z"}
{"parentUuid":"8edaa98b-b40f-481f-8ccb-501cb6c0c371","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01XZiPPwSgMsXVRbBtLENxsr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PfxuohRtRNst6XGT5u5uYn","name":"AskUserQuestion","input":{"questions":[{"question":"Do you want a separate feature request entity (its own ID + directory), or is the current flat structure (AGI-{n} tickets in request_queue/, linked by `group` field) sufficient?","header":"Feature req ID","options":[{"label":"Keep flat structure","description":"Drop the TODO. Tickets live in request_queue/ with AGI-{n} IDs. The `group` field links variant chains. Original user request is stored in ticket descriptions. Simple."},{"label":"Add feature request layer","description":"Introduce a FR-{n} feature request ID. Create feature_requests/FR-{n}/ directories. Tickets reference their parent FR. Useful for tracking 'which user request spawned these tickets' and for variant grouping."},{"label":"Add FR ID but keep flat dir","description":"Add a `feature_request: FR-{n}` field to ticket frontmatter for traceability, but don't create separate directories. Tickets stay in request_queue/. Lightweight middle ground."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":586,"cache_read_input_tokens":56273,"output_tokens":504,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":586},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7nEjPsWcx2vVnj7Reqb","type":"assistant","uuid":"562dce57-4940-42bb-bef6-02a3fd24f536","timestamp":"2026-02-14T10:11:12.538Z"}
{"parentUuid":"562dce57-4940-42bb-bef6-02a3fd24f536","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01PfxuohRtRNst6XGT5u5uYn","parentToolUseID":"toolu_01PfxuohRtRNst6XGT5u5uYn","uuid":"8f48c3e3-104b-4b10-8a5f-9b940d35c736","timestamp":"2026-02-14T10:11:12.541Z"}
{"parentUuid":"8f48c3e3-104b-4b10-8a5f-9b940d35c736","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01PfxuohRtRNst6XGT5u5uYn","toolUseID":"toolu_01PfxuohRtRNst6XGT5u5uYn","timestamp":"2026-02-14T10:11:42.696Z","uuid":"53a24d46-442e-4657-96a6-855010a4b34b"}
{"parentUuid":"562dce57-4940-42bb-bef6-02a3fd24f536","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Do you want a separate feature request entity (its own ID + directory), or is the current flat structure (AGI-{n} tickets in request_queue/, linked by `group` field) sufficient?\"=\"Add feature request layer\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01PfxuohRtRNst6XGT5u5uYn"}]},"uuid":"b1555b62-ba54-4aaf-96e6-1c6d93fd7b71","timestamp":"2026-02-14T10:11:42.692Z","toolUseResult":{"questions":[{"question":"Do you want a separate feature request entity (its own ID + directory), or is the current flat structure (AGI-{n} tickets in request_queue/, linked by `group` field) sufficient?","header":"Feature req ID","options":[{"label":"Keep flat structure","description":"Drop the TODO. Tickets live in request_queue/ with AGI-{n} IDs. The `group` field links variant chains. Original user request is stored in ticket descriptions. Simple."},{"label":"Add feature request layer","description":"Introduce a FR-{n} feature request ID. Create feature_requests/FR-{n}/ directories. Tickets reference their parent FR. Useful for tracking 'which user request spawned these tickets' and for variant grouping."},{"label":"Add FR ID but keep flat dir","description":"Add a `feature_request: FR-{n}` field to ticket frontmatter for traceability, but don't create separate directories. Tickets stay in request_queue/. Lightweight middle ground."}],"multiSelect":false}],"answers":{"Do you want a separate feature request entity (its own ID + directory), or is the current flat structure (AGI-{n} tickets in request_queue/, linked by `group` field) sufficient?":"Add feature request layer"}},"sourceToolAssistantUUID":"562dce57-4940-42bb-bef6-02a3fd24f536"}
{"parentUuid":"b1555b62-ba54-4aaf-96e6-1c6d93fd7b71","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01B81pzrhTaQzjT1TwGRRhDm","type":"message","role":"assistant","content":[{"type":"text","text":"Got it — **Add a `FR-{n}` feature request layer with directories**. So the structure would be:\n\n```\nfeature_requests/\n  FR-1/\n    request.md          # Original user request + clarification Q&A\n    AGI-5.md            # Ticket: Auth middleware (group: dashboard-v1)\n    AGI-6.md            # Ticket: Dashboard API (group: dashboard-v1)\n    AGI-7.md            # Ticket: Dashboard UI (group: dashboard-v1)\n    AGI-8.md            # Ticket: Auth middleware (group: dashboard-v2)\n    AGI-9.md            # Ticket: Dashboard API (group: dashboard-v2)\n    AGI-10.md           # Ticket: Dashboard UI (group: dashboard-v2)\n  FR-2/\n    request.md\n    AGI-11.md\n```\n\nEach ticket's frontmatter would include `feature_request: FR-1`. The orchestrator scans `feature_requests/*/AGI-*.md` instead of `request_queue/*.md`.\n\nOne follow-up before I move on:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":694,"cache_read_input_tokens":56859,"cache_creation":{"ephemeral_5m_input_tokens":694,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nHxtZdEx2ESfrtiEBy","type":"assistant","uuid":"d7aedb31-e2b1-4065-a77c-2d1ce24785b7","timestamp":"2026-02-14T10:11:49.046Z"}
{"parentUuid":"d7aedb31-e2b1-4065-a77c-2d1ce24785b7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01B81pzrhTaQzjT1TwGRRhDm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TvEuEPXGyhuFkQ9gcS1za3","name":"AskUserQuestion","input":{"questions":[{"question":"Should variant groups get their own subdirectory within the FR directory, or stay flat within it? e.g., FR-1/dashboard-v1/AGI-5.md vs FR-1/AGI-5.md (with group field in frontmatter)","header":"Variant dirs?","options":[{"label":"Flat within FR dir","description":"All tickets in FR-1/ regardless of variant. Group linkage via `group` field in frontmatter. Simpler glob pattern for the orchestrator."},{"label":"Subdirs per variant group","description":"FR-1/dashboard-v1/AGI-5.md, FR-1/dashboard-v2/AGI-8.md. Physical separation of variant chains. More complex glob but clearer filesystem organization."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":694,"cache_read_input_tokens":56859,"cache_creation":{"ephemeral_5m_input_tokens":694,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nHxtZdEx2ESfrtiEBy","type":"assistant","uuid":"ca7c9ef3-804e-41d3-8e4f-3b6e8dd43cfa","timestamp":"2026-02-14T10:11:53.000Z"}
{"parentUuid":"ca7c9ef3-804e-41d3-8e4f-3b6e8dd43cfa","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01TvEuEPXGyhuFkQ9gcS1za3","parentToolUseID":"toolu_01TvEuEPXGyhuFkQ9gcS1za3","uuid":"3668bff9-bc12-4d73-ae44-afb78366bf70","timestamp":"2026-02-14T10:11:53.002Z"}
{"parentUuid":"3668bff9-bc12-4d73-ae44-afb78366bf70","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01TvEuEPXGyhuFkQ9gcS1za3","toolUseID":"toolu_01TvEuEPXGyhuFkQ9gcS1za3","timestamp":"2026-02-14T10:12:15.541Z","uuid":"b865ddf9-9b7b-4127-9c0a-2a7430617bb9"}
{"parentUuid":"ca7c9ef3-804e-41d3-8e4f-3b6e8dd43cfa","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Should variant groups get their own subdirectory within the FR directory, or stay flat within it? e.g., FR-1/dashboard-v1/AGI-5.md vs FR-1/AGI-5.md (with group field in frontmatter)\"=\"Subdirs per variant group\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01TvEuEPXGyhuFkQ9gcS1za3"}]},"uuid":"15cad7f5-f12c-4c55-b017-ba503fde0da2","timestamp":"2026-02-14T10:12:15.538Z","toolUseResult":{"questions":[{"question":"Should variant groups get their own subdirectory within the FR directory, or stay flat within it? e.g., FR-1/dashboard-v1/AGI-5.md vs FR-1/AGI-5.md (with group field in frontmatter)","header":"Variant dirs?","options":[{"label":"Flat within FR dir","description":"All tickets in FR-1/ regardless of variant. Group linkage via `group` field in frontmatter. Simpler glob pattern for the orchestrator."},{"label":"Subdirs per variant group","description":"FR-1/dashboard-v1/AGI-5.md, FR-1/dashboard-v2/AGI-8.md. Physical separation of variant chains. More complex glob but clearer filesystem organization."}],"multiSelect":false}],"answers":{"Should variant groups get their own subdirectory within the FR directory, or stay flat within it? e.g., FR-1/dashboard-v1/AGI-5.md vs FR-1/AGI-5.md (with group field in frontmatter)":"Subdirs per variant group"}},"sourceToolAssistantUUID":"ca7c9ef3-804e-41d3-8e4f-3b6e8dd43cfa"}
{"parentUuid":"15cad7f5-f12c-4c55-b017-ba503fde0da2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01W4i3TNC5nPSaEhr6XNjjeq","type":"message","role":"assistant","content":[{"type":"text","text":"Confirmed — **subdirs per variant group**:\n\n```\nfeature_requests/\n  FR-1/\n    request.md\n    dashboard-v1/\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md            # No group → lives directly in FR-2/\n```\n\nOrchestrator glob: `feature_requests/*/AGI-*.md` + `feature_requests/*/*/AGI-*.md`. Non-variant tickets live directly in the FR dir.\n\n---\n\n**Issue #6: Test-Writer scope — which stages trigger it?**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":616,"cache_read_input_tokens":57553,"cache_creation":{"ephemeral_5m_input_tokens":616,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nLPK3xqqETyEarQF6x","type":"assistant","uuid":"b0a60fb5-c03b-46a8-a9a7-01e06fd9c5d5","timestamp":"2026-02-14T10:12:30.371Z"}
{"parentUuid":"b0a60fb5-c03b-46a8-a9a7-01e06fd9c5d5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01W4i3TNC5nPSaEhr6XNjjeq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017P6X6e33QQ1qjom88dHZnK","name":"Read","input":{"file_path":"REDACTED.md","offset":895,"limit":30},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":616,"cache_read_input_tokens":57553,"cache_creation":{"ephemeral_5m_input_tokens":616,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nLPK3xqqETyEarQF6x","type":"assistant","uuid":"5406a62b-64fe-47f8-bf9c-c685a9657119","timestamp":"2026-02-14T10:12:31.081Z"}
{"parentUuid":"5406a62b-64fe-47f8-bf9c-c685a9657119","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_017P6X6e33QQ1qjom88dHZnK","parentToolUseID":"toolu_017P6X6e33QQ1qjom88dHZnK","uuid":"9a8ccbb8-59e9-46f0-aa62-a130baa5f7a1","timestamp":"2026-02-14T10:12:31.086Z"}
{"parentUuid":"9a8ccbb8-59e9-46f0-aa62-a130baa5f7a1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_017P6X6e33QQ1qjom88dHZnK","toolUseID":"toolu_017P6X6e33QQ1qjom88dHZnK","timestamp":"2026-02-14T10:12:31.158Z","uuid":"14fb144c-4a9f-4c3c-8a02-86eca12c6cb2"}
{"parentUuid":"14fb144c-4a9f-4c3c-8a02-86eca12c6cb2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_017P6X6e33QQ1qjom88dHZnK","toolUseID":"toolu_017P6X6e33QQ1qjom88dHZnK","timestamp":"2026-02-14T10:12:31.158Z","uuid":"5c8e91eb-691b-48aa-8cc6-139a6f1dea97"}
{"parentUuid":"5406a62b-64fe-47f8-bf9c-c685a9657119","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017P6X6e33QQ1qjom88dHZnK","type":"tool_result","content":"   895→## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n   896→\n   897→### Purpose\n   898→\n   899→Every worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n   900→\n   901→### Two-Tier Testing Strategy\n   902→\n   903→| Ticket type | Unit tests | Integration tests |\n   904→|-------------|-----------|-------------------|\n   905→| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n   906→| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n   907→\n   908→### Execution Flow\n   909→\n   910→The test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n   911→\n   912→```\n   913→executeWorker(task):\n   914→  1. Worker agent implements feature, commits, pushes\n   915→  2. Test-writer agent runs in same sandbox:\n   916→     a. Reads the git diff (all commits on this branch vs main)\n   917→     b. Reads the ticket description + acceptance criteria\n   918→     c. If terminal: also reads all tickets in the group chain for integration context\n   919→     d. Writes test files to tests/\n   920→     e. Runs `npm test` to verify all tests pass\n   921→     f. Commits test files, pushes to same branch\n   922→  3. Return combined WORK_RESULT (implementation + test summary)\n   923→```\n   924→"}]},"uuid":"a6fc2fd4-c1de-4bad-a8dd-59cd21a5d3f0","timestamp":"2026-02-14T10:12:31.156Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n","numLines":30,"startLine":895,"totalLines":1017}},"sourceToolAssistantUUID":"5406a62b-64fe-47f8-bf9c-c685a9657119"}
{"parentUuid":"a6fc2fd4-c1de-4bad-a8dd-59cd21a5d3f0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01MeBuswKvVWkFk446cyyAiU","type":"message","role":"assistant","content":[{"type":"text","text":"Line 899 says \"Every worker execution is followed by a test-writer step.\" But Research, Specification, and Plan stages don't produce code changes — they produce analysis, specs, and plans. Writing tests after those stages makes no sense.\n\nOnly stages that produce code commits are worth testing:\n- **Implement** — yes, always\n- **Oneshot** — yes, always (it's a fast-track implementation)\n- **Validate** — debatable — Validate verifies the implementation, it may fix things and commit. If it does commit code changes, tests make sense.\n\nResearch, Specification, and Plan — no code changes, no tests."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":746,"cache_read_input_tokens":58169,"cache_creation":{"ephemeral_5m_input_tokens":746,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nMY8f5a3skyGLxjCuB","type":"assistant","uuid":"c3c99ade-425d-43f6-bd40-df3189bc3c80","timestamp":"2026-02-14T10:12:37.707Z"}
{"parentUuid":"c3c99ade-425d-43f6-bd40-df3189bc3c80","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01MeBuswKvVWkFk446cyyAiU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JgMoA3ggjd9k9bJnX6RXpG","name":"AskUserQuestion","input":{"questions":[{"question":"Which stages should trigger the test-writer? (Research/Spec/Plan produce no code, so testing them is meaningless.)","header":"Test stages","options":[{"label":"Implement + Oneshot only","description":"Test-writer runs after Implement and Oneshot stages only. Validate is a verification step that shouldn't produce new untested code."},{"label":"Implement + Oneshot + Validate","description":"Test-writer runs after any stage that might commit code. Validate could fix issues and commit, so test those changes too."},{"label":"Implement only, Oneshot bundles tests","description":"Implement triggers test-writer. Oneshot's prompt already includes 'write tests' as part of its implementation (since it's a single fast-track step)."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":746,"cache_read_input_tokens":58169,"cache_creation":{"ephemeral_5m_input_tokens":746,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nMY8f5a3skyGLxjCuB","type":"assistant","uuid":"e6c8fa75-4605-4aab-8fa6-12e33ab5fcba","timestamp":"2026-02-14T10:12:42.192Z"}
{"parentUuid":"e6c8fa75-4605-4aab-8fa6-12e33ab5fcba","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01JgMoA3ggjd9k9bJnX6RXpG","parentToolUseID":"toolu_01JgMoA3ggjd9k9bJnX6RXpG","uuid":"886c8065-a543-45d0-b9a6-d9d3e17b15f2","timestamp":"2026-02-14T10:12:42.194Z"}
{"parentUuid":"886c8065-a543-45d0-b9a6-d9d3e17b15f2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01JgMoA3ggjd9k9bJnX6RXpG","toolUseID":"toolu_01JgMoA3ggjd9k9bJnX6RXpG","timestamp":"2026-02-14T10:13:23.470Z","uuid":"3d9ca1a4-7653-4bb2-b5b6-769124f2385d"}
{"parentUuid":"e6c8fa75-4605-4aab-8fa6-12e33ab5fcba","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Which stages should trigger the test-writer? (Research/Spec/Plan produce no code, so testing them is meaningless.)\"=\"Implement + Oneshot + Validate\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01JgMoA3ggjd9k9bJnX6RXpG"}]},"uuid":"cb7c6c46-c9f7-44b6-b2cc-7d62c74d41a0","timestamp":"2026-02-14T10:13:23.468Z","toolUseResult":{"questions":[{"question":"Which stages should trigger the test-writer? (Research/Spec/Plan produce no code, so testing them is meaningless.)","header":"Test stages","options":[{"label":"Implement + Oneshot only","description":"Test-writer runs after Implement and Oneshot stages only. Validate is a verification step that shouldn't produce new untested code."},{"label":"Implement + Oneshot + Validate","description":"Test-writer runs after any stage that might commit code. Validate could fix issues and commit, so test those changes too."},{"label":"Implement only, Oneshot bundles tests","description":"Implement triggers test-writer. Oneshot's prompt already includes 'write tests' as part of its implementation (since it's a single fast-track step)."}],"multiSelect":false}],"answers":{"Which stages should trigger the test-writer? (Research/Spec/Plan produce no code, so testing them is meaningless.)":"Implement + Oneshot + Validate"}},"sourceToolAssistantUUID":"e6c8fa75-4605-4aab-8fa6-12e33ab5fcba"}
{"parentUuid":"cb7c6c46-c9f7-44b6-b2cc-7d62c74d41a0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01FKMZuKnsDBaGNSPNbhuoQz","type":"message","role":"assistant","content":[{"type":"text","text":"Confirmed — **test-writer runs after Implement, Oneshot, and Validate stages** (the three stages that can commit code). Research, Specification, and Plan do not trigger it.\n\n---\n\nAll 6 issues resolved. Here's the summary of decisions:\n\n| Issue | Resolution |\n|-------|-----------|\n| #1 filterEligible signature | **Version B** — 2-param `filterEligible(allTasks, active)` with `isActionable()` guard. Drop `loadActionableTasks()`. |\n| #2 Oneshot dispatch gap | **Add `NeedsOneshot`** status + `stagePromptMap` entry. Research outputs `next_status: \"Needs Oneshot\"`. |\n| #3 Naming conflict | **Eliminated** — all stages run in Daytona sandboxes. Single `dispatchStage` method. Remove line 486 about local stages. |\n| #4 Agent 1 & 3 | **Absorb into TypeScript**. Drop `agent1-linear-reader.md` and `agent3-linear-writer.md` prompts. |\n| #5 Dual ID TODO | **Add FR-{n} feature request layer** with directories. Variant groups get subdirs. Orchestrator globs `feature_requests/**/AGI-*.md`. |\n| #6 Test-writer scope | **Implement + Oneshot + Validate** only. Research/Spec/Plan don't trigger test-writer. |\n\nWant me to apply all these changes to `IMPLEMENTATION_PLAN.md` now?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":464,"cache_read_input_tokens":58915,"cache_creation":{"ephemeral_5m_input_tokens":464,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nRPoiKjJZ4XzSDL2iN","type":"assistant","uuid":"74281420-70db-4b93-93c4-b331df2ea881","timestamp":"2026-02-14T10:13:32.948Z"}
{"parentUuid":"74281420-70db-4b93-93c4-b331df2ea881","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"0b492cc2-a5d2-40bb-a541-a3a6d55c9838","toolUseID":"0b492cc2-a5d2-40bb-a541-a3a6d55c9838","timestamp":"2026-02-14T10:13:32.977Z","uuid":"3831f9b1-82f8-490e-8860-4e7b74cfd767"}
{"parentUuid":"3831f9b1-82f8-490e-8860-4e7b74cfd767","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"0b492cc2-a5d2-40bb-a541-a3a6d55c9838","toolUseID":"0b492cc2-a5d2-40bb-a541-a3a6d55c9838","timestamp":"2026-02-14T10:13:32.978Z","uuid":"d5bc92f4-6b85-49ae-8e55-0afec43b0836"}
{"parentUuid":"d5bc92f4-6b85-49ae-8e55-0afec43b0836","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T10:13:33.269Z","uuid":"9ddf7ba5-03f4-456d-98f4-e79f81b5b279","toolUseID":"0b492cc2-a5d2-40bb-a541-a3a6d55c9838"}
{"parentUuid":"9ddf7ba5-03f4-456d-98f4-e79f81b5b279","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"system","subtype":"turn_duration","durationMs":64995,"timestamp":"2026-02-14T10:13:33.269Z","uuid":"b3d7fb94-542e-41e0-9adb-0f7276e4e8f0","isMeta":false}
{"type":"file-history-snapshot","messageId":"aad31b83-18ce-4759-a4b5-5451de419ccc","snapshot":{"messageId":"aad31b83-18ce-4759-a4b5-5451de419ccc","trackedFileBackups":{},"timestamp":"2026-02-14T10:13:38.509Z"},"isSnapshotUpdate":false}
{"parentUuid":"b3d7fb94-542e-41e0-9adb-0f7276e4e8f0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":"yes apply all changes to the plan"},"uuid":"aad31b83-18ce-4759-a4b5-5451de419ccc","timestamp":"2026-02-14T10:13:38.141Z","thinkingMetadata":{"maxThinkingTokens":31999},"todos":[],"permissionMode":"default"}
{"parentUuid":"aad31b83-18ce-4759-a4b5-5451de419ccc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_015YRBxGba9miDJwefhPDvmT","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":31,"cache_read_input_tokens":59751,"cache_creation":{"ephemeral_5m_input_tokens":31,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nSWBUGJFzAkyaCiuhi","type":"assistant","uuid":"ca5fe0f3-d234-4858-886b-a2bc15301d14","timestamp":"2026-02-14T10:13:42.286Z"}
{"parentUuid":"ca5fe0f3-d234-4858-886b-a2bc15301d14","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_015YRBxGba9miDJwefhPDvmT","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Let me apply all 6 changes to the IMPLEMENTATION_PLAN.md. I need to read the full file first to understand all the sections that need updating, then make targeted edits.\n\nLet me plan the edits:\n\n1. **Issue #1**: filterEligible → Version B (2-param), drop loadActionableTasks\n   - Update the filterEligible section at lines 406-443 to use 2-param version\n   - Update the processQueue code at lines 324-361 to use single loader\n   - Update the \"Two Task Loaders\" section at lines 754-759\n   - Update the \"filterEligible Update\" section at lines 733-752 (this is already Version B, but need to reconcile)\n   - Remove `loadActionableTasks()` from the Files table at line 866\n\n2. **Issue #2**: Add NeedsOneshot status\n   - Insert it into the TaskStatus enum at line 615-616\n   - Add corresponding entry to stagePromptMap at line 660-666\n   - Update the transition diagram at line 637\n\n3. **Issue #3**: All stages in sandboxes\n   - Remove the note about local stages at line 486\n   - Eliminate the naming distinction between dispatchStage and executeWorker in Phase 5\n\n4. **Issue #4**: Absorb agent1/agent3 into TypeScript\n   - Update the pipeline diagram at lines 69\n   - Remove agent1/agent3 from the prompt mapping table at lines 39, 47\n   - Remove them from the files table at lines 870-871\n   - Update the adaptation guidelines\n\n5. **Issue #5**: Add FR-{n} feature request layer with variant subdirs\n   - Revise the \"Writing Tickets\" section at lines 255-277\n   - Remove the HTML TODO comment\n   - Update all references to request_queue/ throughout the document\n\n6. **Issue #6**: Test-writer runs after Implement + Oneshot + Validate only\n   - Update Phase 5 text at line 899\n\nNow I need to read through the full file to make these edits precisely.","signature":"EoIOCkYICxgCKkBoEoQhdLWCbfMtypvIfTlJqAPKUS7byleUsA4fStBPnjHAGRxPTgM99DFKDI2GgMXY2r1v9wVVV4CCRsrk1sq5EgyoUBvSPRM7uOEZ0DYaDDlrUe7T0XJudx5fnCIw/ajmhjyR80a7px73Y0Sd2HHiMFm7Y9CDD/4bwwYpLaSQDhp7sGoWLac0ITE0aOoSKukMwx6JT6cME6L85TqNTeeF423Z7X2GjC1N2KwXcSPMrziNph51IMAP3D+V/3ui/sFk1wFr5s57pDiGbX49BMu0EkjABpauGO7O6/u/cbpYKbbbTTjefLR69bjwFb8o5wD0HKf3GUvs6p4BmGhJm9Ihg/QXe8kM1HVW02CbkR4gHD7fthjupECijwKNlfSouThER/ZyLqn/UQScZuNYl8FFBUKgOwnTcJQtiaVsTn73L/6NxBlc/QOVWl0oc1VWDRgP5ebwlVffxYaL+LyCM/iwxtdGPM2XPQnR5ouPHrA7o+oI9kuT523Vl+vTZHihTdMuWFLhVs010jpCHaDNkkh63RXatBVxDiVuiQGZBCrU+sgXT0PlIw6erCprpZqY1jdfedv6sHbfjjsy1hLdu+FXoy21iJSjD2/2VgR5BJR+Azps5NYLuAygx+PO+6sEnXlJpxnuDkFNr75tscTLIYTHGcWNzzYY2kEoUkmn9OOihb0wM841wbQhJ1M4PuVftryz7iRGiipbRqHvXMSNwK33GSwC6EO1VH4LOdpA8kxrirZaUJgHvZUNHRbUeDsSSItj930Yw/6crX0ndGJxrFXG2DTO7D5BvwpOdLpi5tHPD/MdWvyje9QSq46XobE/IbBO9XV4GOvQn9kmPu3LdsGN+ARsyuQMdj50neJd0oCG0lLCYBaMjHJ4/HYYnAyntcdP7cnys5mzZ3B1lce7bjTMlurTCoVBTSO9eXCKX4kINCUFzW2ne1BkN+P9C7nDhao6bHuJ1CK88a8Q5vxSxo+u5wt27AajxEj+GS/gAvh/AnNgi5nxRo4Va6pIZEh5oAzAJXzKqVc/b01+e6rRnNxTw/o5iPsz9VxLEI9Hnl4BF62rIDVTNmPbVOafJFnhN2fiGqe9nxTYr1hgG0RVlQ/jTLUqcIBQwx1FK1gknm0IZQZJr2ldr52/u6E1gM/jeV+kvmjmS7O+/LHHXq3KW+c0lpWTH6PljBpEV1S+/nP44lQKvFsgig3tfoLUfbhTGt1qTzUwdzu4y8+t3ED9NmpVSYMRUStJWpxAvltnaiREGeAMmK9qJnrxm+DOoBb9hK6IahdFz/f/3Z7mNtN3vdtT2a85fBPU8ZkG0Gl02QuYjcLHEL+gPH7T7FFrlaJqkCtCHUV8y2Bi6zNroF3N+smXucTdQhPXmTsTNYrQ8tqi5ITWao97CYORJhjbWuPOFyDqWJ1Hh72pCmM0IQA5aluZzGJxzOcrANXply8lLzVRtL2px/602u8eWPcxRi9LZABqO4jEaBqxq4gGrsKS17BCVjeFGH6o7ZATUispKHWpvTULBRjsasgilQYDQYyujQVWRuPZM2C/XYz4gSVfEL52JaE8BrIlGYy3UvSgV2axyuZ7CSImWv2gHYQgKETnV/+QyFfdLH+SJ9anomamG49IKuYrwwtaVa1AfYq3g7pZrSesEeCsm5JFbCIOuUEFCugaqXzRurTy6MZgL6vAL/wGHLWpCbubWhXHDxmq//s4Czm5MFovXrzilgDACsTmumSG2+4vo1OB1xhcxtgtXPoKygyQc55z+xZEdYsdOvlxMaJ+Lpdk/HoDnKfJLUT/jq90El06WKzQdpwbMFgIqcraPPojzju4Z0DkEoXT/OkaGdc+Db4LgvHd40NjmUVcDkoOnK6AqT2sE9+Xc5LuUdijgcUSX+KjQG/fhD6z8y8Am2NppmR23gtW23NsVxZRWsMZ/2nFcErKY3Qsj1/lNJyc9+EAum60wkZKNuJb6iN5+J8yoyBxCz7d43je3cizKenDJgwsUZmwMq26/xDSMMIftd0ZS+H7Q6nQ/7IU/B0Gyev1k039ZUh/96zoDFcRayGzNL6bpv0N7Bukvp7YLDXifNilm4bIwfWR2qHPKzZN+hxHCD6CtLBbj4MRnG0dJV9bvMvlqWBrGFjTuBtFKYXpx8wJ8L1TrYuu3EKojWk1WwWA7T3hHG6t18ZJC6yNC4KmDsG8Y69ySv7YfiIL2iGuZtY/som56ct9Pvc9I/RiDuIVhSYylBn0X4mHwmQ8sfzMGofu4/rZoztfG21E59ND4pWePswJRbgkHsZATuP/TmW+AGB10r9WXNZ2AhSldNYc+LUX1O+d0hzcMP3PDeORYaDdLAVMrNbOLhUaXo5xU0raqxVLkFDqGsXf6vnFyuzlhAQNAf6wcFrOGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":31,"cache_read_input_tokens":59751,"cache_creation":{"ephemeral_5m_input_tokens":31,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nSWBUGJFzAkyaCiuhi","type":"assistant","uuid":"b43c1d52-8a03-4bf3-8f9d-cf3030725e11","timestamp":"2026-02-14T10:13:52.933Z"}
{"parentUuid":"b43c1d52-8a03-4bf3-8f9d-cf3030725e11","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_015YRBxGba9miDJwefhPDvmT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0154SPGiaJFL9xC2hkcAQaKg","name":"TaskCreate","input":{"subject":"Apply 6 resolved issues to IMPLEMENTATION_PLAN.md","description":"Apply all 6 resolved changes:\n1. filterEligible → Version B (2-param), drop loadActionableTasks\n2. Add NeedsOneshot status + stagePromptMap entry\n3. All stages in sandboxes, single dispatchStage method\n4. Absorb agent1/agent3 into TypeScript, drop their prompts\n5. Add FR-{n} feature request layer with variant subdirs\n6. Test-writer runs after Implement + Oneshot + Validate only","activeForm":"Updating IMPLEMENTATION_PLAN.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":31,"cache_read_input_tokens":59751,"output_tokens":710,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":31},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7nSWBUGJFzAkyaCiuhi","type":"assistant","uuid":"473a0ce8-a1cb-434e-9aeb-9684001d9811","timestamp":"2026-02-14T10:13:53.422Z"}
{"parentUuid":"473a0ce8-a1cb-434e-9aeb-9684001d9811","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:TaskCreate","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_0154SPGiaJFL9xC2hkcAQaKg","parentToolUseID":"toolu_0154SPGiaJFL9xC2hkcAQaKg","uuid":"4900eeaa-e075-4446-a0ba-47c5dacee802","timestamp":"2026-02-14T10:13:53.426Z"}
{"parentUuid":"4900eeaa-e075-4446-a0ba-47c5dacee802","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:TaskCreate","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_0154SPGiaJFL9xC2hkcAQaKg","toolUseID":"toolu_0154SPGiaJFL9xC2hkcAQaKg","timestamp":"2026-02-14T10:13:53.481Z","uuid":"035a4af2-3973-4d14-bd68-21ff3f34eb25"}
{"parentUuid":"473a0ce8-a1cb-434e-9aeb-9684001d9811","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0154SPGiaJFL9xC2hkcAQaKg","type":"tool_result","content":"Task #1 created successfully: Apply 6 resolved issues to IMPLEMENTATION_PLAN.md"}]},"uuid":"a2ee9fc6-ed2d-4354-9311-2f97e553de66","timestamp":"2026-02-14T10:13:53.480Z","toolUseResult":{"task":{"id":"1","subject":"Apply 6 resolved issues to IMPLEMENTATION_PLAN.md"}},"sourceToolAssistantUUID":"473a0ce8-a1cb-434e-9aeb-9684001d9811"}
{"parentUuid":"a2ee9fc6-ed2d-4354-9311-2f97e553de66","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01N8Fe2xciJqvfBMNDwS2Cdz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01E8gAFYYq8Szc5QgMgvq26n","name":"TaskUpdate","input":{"taskId":"1","status":"in_progress"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":727,"cache_read_input_tokens":59782,"output_tokens":72,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":727},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7nTbxkrKCbHJRR6zu49","type":"assistant","uuid":"d0556932-6fd1-4ace-9eab-0f6182bb5b9a","timestamp":"2026-02-14T10:13:55.982Z"}
{"parentUuid":"d0556932-6fd1-4ace-9eab-0f6182bb5b9a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:TaskUpdate","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01E8gAFYYq8Szc5QgMgvq26n","parentToolUseID":"toolu_01E8gAFYYq8Szc5QgMgvq26n","uuid":"1d9f33f2-a819-4e52-8667-575b6ad38108","timestamp":"2026-02-14T10:13:55.986Z"}
{"parentUuid":"1d9f33f2-a819-4e52-8667-575b6ad38108","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:TaskUpdate","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01E8gAFYYq8Szc5QgMgvq26n","toolUseID":"toolu_01E8gAFYYq8Szc5QgMgvq26n","timestamp":"2026-02-14T10:13:56.054Z","uuid":"2e258561-f7ea-403e-b0f7-b5a2f0a221a1"}
{"parentUuid":"d0556932-6fd1-4ace-9eab-0f6182bb5b9a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01E8gAFYYq8Szc5QgMgvq26n","type":"tool_result","content":"Updated task #1 status"}]},"uuid":"2980bb25-2b3f-4027-a972-a9d4f317b82b","timestamp":"2026-02-14T10:13:56.053Z","toolUseResult":{"success":true,"taskId":"1","updatedFields":["status"],"statusChange":{"from":"pending","to":"in_progress"}},"sourceToolAssistantUUID":"d0556932-6fd1-4ace-9eab-0f6182bb5b9a"}
{"parentUuid":"2980bb25-2b3f-4027-a972-a9d4f317b82b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_0186tFrG3BWyQ94BpHAkT2WE","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the full file to make precise edits."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":90,"cache_read_input_tokens":60509,"cache_creation":{"ephemeral_5m_input_tokens":90,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nTnwomgP3cXPJPiDSB","type":"assistant","uuid":"62e5e3f4-41d3-4cb3-b983-bd3c8feadee9","timestamp":"2026-02-14T10:13:58.602Z"}
{"parentUuid":"62e5e3f4-41d3-4cb3-b983-bd3c8feadee9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_0186tFrG3BWyQ94BpHAkT2WE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DFBY2rEeT5JHXbYH4shNxK","name":"Read","input":{"file_path":"REDACTED.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":90,"cache_read_input_tokens":60509,"cache_creation":{"ephemeral_5m_input_tokens":90,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nTnwomgP3cXPJPiDSB","type":"assistant","uuid":"7950720d-c635-4fa2-be6e-4cfb2050f227","timestamp":"2026-02-14T10:13:59.108Z"}
{"parentUuid":"7950720d-c635-4fa2-be6e-4cfb2050f227","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01DFBY2rEeT5JHXbYH4shNxK","parentToolUseID":"toolu_01DFBY2rEeT5JHXbYH4shNxK","uuid":"33e0a5b7-70a2-46cd-88dd-b659c77b55ff","timestamp":"2026-02-14T10:13:59.110Z"}
{"parentUuid":"33e0a5b7-70a2-46cd-88dd-b659c77b55ff","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01DFBY2rEeT5JHXbYH4shNxK","toolUseID":"toolu_01DFBY2rEeT5JHXbYH4shNxK","timestamp":"2026-02-14T10:13:59.465Z","uuid":"a4a26400-a5d9-4b32-aaf7-ffa8e2b56f3d"}
{"parentUuid":"a4a26400-a5d9-4b32-aaf7-ffa8e2b56f3d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01DFBY2rEeT5JHXbYH4shNxK","toolUseID":"toolu_01DFBY2rEeT5JHXbYH4shNxK","timestamp":"2026-02-14T10:13:59.465Z","uuid":"ca8209dc-9d32-4825-89b4-a01b3fc0b860"}
{"parentUuid":"7950720d-c635-4fa2-be6e-4cfb2050f227","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DFBY2rEeT5JHXbYH4shNxK","type":"tool_result","content":"     1→# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n     2→\n     3→---\n     4→\n     5→## Reference Architecture: Horizon CLI Agent\n     6→\n     7→> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n     8→>\n     9→> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n    10→>\n    11→> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n    12→> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n    13→> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n    14→> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n    15→>\n    16→> ### Key Difference: Linear vs Local Queue\n    17→>\n    18→> | Concern | Horizon | Napoli-Matcha |\n    19→> |---------|---------|---------------|\n    20→> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `request_queue/` with YAML frontmatter |\n    21→> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n    22→> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n    23→> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `request_queue/` |\n    24→> | **Agent 1 (Reader)** | Queries Linear for issues in specific statuses | Reads `request_queue/*.md`, filters by `status: Needs Research` |\n    25→> | **Agent 3 (Writer)** | Posts comments + updates Linear issue status | Updates MD frontmatter status + appends result sections |\n    26→>\n    27→> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n    28→\n    29→---\n    30→\n    31→## Prompts Directory (`prompts/`)\n    32→\n    33→The `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n    34→\n    35→### Prompt Mapping & Adaptation Status\n    36→\n    37→| File | Horizon Role | Napoli Role | Adaptation Needed |\n    38→|------|-------------|-------------|-------------------|\n    39→| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Queue Reader** — reads from `request_queue/*.md` | **HIGH** — Replace all `mcp__linear__*` calls with local file I/O. Keep multi-agent conflict/claim logic. |\n    40→| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n    41→| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n    42→| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n    43→| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n    44→| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n    45→| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n    46→| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n    47→| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Queue Writer** — updates MD files with results | **HIGH** — Remove all MCP calls, write results to MD files, handle sub-issue creation as new queue files |\n    48→| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n    49→| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n    50→| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n    51→\n    52→### New Prompts Needed\n    53→\n    54→| File | Purpose | Phase |\n    55→|------|---------|-------|\n    56→| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n    57→| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n    58→\n    59→### How Prompts Are Used in the Pipeline\n    60→\n    61→```\n    62→User request\n    63→  │\n    64→  ▼\n    65→agent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n    66→  │ Clarification loop until spec meets 5 quality criteria\n    67→  │ Writes tickets to request_queue/\n    68→  ▼\n    69→agent1-linear-reader.md (Queue Reader — IN SANDBOX, adapted for local queue)\n    70→  │ Reads ticket from queue, claims it, outputs context for worker\n    71→  ▼\n    72→agent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n    73→  │ 6-stage pipeline: research → spec → plan → implement → validate\n    74→  │ (or oneshot fast-track)\n    75→  ▼\n    76→agent2-worker-test.md (Test Writer — IN SAME SANDBOX, after worker)\n    77→  │ Writes tests for the implementation, commits to same branch\n    78→  ▼\n    79→agent3-linear-writer.md (Queue Writer — IN SANDBOX, adapted for local queue)\n    80→  │ Parses WORK_RESULT, updates MD file with results + status\n    81→  ▼\n    82→Orchestrator decides: terminal? → PR + merge. Non-terminal? → push, next ticket.\n    83→```\n    84→\n    85→### Adaptation Guidelines for Horizon → Napoli Prompts\n    86→\n    87→When editing prompts that reference Horizon/Linear:\n    88→\n    89→1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n    90→2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n    91→3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n    92→4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n    93→5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n    94→6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n    95→\n    96→---\n    97→\n    98→## Full Pipeline\n    99→\n   100→```\n   101→User submits request (CLI arg, stdin, or file)\n   102→  │\n   103→  ▼\n   104→Spec Agent (local Claude CLI, interactive clarification loop)\n   105→  ├─ Evaluates request against 5 spec quality criteria\n   106→  ├─ If gaps: asks human targeted questions (loop until clear)\n   107→  ├─ Detects variant requests (\"give me 2 versions\")\n   108→  ├─ Decomposes into structured tickets with dependency graph\n   109→  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n   110→  └─ Writes tickets to request_queue/ as MD files (status: Needs Research)\n   111→  │\n   112→  ▼\n   113→Orchestrator (pure TypeScript, continuous loop)\n   114→  ├─ Reads request_queue/, topological sort on depends_on\n   115→  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n   116→  ├─ On completion: parses WORK_RESULT, writes to MD\n   117→  ├─ Merge: only for terminal tickets (no downstream group deps)\n   118→  └─ When queue empty: sleep, poll, retry\n   119→  │\n   120→  ▼\n   121→Workers (Claude in Daytona sandbox, parallel)\n   122→  ├─ Receives structured ticket in prompt\n   123→  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n   124→  ├─ Checks out existing group branch (has prior chain commits) or creates new\n   125→  ├─ Implements, commits, pushes\n   126→  ├─ Creates PR only if terminal ticket\n   127→  └─ Outputs structured WORK_RESULT block\n   128→```\n   129→\n   130→---\n   131→\n   132→## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n   133→\n   134→### Purpose\n   135→\n   136→Front-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n   137→\n   138→### Clarification Loop\n   139→\n   140→The Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n   141→\n   142→```\n   143→clarify(userRequest: string): Promise<TaskRequest[]>\n   144→  context = userRequest\n   145→  while true:\n   146→    result = ClaudeSpawner.spawn(buildPrompt(context))\n   147→    parsed = parseOutput(result.finalOutput)\n   148→\n   149→    if parsed.type === \"QUESTIONS\":\n   150→      answers = await promptHuman(parsed.questions)\n   151→      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n   152→      continue\n   153→\n   154→    if parsed.type === \"TICKETS\":\n   155→      writeTicketsToQueue(parsed.tickets)\n   156→      return parsed.tickets\n   157→```\n   158→\n   159→Each spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n   160→\n   161→### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n   162→\n   163→```\n   164→You are a Specification Agent. Your job is to evaluate a user's feature request\n   165→and either ask clarifying questions or produce structured tickets.\n   166→\n   167→## Spec Quality Criteria\n   168→\n   169→Evaluate the request against ALL 5 of these standards:\n   170→\n   171→1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   172→   (not just \"improve X\")\n   173→2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n   174→3. **User-Facing Behavior** — Is it clear what users will see or experience?\n   175→4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n   176→5. **Context & Background** — Is there enough context for why this matters and what exists today?\n   177→\n   178→## Red Flags (require clarification)\n   179→- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n   180→- Implementation details without a problem statement\n   181→- No acceptance criteria\n   182→- Assumes shared context without explaining it\n   183→- Multiple unrelated features in one request\n   184→\n   185→## Variant Requests\n   186→\n   187→If the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n   188→\"compare approaches\", \"try it two different ways\"):\n   189→\n   190→- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n   191→- Each variant gets its own independent IDs and dependency chain\n   192→- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n   193→- Add a `variant_hint` to each ticket describing the design direction for that variant\n   194→- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n   195→\n   196→## Your Output (EXACTLY one of these two formats)\n   197→\n   198→### If ANY criteria are missing or vague:\n   199→\n   200→QUESTIONS\n   201→---\n   202→1. [Targeted question addressing specific missing criterion]\n   203→2. [Another question if needed]\n   204→---\n   205→\n   206→### If ALL 5 criteria are adequately covered:\n   207→\n   208→TICKETS\n   209→---\n   210→- id: AGI-{n}\n   211→  title: {short imperative title}\n   212→  description: {detailed description with acceptance criteria}\n   213→  repo: {repo URL}\n   214→  depends_on: [{list of AGI-IDs this depends on, or empty}]\n   215→  start_status: {starting stage — see Stage-Skipping Rules below}\n   216→  group: {group name, omit if standalone ticket}\n   217→  variant_hint: {design direction hint, omit if not a variant}\n   218→- id: AGI-{n+1}\n   219→  ...\n   220→---\n   221→\n   222→Stage-Skipping Rules (for start_status):\n   223→- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n   224→- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n   225→- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n   226→- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n   227→\n   228→Rules for ticket decomposition:\n   229→- Each ticket should be a single, independently testable unit of work\n   230→- Order tickets by dependency (foundations first)\n   231→- Use depends_on to encode the execution order\n   232→- Include acceptance criteria in each ticket description\n   233→- For variants: each chain must be fully self-contained\n   234→```\n   235→\n   236→### Human Interaction\n   237→\n   238→Uses Node `readline` to prompt the human:\n   239→\n   240→```typescript\n   241→private async promptHuman(questions: string[]): Promise<string> {\n   242→  const rl = createInterface({ input: process.stdin, output: process.stdout });\n   243→  const answers: string[] = [];\n   244→  for (const q of questions) {\n   245→    const answer = await new Promise<string>(resolve =>\n   246→      rl.question(`\\n${q}\\n> `, resolve)\n   247→    );\n   248→    answers.push(`Q: ${q}\\nA: ${answer}`);\n   249→  }\n   250→  rl.close();\n   251→  return answers.join(\"\\n\\n\");\n   252→}\n   253→```\n   254→\n   255→### Writing Tickets\n   256→\n   257→<!-- I need 2 IDs here, one to track the feature requests from the user, the other to track the tickets for the implementation; for ease of implementation, also create a dir \"feature_requests_id\" to store the feature request. If a feature request has variants requsted by the user, create a separate directory to store each \"group\" of tickets per variant -->\n   258→After the spec is complete, writes each ticket as an MD file to `request_queue/`:\n   259→\n   260→```markdown\n   261→---\n   262→id: AGI-8\n   263→title: Add auth middleware\n   264→description: >-\n   265→  Create Express middleware that validates JWT tokens on protected routes.\n   266→  Success criteria: unauthorized requests return 401, valid tokens pass through.\n   267→repo: 'https://github.com/user/repo'\n   268→depends_on: []\n   269→group: dashboard-v2\n   270→variant_hint: >-\n   271→  Use a data-dense table layout. Prioritize information density over whitespace.\n   272→number_of_sandboxes: 1\n   273→status: Needs Plan\n   274→---\n   275→```\n   276→\n   277→The `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n   278→\n   279→### Integration with Existing ID Scheme\n   280→\n   281→Reads existing `request_queue/` files to find the current max `AGI-{n}` ID (reuses logic from `SandboxQueueProcessor.loadTasksFromQueue()`). New tickets start from `max + 1`.\n   282→\n   283→---\n   284→\n   285→## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n   286→\n   287→Simplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n   288→\n   289→```typescript\n   290→interface SpawnResult {\n   291→  finalOutput: string;\n   292→  cost: number;\n   293→  duration: number;\n   294→  exitCode: number;\n   295→}\n   296→\n   297→class ClaudeSpawner {\n   298→  spawn(prompt: string, model?: string): Promise<SpawnResult>\n   299→}\n   300→```\n   301→\n   302→- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n   303→- Writes prompt to stdin, closes stdin\n   304→- Parses streaming JSON from stdout\n   305→- Extracts final output from `result` event\n   306→- Logs streaming output to console\n   307→- Returns `SpawnResult`\n   308→\n   309→Based on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n   310→\n   311→---\n   312→\n   313→## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n   314→\n   315→### Continuous Loop with Stage-Aware Dispatch\n   316→\n   317→Replace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n   318→\n   319→```typescript\n   320→async processQueue(): Promise<void> {\n   321→  let iteration = 0;\n   322→  const active = new Map<string, Promise<void>>();\n   323→\n   324→  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n   325→    const actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses\n   326→    const all = await this.loadAllTasks();                // every status\n   327→    const eligible = this.filterEligible(actionable, all, active);\n   328→\n   329→    if (eligible.length === 0 && active.size === 0) {\n   330→      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n   331→      await sleep(this.pollIntervalSeconds * 1000);\n   332→      continue;\n   333→    }\n   334→\n   335→    for (const task of eligible) {\n   336→      if (active.size >= this.maxConcurrency) break;\n   337→      const stagePrompt = this.stagePromptMap[task.status];\n   338→      if (!stagePrompt) continue;\n   339→\n   340→      // Transition to \"In Progress\" for this stage\n   341→      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n   342→      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n   343→        // Worker returns next_status in WORK_RESULT\n   344→        await this.writeResults(task, result);\n   345→        await this.updateTaskStatus(task, result.nextStatus);\n   346→        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n   347→          if (await this.isTerminal(task)) {\n   348→            await this.tryMerge(task);\n   349→          }\n   350→        }\n   351→        active.delete(task.id);\n   352→      });\n   353→      active.set(task.id, promise);\n   354→      iteration++;\n   355→    }\n   356→\n   357→    if (active.size > 0) {\n   358→      await Promise.race(active.values());\n   359→    }\n   360→  }\n   361→}\n   362→```\n   363→\n   364→### Independent Worker Per Stage (Horizon Pattern)\n   365→\n   366→Each stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n   367→\n   368→1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n   369→2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n   370→3. Orchestrator updates MD file: `status: Needs Plan`\n   371→4. Worker A is released (sandbox torn down if applicable)\n   372→5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n   373→6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n   374→7. Repeat until terminal status\n   375→\n   376→This means:\n   377→- Workers are **stateless** — all context comes from the ticket MD file + repo state\n   378→- Multiple tickets in different stages can run in parallel across different workers\n   379→- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n   380→\n   381→### Spec Agent Sets Initial Stage\n   382→\n   383→The Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n   384→\n   385→```typescript\n   386→// In the Spec Agent prompt output, each ticket includes a start_status:\n   387→- id: AGI-{n}\n   388→  title: {title}\n   389→  description: {description}\n   390→  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n   391→```\n   392→\n   393→Stage-skipping rules for the Spec Agent:\n   394→\n   395→| Ticket Characteristics | Start Status | Rationale |\n   396→|----------------------|--------------|-----------|\n   397→| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n   398→| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n   399→| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n   400→| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n   401→\n   402→The Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n   403→\n   404→> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n   405→\n   406→### `filterEligible(actionableTasks, allTasks, active)` — Dependency + Stage Resolution\n   407→\n   408→**Important**: Dependency checks must run against **all tasks** (every status), not just the actionable ones. Otherwise, a dependency in `Research In Progress` (not a `Needs *` status, not in the in-memory `active` map after a restart) would be invisible and incorrectly treated as satisfied.\n   409→\n   410→```typescript\n   411→private filterEligible(\n   412→  actionableTasks: TaskRequest[],\n   413→  allTasks: TaskRequest[],\n   414→  active: Map<string, Promise<void>>\n   415→): TaskRequest[] {\n   416→  return actionableTasks.filter(task => {\n   417→    if (active.has(task.id)) return false;\n   418→    return task.dependsOn.every(depId => {\n   419→      if (active.has(depId)) return false;       // dep running in this process → wait\n   420→      const dep = allTasks.find(t => t.id === depId);\n   421→      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n   422→      return dep.status === TaskStatus.Done;       // only Done = satisfied\n   423→    });\n   424→  });\n   425→}\n   426→```\n   427→\n   428→The `processQueue` loop calls this as:\n   429→\n   430→```typescript\n   431→const actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses only\n   432→const all = await this.loadAllTasks();                 // every status\n   433→const eligible = this.filterEligible(actionable, all, active);\n   434→```\n   435→\n   436→Four states a dependency can be in:\n   437→- **`Done`** — satisfied, proceed\n   438→- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n   439→- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n   440→- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n   441→- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n   442→\n   443→No variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n   444→\n   445→### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n   446→\n   447→A ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n   448→\n   449→```typescript\n   450→private async isTerminal(task: TaskRequest): Promise<boolean> {\n   451→  const allTasks = await this.loadAllTasks();  // all statuses\n   452→  return !allTasks.some(t =>\n   453→    t.id !== task.id &&\n   454→    t.dependsOn.includes(task.id) &&\n   455→    t.status !== TaskStatus.Done\n   456→  );\n   457→}\n   458→```\n   459→\n   460→> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n   461→\n   462→This determines:\n   463→- **Terminal**: Create PR, attempt merge to main\n   464→- **Non-terminal**: Just push to group branch, no PR, no merge\n   465→\n   466→### `branchName(task)` — Group-Aware Branch Naming (NEW)\n   467→\n   468→```typescript\n   469→private branchName(task: TaskRequest): string {\n   470→  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n   471→}\n   472→```\n   473→\n   474→### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n   475→\n   476→Each invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n   477→\n   478→Key behaviors:\n   479→1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n   480→2. **Branch name** passed to worker prompt uses `branchName(task)`\n   481→3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n   482→4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n   483→5. **`variant_hint`** included in worker prompt when present\n   484→6. Returns parsed WORK_RESULT including `nextStatus` field\n   485→7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot\n   486→8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n   487→\n   488→### `writeResults(task, result)` — Update MD File\n   489→\n   490→Parses WORK_RESULT from agent output, writes structured summary to MD body:\n   491→\n   492→```markdown\n   493→---\n   494→id: AGI-8\n   495→title: Add auth middleware\n   496→status: Done\n   497→group: dashboard-v2\n   498→...\n   499→---\n   500→\n   501→## Results\n   502→\n   503→**Completed**: 2026-02-14T12:00:00Z\n   504→**Branch**: feat/dashboard-v2\n   505→\n   506→### Summary\n   507→{parsed from WORK_RESULT}\n   508→\n   509→### Artifacts\n   510→- Commit: abc1234\n   511→- PR: https://github.com/user/repo/pull/43  (only if terminal)\n   512→```\n   513→\n   514→### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n   515→\n   516→Previous plan merged after every ticket. Now merge only when `isTerminal(task)`:\n   517→\n   518→```typescript\n   519→private async tryMerge(task: TaskRequest): Promise<boolean> {\n   520→  const branch = this.branchName(task);\n   521→  try {\n   522→    execSync(\n   523→      `git fetch origin && git checkout ${branch} && git rebase main` +\n   524→      ` && git checkout main && git merge ${branch}`\n   525→    );\n   526→    return true;\n   527→  } catch {\n   528→    await this.updateTaskStatus(task, \"Blocked\");\n   529→    return false;\n   530→  }\n   531→}\n   532→```\n   533→\n   534→For non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n   535→\n   536→---\n   537→\n   538→## Phase 4: Entry Point (`src/index.ts`)\n   539→\n   540→Two modes of operation:\n   541→\n   542→```typescript\n   543→async function main() {\n   544→  const command = process.argv[2];\n   545→\n   546→  if (command === \"spec\") {\n   547→    const request = process.argv.slice(3).join(\" \") || await readStdin();\n   548→    const specAgent = new SpecAgent(queueDir);\n   549→    await specAgent.clarify(request);\n   550→  } else {\n   551→    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n   552→    await orchestrator.processQueue();\n   553→  }\n   554→}\n   555→```\n   556→\n   557→Usage:\n   558→- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n   559→- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n   560→- `npx tsx src/index.ts` → Orchestrator loop\n   561→\n   562→---\n   563→\n   564→## `TaskRequest` Interface Update\n   565→\n   566→```typescript\n   567→interface TaskRequest {\n   568→  id: string;\n   569→  file: string;\n   570→  filePath: string;\n   571→  title: string;\n   572→  description: string;\n   573→  repo: string;\n   574→  numberOfSandboxes: number;\n   575→  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n   576→  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n   577→  variantHint?: string;      // design direction for this variant\n   578→  status: TaskStatus;\n   579→}\n   580→```\n   581→\n   582→---\n   583→\n   584→## Task Status Model\n   585→\n   586→The worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n   587→\n   588→### Status Enum\n   589→\n   590→```typescript\n   591→enum TaskStatus {\n   592→  // Entry\n   593→  Backlog              = \"Backlog\",\n   594→\n   595→  // Stage: Research\n   596→  NeedsResearch        = \"Needs Research\",\n   597→  ResearchInProgress   = \"Research In Progress\",\n   598→\n   599→  // Stage: Specification (optional — research decides if needed)\n   600→  NeedsSpecification   = \"Needs Specification\",\n   601→  SpecificationInProgress = \"Specification In Progress\",\n   602→\n   603→  // Stage: Plan\n   604→  NeedsPlan            = \"Needs Plan\",\n   605→  PlanInProgress       = \"Plan In Progress\",\n   606→\n   607→  // Stage: Implement\n   608→  NeedsImplement       = \"Needs Implement\",\n   609→  ImplementInProgress  = \"Implement In Progress\",\n   610→\n   611→  // Stage: Validate\n   612→  NeedsValidate        = \"Needs Validate\",\n   613→  ValidateInProgress   = \"Validate In Progress\",\n   614→\n   615→  // Stage: Oneshot (fast-track, decided during research)\n   616→  OneshotInProgress    = \"Oneshot In Progress\",\n   617→\n   618→  // Terminal\n   619→  Done                 = \"Done\",\n   620→  AwaitingMerge        = \"Awaiting Merge\",\n   621→\n   622→  // Intervention (requires human action)\n   623→  Blocked              = \"Blocked\",\n   624→  NeedsHumanReview     = \"Needs Human Review\",\n   625→  NeedsHumanDecision   = \"Needs Human Decision\",\n   626→}\n   627→```\n   628→\n   629→### Stage Transition Diagram\n   630→\n   631→```\n   632→Backlog\n   633→  │\n   634→  ▼\n   635→Needs Research ──→ Research In Progress\n   636→  │\n   637→  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n   638→  │\n   639→  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n   640→               │\n   641→               └──→ Needs Plan (skip spec if pure backend / no UX)\n   642→                      │\n   643→                      ▼\n   644→                    Plan In Progress ──→ Needs Implement\n   645→                      │\n   646→                      ▼\n   647→                    Implement In Progress ──→ Needs Validate\n   648→                      │\n   649→                      ▼\n   650→                    Validate In Progress ──→ Done / Awaiting Merge\n   651→\n   652→ANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n   653→```\n   654→\n   655→### How the Orchestrator Uses Statuses\n   656→\n   657→The orchestrator dispatches workers based on the current status:\n   658→\n   659→```typescript\n   660→private stagePromptMap: Record<string, string> = {\n   661→  \"Needs Research\":        \"agent2-worker-research.md\",\n   662→  \"Needs Specification\":   \"agent2-worker-specification.md\",\n   663→  \"Needs Plan\":            \"agent2-worker-plan.md\",\n   664→  \"Needs Implement\":       \"agent2-worker-implement.md\",\n   665→  \"Needs Validate\":        \"agent2-worker-validate.md\",\n   666→};\n   667→\n   668→async dispatchWorker(task: TaskRequest): Promise<void> {\n   669→  const prompt = this.stagePromptMap[task.status];\n   670→  if (!prompt) return; // not in a \"Needs *\" status — skip\n   671→\n   672→  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n   673→  const result = await this.runWorkerAgent(sandbox, task, prompt);\n   674→  await this.updateTaskStatus(task, result.nextStatus);\n   675→}\n   676→```\n   677→\n   678→Key change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n   679→\n   680→### WORK_RESULT Stage Output\n   681→\n   682→Each stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n   683→\n   684→```yaml\n   685→WORK_RESULT\n   686→---\n   687→success: true\n   688→stage_completed: research\n   689→workflow: staged          # or \"oneshot\"\n   690→next_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n   691→---\n   692→```\n   693→\n   694→### Intervention Statuses\n   695→\n   696→When a worker cannot proceed, it sets one of three intervention statuses:\n   697→\n   698→| Status | Meaning | Example |\n   699→|--------|---------|---------|\n   700→| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n   701→| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n   702→| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n   703→\n   704→Intervention output includes structured context for the human:\n   705→\n   706→```yaml\n   707→WORK_RESULT\n   708→---\n   709→success: false\n   710→stage_completed: research\n   711→next_status: \"Needs Human Decision\"\n   712→intervention:\n   713→  summary: \"Two valid auth approaches — need human to choose\"\n   714→  options:\n   715→    - \"JWT with refresh tokens — simpler, stateless\"\n   716→    - \"Session-based with Redis — better revocation\"\n   717→  questions:\n   718→    - \"Which approach aligns with your scaling plans?\"\n   719→---\n   720→```\n   721→\n   722→### Orchestrator Handling of Intervention Statuses\n   723→\n   724→```typescript\n   725→private isActionable(task: TaskRequest): boolean {\n   726→  return task.status.startsWith(\"Needs \") &&\n   727→    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n   728→}\n   729→```\n   730→\n   731→Tickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n   732→\n   733→### `filterEligible` Update\n   734→\n   735→The previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n   736→\n   737→```typescript\n   738→private filterEligible(\n   739→  tasks: TaskRequest[],\n   740→  active: Map<string, Promise<void>>\n   741→): TaskRequest[] {\n   742→  return tasks.filter(task => {\n   743→    if (active.has(task.id)) return false;\n   744→    if (!this.isActionable(task)) return false;\n   745→    return task.dependsOn.every(depId => {\n   746→      if (active.has(depId)) return false;\n   747→      const dep = tasks.find(t => t.id === depId);\n   748→      return !dep || dep.status === \"Done\";\n   749→    });\n   750→  });\n   751→}\n   752→```\n   753→\n   754→### Two Task Loaders\n   755→\n   756→- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n   757→- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n   758→\n   759→Both are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.\n   760→\n   761→## Changes Required for Variant Support (vs. previous plan)\n   762→\n   763→Summary of what the variant group feature specifically adds or changes:\n   764→\n   765→| Component | Previous Plan | Change for Variants |\n   766→|-----------|--------------|-------------------|\n   767→| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n   768→| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n   769→| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n   770→| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n   771→| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n   772→| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n   773→| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n   774→| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n   775→| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n   776→| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n   777→| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n   778→| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n   779→| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n   780→| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n   781→\n   782→---\n   783→\n   784→## Variant Example: End-to-End\n   785→\n   786→User: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n   787→\n   788→Spec Agent produces after clarification:\n   789→\n   790→```\n   791→# Variant 1: Minimal card layout\n   792→AGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\n   793→AGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\n   794→AGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n   795→                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n   796→\n   797→# Variant 2: Data-dense table layout\n   798→AGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\n   799→AGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\n   800→AGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n   801→                                variant_hint: \"Dense table layout, information-rich\")\n   802→```\n   803→\n   804→Orchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n   805→\n   806→```\n   807→t=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n   808→        → dispatch both in parallel, each gets Plan stage prompt\n   809→        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n   810→        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n   811→\n   812→t=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n   813→        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n   814→        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n   815→           → outputs next_status: \"Needs Validate\"\n   816→        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n   817→           → outputs next_status: \"Needs Validate\"\n   818→\n   819→t=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n   820→        → dispatch both, Validate stage prompt\n   821→        → Worker E: AGI-5 validates → next_status: \"Done\"\n   822→           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n   823→        → Worker F: AGI-8 validates → next_status: \"Done\"\n   824→           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n   825→\n   826→t=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n   827→        → dispatch both for Plan stage\n   828→        ... (same cycle: Plan → Implement → Validate)\n   829→\n   830→t=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n   831→      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n   832→\n   833→t=5   AGI-6 validates → Done. AGI-9 validates → Done.\n   834→        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n   835→\n   836→t=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n   837→        ... Plan → Implement → Validate cycle\n   838→\n   839→t=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n   840→      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n   841→\n   842→t=8   AGI-7 validates → Done. AGI-10 validates → Done.\n   843→        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n   844→        → AGI-7 creates PR for feat/dashboard-v1\n   845→        → AGI-10 creates PR for feat/dashboard-v2\n   846→        → Orchestrator merges whichever the user approves\n   847→```\n   848→\n   849→Key observations:\n   850→- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n   851→- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n   852→- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n   853→- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n   854→\n   855→User gets 2 PRs to compare side-by-side.\n   856→\n   857→---\n   858→\n   859→## Files\n   860→\n   861→| File | Change |\n   862→|------|--------|\n   863→| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n   864→| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n   865→| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n   866→| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n   867→| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n   868→| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n   869→| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n   870→| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n   871→| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n   872→| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n   873→\n   874→---\n   875→\n   876→## Verification\n   877→\n   878→1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n   879→2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n   880→3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n   881→4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n   882→5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n   883→6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n   884→7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n   885→8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   886→   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   887→   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   888→   - Non-terminal tickets push to shared branch, no PR\n   889→   - Terminal tickets create PR and attempt merge\n   890→   - Group branch accumulates commits across chain\n   891→9. **Existing tests**: `npm test` passes\n   892→\n   893→---\n   894→\n   895→## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n   896→\n   897→### Purpose\n   898→\n   899→Every worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n   900→\n   901→### Two-Tier Testing Strategy\n   902→\n   903→| Ticket type | Unit tests | Integration tests |\n   904→|-------------|-----------|-------------------|\n   905→| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n   906→| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n   907→\n   908→### Execution Flow\n   909→\n   910→The test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n   911→\n   912→```\n   913→executeWorker(task):\n   914→  1. Worker agent implements feature, commits, pushes\n   915→  2. Test-writer agent runs in same sandbox:\n   916→     a. Reads the git diff (all commits on this branch vs main)\n   917→     b. Reads the ticket description + acceptance criteria\n   918→     c. If terminal: also reads all tickets in the group chain for integration context\n   919→     d. Writes test files to tests/\n   920→     e. Runs `npm test` to verify all tests pass\n   921→     f. Commits test files, pushes to same branch\n   922→  3. Return combined WORK_RESULT (implementation + test summary)\n   923→```\n   924→\n   925→### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n   926→\n   927→```\n   928→You are a Test-Writer Agent. You have just received a completed implementation in this\n   929→sandbox. Your job is to write tests for the code that was changed.\n   930→\n   931→## Context\n   932→\n   933→**Ticket**: {ticket title + description + acceptance criteria}\n   934→**Branch diff vs main**: {git diff main...HEAD}\n   935→**Is terminal ticket**: {true/false}\n   936→{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n   937→\n   938→## Rules\n   939→\n   940→1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n   941→2. Follow existing test patterns in the repo (see tests/ for examples).\n   942→3. Write **unit tests** for:\n   943→   - Every new public method on any class\n   944→   - Non-trivial private logic (parsing, state transitions, validation)\n   945→   - Both happy path and at least one meaningful failure case per method\n   946→   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n   947→4. If this is a **terminal ticket**, also write **integration tests** that:\n   948→   - Exercise the full chain of features built across this variant group\n   949→   - Test interactions between the new code and pre-existing repo code\n   950→   - Cover end-to-end flows from the user's perspective where applicable\n   951→5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n   952→6. Run `npm test` after writing. If tests fail, fix them before committing.\n   953→7. Commit all test files with message: \"test: add tests for {ticket title}\"\n   954→\n   955→## Output\n   956→\n   957→TEST_RESULT\n   958→---\n   959→files_created: [list of test file paths]\n   960→unit_tests: {count}\n   961→integration_tests: {count}\n   962→all_passing: {true/false}\n   963→---\n   964→```\n   965→\n   966→### Orchestrator Integration\n   967→\n   968→Modify `executeWorker()` to include the test-writer step:\n   969→\n   970→```typescript\n   971→private async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n   972→  const sandbox = await this.createSandbox(task);\n   973→\n   974→  // Step 1: Implementation worker\n   975→  const implResult = await this.runWorkerAgent(sandbox, task);\n   976→\n   977→  // Step 2: Test-writer (same sandbox, deterministic)\n   978→  const isTerminal = await this.isTerminal(task);\n   979→  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n   980→  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n   981→\n   982→  return { impl: implResult, tests: testResult };\n   983→}\n   984→```\n   985→\n   986→### `writeResults` Update\n   987→\n   988→The result block now includes test metadata:\n   989→\n   990→```markdown\n   991→## Results\n   992→\n   993→**Completed**: 2026-02-14T12:00:00Z\n   994→**Branch**: feat/dashboard-v2\n   995→\n   996→### Summary\n   997→{parsed from WORK_RESULT}\n   998→\n   999→### Tests\n  1000→- Unit tests: 8\n  1001→- Integration tests: 3 (terminal only)\n  1002→- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n  1003→- All passing: true\n  1004→\n  1005→### Artifacts\n  1006→- Commit: abc1234 (implementation)\n  1007→- Commit: def5678 (tests)\n  1008→- PR: https://github.com/user/repo/pull/43 (only if terminal)\n  1009→```\n  1010→\n  1011→### Files Update\n  1012→\n  1013→| File | Change |\n  1014→|------|--------|\n  1015→| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n  1016→| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n  1017→"}]},"uuid":"5a24c548-7db0-4699-b29b-da57aa44bc61","timestamp":"2026-02-14T10:13:59.462Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `request_queue/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `request_queue/` |\n> | **Agent 1 (Reader)** | Queries Linear for issues in specific statuses | Reads `request_queue/*.md`, filters by `status: Needs Research` |\n> | **Agent 3 (Writer)** | Posts comments + updates Linear issue status | Updates MD frontmatter status + appends result sections |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Queue Reader** — reads from `request_queue/*.md` | **HIGH** — Replace all `mcp__linear__*` calls with local file I/O. Keep multi-agent conflict/claim logic. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Queue Writer** — updates MD files with results | **HIGH** — Remove all MCP calls, write results to MD files, handle sub-issue creation as new queue files |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to request_queue/\n  ▼\nagent1-linear-reader.md (Queue Reader — IN SANDBOX, adapted for local queue)\n  │ Reads ticket from queue, claims it, outputs context for worker\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after worker)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nagent3-linear-writer.md (Queue Writer — IN SANDBOX, adapted for local queue)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  ▼\nOrchestrator decides: terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to request_queue/ as MD files (status: Needs Research)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads request_queue/, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\n<!-- I need 2 IDs here, one to track the feature requests from the user, the other to track the tickets for the implementation; for ease of implementation, also create a dir \"feature_requests_id\" to store the feature request. If a feature request has variants requsted by the user, create a separate directory to store each \"group\" of tickets per variant -->\nAfter the spec is complete, writes each ticket as an MD file to `request_queue/`:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `request_queue/` files to find the current max `AGI-{n}` ID (reuses logic from `SandboxQueueProcessor.loadTasksFromQueue()`). New tickets start from `max + 1`.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses\n    const all = await this.loadAllTasks();                // every status\n    const eligible = this.filterEligible(actionable, all, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(actionableTasks, allTasks, active)` — Dependency + Stage Resolution\n\n**Important**: Dependency checks must run against **all tasks** (every status), not just the actionable ones. Otherwise, a dependency in `Research In Progress` (not a `Needs *` status, not in the in-memory `active` map after a restart) would be invisible and incorrectly treated as satisfied.\n\n```typescript\nprivate filterEligible(\n  actionableTasks: TaskRequest[],\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return actionableTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses only\nconst all = await this.loadAllTasks();                 // every status\nconst eligible = this.filterEligible(actionable, all, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot\n8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","numLines":1017,"startLine":1,"totalLines":1017}},"sourceToolAssistantUUID":"7950720d-c635-4fa2-be6e-4cfb2050f227"}
{"parentUuid":"5a24c548-7db0-4699-b29b-da57aa44bc61","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_016VANumqEetgp2CDSwktUhb","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have the full picture. Let me apply all 6 changes systematically.\n\n**Edit 1: Issue #4 — Remove agent1/agent3 from reference architecture table**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":16018,"cache_read_input_tokens":60599,"cache_creation":{"ephemeral_5m_input_tokens":16018,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nU3dbqcqKYZ7SAcB6g","type":"assistant","uuid":"4da80b18-ea4c-4005-977e-6384281a8666","timestamp":"2026-02-14T10:14:03.958Z"}
{"parentUuid":"4da80b18-ea4c-4005-977e-6384281a8666","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_016VANumqEetgp2CDSwktUhb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NjW8GefBbm71WXwR72kb24","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `request_queue/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `request_queue/` |\n> | **Agent 1 (Reader)** | Queries Linear for issues in specific statuses | Reads `request_queue/*.md`, filters by `status: Needs Research` |\n> | **Agent 3 (Writer)** | Posts comments + updates Linear issue status | Updates MD frontmatter status + appends result sections |","new_string":"> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":16018,"cache_read_input_tokens":60599,"cache_creation":{"ephemeral_5m_input_tokens":16018,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nU3dbqcqKYZ7SAcB6g","type":"assistant","uuid":"c99ecce3-2d65-4d02-86d9-6159abd3a2f4","timestamp":"2026-02-14T10:14:14.146Z"}
{"parentUuid":"c99ecce3-2d65-4d02-86d9-6159abd3a2f4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01NjW8GefBbm71WXwR72kb24","parentToolUseID":"toolu_01NjW8GefBbm71WXwR72kb24","uuid":"2f403f78-99ab-4197-b799-cb972edfc4e1","timestamp":"2026-02-14T10:14:14.149Z"}
{"type":"file-history-snapshot","messageId":"c99ecce3-2d65-4d02-86d9-6159abd3a2f4","snapshot":{"messageId":"aad31b83-18ce-4759-a4b5-5451de419ccc","trackedFileBackups":{"IMPLEMENTATION_PLAN.md":{"backupFileName":"7cb5415938e35d8f@v1","version":1,"backupTime":"2026-02-14T10:14:20.893Z"}},"timestamp":"2026-02-14T10:13:38.509Z"},"isSnapshotUpdate":true}
{"parentUuid":"2f403f78-99ab-4197-b799-cb972edfc4e1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01NjW8GefBbm71WXwR72kb24","toolUseID":"toolu_01NjW8GefBbm71WXwR72kb24","timestamp":"2026-02-14T10:14:20.899Z","uuid":"189bbdc6-a676-467d-8505-da3423a3672b"}
{"parentUuid":"189bbdc6-a676-467d-8505-da3423a3672b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01NjW8GefBbm71WXwR72kb24","toolUseID":"toolu_01NjW8GefBbm71WXwR72kb24","timestamp":"2026-02-14T10:14:20.899Z","uuid":"13124951-5545-4810-b77e-bf1de2848422"}
{"parentUuid":"c99ecce3-2d65-4d02-86d9-6159abd3a2f4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NjW8GefBbm71WXwR72kb24","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"dfeb1228-abc2-4f48-8e87-9c115c0fe5fd","timestamp":"2026-02-14T10:14:20.897Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `request_queue/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `request_queue/` |\n> | **Agent 1 (Reader)** | Queries Linear for issues in specific statuses | Reads `request_queue/*.md`, filters by `status: Needs Research` |\n> | **Agent 3 (Writer)** | Posts comments + updates Linear issue status | Updates MD frontmatter status + appends result sections |","newString":"> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `request_queue/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `request_queue/` |\n> | **Agent 1 (Reader)** | Queries Linear for issues in specific statuses | Reads `request_queue/*.md`, filters by `status: Needs Research` |\n> | **Agent 3 (Writer)** | Posts comments + updates Linear issue status | Updates MD frontmatter status + appends result sections |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Queue Reader** — reads from `request_queue/*.md` | **HIGH** — Replace all `mcp__linear__*` calls with local file I/O. Keep multi-agent conflict/claim logic. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Queue Writer** — updates MD files with results | **HIGH** — Remove all MCP calls, write results to MD files, handle sub-issue creation as new queue files |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to request_queue/\n  ▼\nagent1-linear-reader.md (Queue Reader — IN SANDBOX, adapted for local queue)\n  │ Reads ticket from queue, claims it, outputs context for worker\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after worker)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nagent3-linear-writer.md (Queue Writer — IN SANDBOX, adapted for local queue)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  ▼\nOrchestrator decides: terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to request_queue/ as MD files (status: Needs Research)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads request_queue/, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\n<!-- I need 2 IDs here, one to track the feature requests from the user, the other to track the tickets for the implementation; for ease of implementation, also create a dir \"feature_requests_id\" to store the feature request. If a feature request has variants requsted by the user, create a separate directory to store each \"group\" of tickets per variant -->\nAfter the spec is complete, writes each ticket as an MD file to `request_queue/`:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `request_queue/` files to find the current max `AGI-{n}` ID (reuses logic from `SandboxQueueProcessor.loadTasksFromQueue()`). New tickets start from `max + 1`.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses\n    const all = await this.loadAllTasks();                // every status\n    const eligible = this.filterEligible(actionable, all, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(actionableTasks, allTasks, active)` — Dependency + Stage Resolution\n\n**Important**: Dependency checks must run against **all tasks** (every status), not just the actionable ones. Otherwise, a dependency in `Research In Progress` (not a `Needs *` status, not in the in-memory `active` map after a restart) would be invisible and incorrectly treated as satisfied.\n\n```typescript\nprivate filterEligible(\n  actionableTasks: TaskRequest[],\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return actionableTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses only\nconst all = await this.loadAllTasks();                 // every status\nconst eligible = this.filterEligible(actionable, all, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot\n8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":17,"oldLines":12,"newStart":17,"newLines":12,"lines":[" >"," > | Concern | Horizon | Napoli-Matcha |"," > |---------|---------|---------------|","-> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `request_queue/` with YAML frontmatter |","+> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |"," > | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |"," > | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |","-> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `request_queue/` |","-> | **Agent 1 (Reader)** | Queries Linear for issues in specific statuses | Reads `request_queue/*.md`, filters by `status: Needs Research` |","-> | **Agent 3 (Writer)** | Posts comments + updates Linear issue status | Updates MD frontmatter status + appends result sections |","+> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |","+> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |","+> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |"," >"," > When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O."," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"c99ecce3-2d65-4d02-86d9-6159abd3a2f4"}
{"parentUuid":"dfeb1228-abc2-4f48-8e87-9c115c0fe5fd","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01Y3bPzNfU6a9Hx8aT2g98Gm","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 2: Issue #4 — Remove agent1/agent3 from prompt mapping table**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":730,"cache_read_input_tokens":76617,"cache_creation":{"ephemeral_5m_input_tokens":730,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nVdNeRxtv7z16UJo4e","type":"assistant","uuid":"cf0bbd11-7f09-4580-88b6-38f388a62da9","timestamp":"2026-02-14T10:14:23.467Z"}
{"parentUuid":"cf0bbd11-7f09-4580-88b6-38f388a62da9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01Y3bPzNfU6a9Hx8aT2g98Gm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TpSvGRn6m7Cam9tobz6XiP","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Queue Reader** — reads from `request_queue/*.md` | **HIGH** — Replace all `mcp__linear__*` calls with local file I/O. Keep multi-agent conflict/claim logic. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |","new_string":"| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":730,"cache_read_input_tokens":76617,"cache_creation":{"ephemeral_5m_input_tokens":730,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nVdNeRxtv7z16UJo4e","type":"assistant","uuid":"3d8232b3-f89e-41d7-9c6e-393446ac32ee","timestamp":"2026-02-14T10:14:28.791Z"}
{"parentUuid":"3d8232b3-f89e-41d7-9c6e-393446ac32ee","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01TpSvGRn6m7Cam9tobz6XiP","parentToolUseID":"toolu_01TpSvGRn6m7Cam9tobz6XiP","uuid":"2aea419c-9d3f-433b-ab97-eaec47184a31","timestamp":"2026-02-14T10:14:28.793Z"}
{"parentUuid":"2aea419c-9d3f-433b-ab97-eaec47184a31","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01TpSvGRn6m7Cam9tobz6XiP","toolUseID":"toolu_01TpSvGRn6m7Cam9tobz6XiP","timestamp":"2026-02-14T10:14:28.845Z","uuid":"e0aa79c5-6c0c-4f31-acb2-b528b490516f"}
{"parentUuid":"e0aa79c5-6c0c-4f31-acb2-b528b490516f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01TpSvGRn6m7Cam9tobz6XiP","toolUseID":"toolu_01TpSvGRn6m7Cam9tobz6XiP","timestamp":"2026-02-14T10:14:28.845Z","uuid":"e516b40c-42ed-4383-a8c4-35ec53a754b3"}
{"parentUuid":"3d8232b3-f89e-41d7-9c6e-393446ac32ee","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TpSvGRn6m7Cam9tobz6XiP","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"c5bfa941-be3a-42f3-ab4b-9dbc18ed1902","timestamp":"2026-02-14T10:14:28.844Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Queue Reader** — reads from `request_queue/*.md` | **HIGH** — Replace all `mcp__linear__*` calls with local file I/O. Keep multi-agent conflict/claim logic. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |","newString":"| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Queue Reader** — reads from `request_queue/*.md` | **HIGH** — Replace all `mcp__linear__*` calls with local file I/O. Keep multi-agent conflict/claim logic. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Queue Writer** — updates MD files with results | **HIGH** — Remove all MCP calls, write results to MD files, handle sub-issue creation as new queue files |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to request_queue/\n  ▼\nagent1-linear-reader.md (Queue Reader — IN SANDBOX, adapted for local queue)\n  │ Reads ticket from queue, claims it, outputs context for worker\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after worker)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nagent3-linear-writer.md (Queue Writer — IN SANDBOX, adapted for local queue)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  ▼\nOrchestrator decides: terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to request_queue/ as MD files (status: Needs Research)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads request_queue/, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\n<!-- I need 2 IDs here, one to track the feature requests from the user, the other to track the tickets for the implementation; for ease of implementation, also create a dir \"feature_requests_id\" to store the feature request. If a feature request has variants requsted by the user, create a separate directory to store each \"group\" of tickets per variant -->\nAfter the spec is complete, writes each ticket as an MD file to `request_queue/`:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `request_queue/` files to find the current max `AGI-{n}` ID (reuses logic from `SandboxQueueProcessor.loadTasksFromQueue()`). New tickets start from `max + 1`.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses\n    const all = await this.loadAllTasks();                // every status\n    const eligible = this.filterEligible(actionable, all, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(actionableTasks, allTasks, active)` — Dependency + Stage Resolution\n\n**Important**: Dependency checks must run against **all tasks** (every status), not just the actionable ones. Otherwise, a dependency in `Research In Progress` (not a `Needs *` status, not in the in-memory `active` map after a restart) would be invisible and incorrectly treated as satisfied.\n\n```typescript\nprivate filterEligible(\n  actionableTasks: TaskRequest[],\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return actionableTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses only\nconst all = await this.loadAllTasks();                 // every status\nconst eligible = this.filterEligible(actionable, all, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot\n8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":36,"oldLines":7,"newStart":36,"newLines":7,"lines":[" "," | File | Horizon Role | Napoli Role | Adaptation Needed |"," |------|-------------|-------------|-------------------|","-| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Queue Reader** — reads from `request_queue/*.md` | **HIGH** — Replace all `mcp__linear__*` calls with local file I/O. Keep multi-agent conflict/claim logic. |","+| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |"," | `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |"," | `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |"," | `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"3d8232b3-f89e-41d7-9c6e-393446ac32ee"}
{"parentUuid":"c5bfa941-be3a-42f3-ab4b-9dbc18ed1902","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_016FsnQvBdL5XZW44QAJNySm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UR7Xhc9SZyzbMAZbj2V2hn","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Queue Writer** — updates MD files with results | **HIGH** — Remove all MCP calls, write results to MD files, handle sub-issue creation as new queue files |","new_string":"| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":454,"cache_read_input_tokens":77347,"cache_creation":{"ephemeral_5m_input_tokens":454,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nWD99t5SYRWiQycesJ","type":"assistant","uuid":"9d7e4378-f094-4395-9a62-c002e1b52312","timestamp":"2026-02-14T10:14:34.090Z"}
{"parentUuid":"9d7e4378-f094-4395-9a62-c002e1b52312","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01UR7Xhc9SZyzbMAZbj2V2hn","parentToolUseID":"toolu_01UR7Xhc9SZyzbMAZbj2V2hn","uuid":"82cebfbd-8a44-4738-9fd6-b48b7b8b266d","timestamp":"2026-02-14T10:14:34.093Z"}
{"parentUuid":"82cebfbd-8a44-4738-9fd6-b48b7b8b266d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01UR7Xhc9SZyzbMAZbj2V2hn","toolUseID":"toolu_01UR7Xhc9SZyzbMAZbj2V2hn","timestamp":"2026-02-14T10:14:34.138Z","uuid":"9f8d9c8a-9e24-484b-9ec0-288f85c65169"}
{"parentUuid":"9f8d9c8a-9e24-484b-9ec0-288f85c65169","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01UR7Xhc9SZyzbMAZbj2V2hn","toolUseID":"toolu_01UR7Xhc9SZyzbMAZbj2V2hn","timestamp":"2026-02-14T10:14:34.138Z","uuid":"e753119d-9b3b-4ec5-ac27-474c400438be"}
{"parentUuid":"9d7e4378-f094-4395-9a62-c002e1b52312","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UR7Xhc9SZyzbMAZbj2V2hn","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"b0b79347-612a-4024-ae9d-0c75ef76085f","timestamp":"2026-02-14T10:14:34.137Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Queue Writer** — updates MD files with results | **HIGH** — Remove all MCP calls, write results to MD files, handle sub-issue creation as new queue files |","newString":"| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Queue Writer** — updates MD files with results | **HIGH** — Remove all MCP calls, write results to MD files, handle sub-issue creation as new queue files |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to request_queue/\n  ▼\nagent1-linear-reader.md (Queue Reader — IN SANDBOX, adapted for local queue)\n  │ Reads ticket from queue, claims it, outputs context for worker\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after worker)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nagent3-linear-writer.md (Queue Writer — IN SANDBOX, adapted for local queue)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  ▼\nOrchestrator decides: terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to request_queue/ as MD files (status: Needs Research)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads request_queue/, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\n<!-- I need 2 IDs here, one to track the feature requests from the user, the other to track the tickets for the implementation; for ease of implementation, also create a dir \"feature_requests_id\" to store the feature request. If a feature request has variants requsted by the user, create a separate directory to store each \"group\" of tickets per variant -->\nAfter the spec is complete, writes each ticket as an MD file to `request_queue/`:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `request_queue/` files to find the current max `AGI-{n}` ID (reuses logic from `SandboxQueueProcessor.loadTasksFromQueue()`). New tickets start from `max + 1`.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses\n    const all = await this.loadAllTasks();                // every status\n    const eligible = this.filterEligible(actionable, all, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(actionableTasks, allTasks, active)` — Dependency + Stage Resolution\n\n**Important**: Dependency checks must run against **all tasks** (every status), not just the actionable ones. Otherwise, a dependency in `Research In Progress` (not a `Needs *` status, not in the in-memory `active` map after a restart) would be invisible and incorrectly treated as satisfied.\n\n```typescript\nprivate filterEligible(\n  actionableTasks: TaskRequest[],\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return actionableTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses only\nconst all = await this.loadAllTasks();                 // every status\nconst eligible = this.filterEligible(actionable, all, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot\n8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":44,"oldLines":7,"newStart":44,"newLines":7,"lines":[" | `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |"," | `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |"," | `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |","-| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Queue Writer** — updates MD files with results | **HIGH** — Remove all MCP calls, write results to MD files, handle sub-issue creation as new queue files |","+| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |"," | `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |"," | `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |"," | `fragments/merge-pr.md` | PR creation path | Same | **NONE** |"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"9d7e4378-f094-4395-9a62-c002e1b52312"}
{"parentUuid":"b0b79347-612a-4024-ae9d-0c75ef76085f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01LN7pqbgBWhaBEvCjh7Gxs6","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 3: Issue #4 + #5 — Update pipeline diagram (remove agent1/agent3, update paths)**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":307,"cache_read_input_tokens":77801,"cache_creation":{"ephemeral_5m_input_tokens":307,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nWbmgX2oD9Bx16J5TM","type":"assistant","uuid":"0e7e5f60-9ed7-4cd1-87f9-73d77a21c090","timestamp":"2026-02-14T10:14:36.840Z"}
{"parentUuid":"0e7e5f60-9ed7-4cd1-87f9-73d77a21c090","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01LN7pqbgBWhaBEvCjh7Gxs6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SB4SkBVpp7B7tMkDRyNyHB","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to request_queue/\n  ▼\nagent1-linear-reader.md (Queue Reader — IN SANDBOX, adapted for local queue)\n  │ Reads ticket from queue, claims it, outputs context for worker\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after worker)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nagent3-linear-writer.md (Queue Writer — IN SANDBOX, adapted for local queue)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  ▼\nOrchestrator decides: terminal? → PR + merge. Non-terminal? → push, next ticket.\n```","new_string":"```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":307,"cache_read_input_tokens":77801,"cache_creation":{"ephemeral_5m_input_tokens":307,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nWbmgX2oD9Bx16J5TM","type":"assistant","uuid":"7451ee9d-e63d-413e-9ffd-da4e4986a8ad","timestamp":"2026-02-14T10:14:46.351Z"}
{"parentUuid":"7451ee9d-e63d-413e-9ffd-da4e4986a8ad","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01SB4SkBVpp7B7tMkDRyNyHB","parentToolUseID":"toolu_01SB4SkBVpp7B7tMkDRyNyHB","uuid":"d99811e7-d37e-4399-b0b1-59501dd69989","timestamp":"2026-02-14T10:14:46.354Z"}
{"parentUuid":"d99811e7-d37e-4399-b0b1-59501dd69989","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01SB4SkBVpp7B7tMkDRyNyHB","toolUseID":"toolu_01SB4SkBVpp7B7tMkDRyNyHB","timestamp":"2026-02-14T10:14:46.402Z","uuid":"cf2d2867-faf4-4699-a4a0-e85524914d2f"}
{"parentUuid":"cf2d2867-faf4-4699-a4a0-e85524914d2f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01SB4SkBVpp7B7tMkDRyNyHB","toolUseID":"toolu_01SB4SkBVpp7B7tMkDRyNyHB","timestamp":"2026-02-14T10:14:46.402Z","uuid":"c60b5174-e5fc-4911-9638-d5f4bc338151"}
{"parentUuid":"7451ee9d-e63d-413e-9ffd-da4e4986a8ad","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SB4SkBVpp7B7tMkDRyNyHB","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"b1f37a58-dd2f-4eda-b96e-f57f8fec1015","timestamp":"2026-02-14T10:14:46.401Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to request_queue/\n  ▼\nagent1-linear-reader.md (Queue Reader — IN SANDBOX, adapted for local queue)\n  │ Reads ticket from queue, claims it, outputs context for worker\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after worker)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nagent3-linear-writer.md (Queue Writer — IN SANDBOX, adapted for local queue)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  ▼\nOrchestrator decides: terminal? → PR + merge. Non-terminal? → push, next ticket.\n```","newString":"```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to request_queue/\n  ▼\nagent1-linear-reader.md (Queue Reader — IN SANDBOX, adapted for local queue)\n  │ Reads ticket from queue, claims it, outputs context for worker\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after worker)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nagent3-linear-writer.md (Queue Writer — IN SANDBOX, adapted for local queue)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  ▼\nOrchestrator decides: terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to request_queue/ as MD files (status: Needs Research)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads request_queue/, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\n<!-- I need 2 IDs here, one to track the feature requests from the user, the other to track the tickets for the implementation; for ease of implementation, also create a dir \"feature_requests_id\" to store the feature request. If a feature request has variants requsted by the user, create a separate directory to store each \"group\" of tickets per variant -->\nAfter the spec is complete, writes each ticket as an MD file to `request_queue/`:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `request_queue/` files to find the current max `AGI-{n}` ID (reuses logic from `SandboxQueueProcessor.loadTasksFromQueue()`). New tickets start from `max + 1`.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses\n    const all = await this.loadAllTasks();                // every status\n    const eligible = this.filterEligible(actionable, all, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(actionableTasks, allTasks, active)` — Dependency + Stage Resolution\n\n**Important**: Dependency checks must run against **all tasks** (every status), not just the actionable ones. Otherwise, a dependency in `Research In Progress` (not a `Needs *` status, not in the in-memory `active` map after a restart) would be invisible and incorrectly treated as satisfied.\n\n```typescript\nprivate filterEligible(\n  actionableTasks: TaskRequest[],\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return actionableTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses only\nconst all = await this.loadAllTasks();                 // every status\nconst eligible = this.filterEligible(actionable, all, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot\n8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":64,"oldLines":22,"newStart":64,"newLines":23,"lines":["   ▼"," agent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)","   │ Clarification loop until spec meets 5 quality criteria","-  │ Writes tickets to request_queue/","+  │ Writes tickets to feature_requests/FR-{n}/","   ▼","-agent1-linear-reader.md (Queue Reader — IN SANDBOX, adapted for local queue)","-  │ Reads ticket from queue, claims it, outputs context for worker","+Orchestrator (TypeScript — replaces agent1/agent3)","+  │ loadAllTasks() reads feature_requests/**/AGI-*.md","+  │ filterEligible() selects dispatch candidates","+  │ Dispatches one stage per worker invocation","   ▼"," agent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)","   │ 6-stage pipeline: research → spec → plan → implement → validate","   │ (or oneshot fast-track)","   ▼","-agent2-worker-test.md (Test Writer — IN SAME SANDBOX, after worker)","+agent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)","   │ Writes tests for the implementation, commits to same branch","   ▼","-agent3-linear-writer.md (Queue Writer — IN SANDBOX, adapted for local queue)","+Orchestrator (TypeScript)","   │ Parses WORK_RESULT, updates MD file with results + status","-  ▼","-Orchestrator decides: terminal? → PR + merge. Non-terminal? → push, next ticket.","+  │ terminal? → PR + merge. Non-terminal? → push, next ticket."," ```"," "," ### Adaptation Guidelines for Horizon → Napoli Prompts"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"7451ee9d-e63d-413e-9ffd-da4e4986a8ad"}
{"parentUuid":"b1f37a58-dd2f-4eda-b96e-f57f8fec1015","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01KBm6FNDvvJvmCdGAQpnuKD","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 4: Issue #5 — Update Full Pipeline section paths**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":790,"cache_read_input_tokens":78108,"cache_creation":{"ephemeral_5m_input_tokens":790,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nXWHJoCnqHSeZtzgEr","type":"assistant","uuid":"d32f9881-3463-4d63-893f-9edc490bdb79","timestamp":"2026-02-14T10:14:48.936Z"}
{"parentUuid":"d32f9881-3463-4d63-893f-9edc490bdb79","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01KBm6FNDvvJvmCdGAQpnuKD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EfaBdVT4iKXPVBsCx3CMub","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to request_queue/ as MD files (status: Needs Research)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads request_queue/, topological sort on depends_on","new_string":"  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":790,"cache_read_input_tokens":78108,"cache_creation":{"ephemeral_5m_input_tokens":790,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nXWHJoCnqHSeZtzgEr","type":"assistant","uuid":"adf20436-491c-4371-bf99-f2a031a2f573","timestamp":"2026-02-14T10:14:52.817Z"}
{"parentUuid":"adf20436-491c-4371-bf99-f2a031a2f573","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01EfaBdVT4iKXPVBsCx3CMub","parentToolUseID":"toolu_01EfaBdVT4iKXPVBsCx3CMub","uuid":"845c3687-c273-42d4-9dee-8dde7abab6e0","timestamp":"2026-02-14T10:14:52.821Z"}
{"parentUuid":"845c3687-c273-42d4-9dee-8dde7abab6e0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01EfaBdVT4iKXPVBsCx3CMub","toolUseID":"toolu_01EfaBdVT4iKXPVBsCx3CMub","timestamp":"2026-02-14T10:14:52.887Z","uuid":"61d814b0-e431-40f8-9e32-ebf6daa8392f"}
{"parentUuid":"61d814b0-e431-40f8-9e32-ebf6daa8392f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01EfaBdVT4iKXPVBsCx3CMub","toolUseID":"toolu_01EfaBdVT4iKXPVBsCx3CMub","timestamp":"2026-02-14T10:14:52.887Z","uuid":"b0068e14-004a-4661-9583-03a6167df0c4"}
{"parentUuid":"adf20436-491c-4371-bf99-f2a031a2f573","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EfaBdVT4iKXPVBsCx3CMub","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"3c36886f-3631-4222-b910-2408bde0e586","timestamp":"2026-02-14T10:14:52.886Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to request_queue/ as MD files (status: Needs Research)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads request_queue/, topological sort on depends_on","newString":"  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to request_queue/ as MD files (status: Needs Research)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads request_queue/, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\n<!-- I need 2 IDs here, one to track the feature requests from the user, the other to track the tickets for the implementation; for ease of implementation, also create a dir \"feature_requests_id\" to store the feature request. If a feature request has variants requsted by the user, create a separate directory to store each \"group\" of tickets per variant -->\nAfter the spec is complete, writes each ticket as an MD file to `request_queue/`:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `request_queue/` files to find the current max `AGI-{n}` ID (reuses logic from `SandboxQueueProcessor.loadTasksFromQueue()`). New tickets start from `max + 1`.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses\n    const all = await this.loadAllTasks();                // every status\n    const eligible = this.filterEligible(actionable, all, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(actionableTasks, allTasks, active)` — Dependency + Stage Resolution\n\n**Important**: Dependency checks must run against **all tasks** (every status), not just the actionable ones. Otherwise, a dependency in `Research In Progress` (not a `Needs *` status, not in the in-memory `active` map after a restart) would be invisible and incorrectly treated as satisfied.\n\n```typescript\nprivate filterEligible(\n  actionableTasks: TaskRequest[],\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return actionableTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses only\nconst all = await this.loadAllTasks();                 // every status\nconst eligible = this.filterEligible(actionable, all, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot\n8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":108,"oldLines":11,"newStart":108,"newLines":11,"lines":["   ├─ Detects variant requests (\"give me 2 versions\")","   ├─ Decomposes into structured tickets with dependency graph","   ├─ If variants: duplicates full dependency chain per variant with independent IDs","-  └─ Writes tickets to request_queue/ as MD files (status: Needs Research)","+  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)","   │","   ▼"," Orchestrator (pure TypeScript, continuous loop)","-  ├─ Reads request_queue/, topological sort on depends_on","+  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on","   ├─ Dispatches eligible tasks to Workers (up to N parallel)","   ├─ On completion: parses WORK_RESULT, writes to MD","   ├─ Merge: only for terminal tickets (no downstream group deps)"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"adf20436-491c-4371-bf99-f2a031a2f573"}
{"parentUuid":"3c36886f-3631-4222-b910-2408bde0e586","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01EP4SMfJVmdZBC2ikmWEgD1","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 5: Issue #5 — Replace Writing Tickets section (remove TODO, add FR structure)**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":513,"cache_read_input_tokens":78898,"cache_creation":{"ephemeral_5m_input_tokens":513,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nXyyh5FeK75fQiG39u","type":"assistant","uuid":"60b59a11-c4a2-4c62-b6ce-707b850b6106","timestamp":"2026-02-14T10:14:55.443Z"}
{"parentUuid":"60b59a11-c4a2-4c62-b6ce-707b850b6106","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01EP4SMfJVmdZBC2ikmWEgD1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014WmiQYxSi5BLU9PU1MRADY","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"### Writing Tickets\n\n<!-- I need 2 IDs here, one to track the feature requests from the user, the other to track the tickets for the implementation; for ease of implementation, also create a dir \"feature_requests_id\" to store the feature request. If a feature request has variants requsted by the user, create a separate directory to store each \"group\" of tickets per variant -->\nAfter the spec is complete, writes each ticket as an MD file to `request_queue/`:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `request_queue/` files to find the current max `AGI-{n}` ID (reuses logic from `SandboxQueueProcessor.loadTasksFromQueue()`). New tickets start from `max + 1`.","new_string":"### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":513,"cache_read_input_tokens":78898,"cache_creation":{"ephemeral_5m_input_tokens":513,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nXyyh5FeK75fQiG39u","type":"assistant","uuid":"2cfb557e-e7e2-49b3-85f4-3514758c3523","timestamp":"2026-02-14T10:15:15.686Z"}
{"parentUuid":"2cfb557e-e7e2-49b3-85f4-3514758c3523","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_014WmiQYxSi5BLU9PU1MRADY","parentToolUseID":"toolu_014WmiQYxSi5BLU9PU1MRADY","uuid":"326d4d64-8ae1-4f14-9807-36b823b82413","timestamp":"2026-02-14T10:15:15.688Z"}
{"parentUuid":"326d4d64-8ae1-4f14-9807-36b823b82413","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_014WmiQYxSi5BLU9PU1MRADY","toolUseID":"toolu_014WmiQYxSi5BLU9PU1MRADY","timestamp":"2026-02-14T10:15:15.726Z","uuid":"4761513c-7b3a-4508-b59e-438a174f54a2"}
{"parentUuid":"4761513c-7b3a-4508-b59e-438a174f54a2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_014WmiQYxSi5BLU9PU1MRADY","toolUseID":"toolu_014WmiQYxSi5BLU9PU1MRADY","timestamp":"2026-02-14T10:15:15.726Z","uuid":"ad22d704-1d37-4860-b346-8787b73831e9"}
{"parentUuid":"2cfb557e-e7e2-49b3-85f4-3514758c3523","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014WmiQYxSi5BLU9PU1MRADY","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"670b7735-2e00-444b-88c6-d4f62846953a","timestamp":"2026-02-14T10:15:15.725Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"### Writing Tickets\n\n<!-- I need 2 IDs here, one to track the feature requests from the user, the other to track the tickets for the implementation; for ease of implementation, also create a dir \"feature_requests_id\" to store the feature request. If a feature request has variants requsted by the user, create a separate directory to store each \"group\" of tickets per variant -->\nAfter the spec is complete, writes each ticket as an MD file to `request_queue/`:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `request_queue/` files to find the current max `AGI-{n}` ID (reuses logic from `SandboxQueueProcessor.loadTasksFromQueue()`). New tickets start from `max + 1`.","newString":"### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\n<!-- I need 2 IDs here, one to track the feature requests from the user, the other to track the tickets for the implementation; for ease of implementation, also create a dir \"feature_requests_id\" to store the feature request. If a feature request has variants requsted by the user, create a separate directory to store each \"group\" of tickets per variant -->\nAfter the spec is complete, writes each ticket as an MD file to `request_queue/`:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `request_queue/` files to find the current max `AGI-{n}` ID (reuses logic from `SandboxQueueProcessor.loadTasksFromQueue()`). New tickets start from `max + 1`.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses\n    const all = await this.loadAllTasks();                // every status\n    const eligible = this.filterEligible(actionable, all, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(actionableTasks, allTasks, active)` — Dependency + Stage Resolution\n\n**Important**: Dependency checks must run against **all tasks** (every status), not just the actionable ones. Otherwise, a dependency in `Research In Progress` (not a `Needs *` status, not in the in-memory `active` map after a restart) would be invisible and incorrectly treated as satisfied.\n\n```typescript\nprivate filterEligible(\n  actionableTasks: TaskRequest[],\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return actionableTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses only\nconst all = await this.loadAllTasks();                 // every status\nconst eligible = this.filterEligible(actionable, all, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot\n8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":255,"oldLines":12,"newStart":255,"newLines":52,"lines":[" "," ### Writing Tickets"," ","-<!-- I need 2 IDs here, one to track the feature requests from the user, the other to track the tickets for the implementation; for ease of implementation, also create a dir \"feature_requests_id\" to store the feature request. If a feature request has variants requsted by the user, create a separate directory to store each \"group\" of tickets per variant -->","-After the spec is complete, writes each ticket as an MD file to `request_queue/`:","+The Spec Agent uses two ID schemes:"," ","+- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.","+- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.","+","+After the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:","+","+```","+feature_requests/","+  FR-1/","+    request.md              # Original user request + clarification Q&A","+    dashboard-v1/           # Variant group subdirectory","+      AGI-5.md","+      AGI-6.md","+      AGI-7.md","+    dashboard-v2/           # Variant group subdirectory","+      AGI-8.md","+      AGI-9.md","+      AGI-10.md","+  FR-2/","+    request.md","+    AGI-11.md               # No group → lives directly in FR dir","+```","+","+**`request.md`** stores the original request and clarification history:","+"," ```markdown"," ---","+id: FR-1","+created: 2026-02-14T12:00:00Z","+---","+","+## Original Request","+Build a dashboard with auth, give me 2 versions to compare","+","+## Clarifications","+Q: What auth provider should be used?","+A: JWT with our existing user table","+```","+","+**Ticket MD files** use YAML frontmatter:","+","+```markdown","+---"," id: AGI-8","+feature_request: FR-1"," title: Add auth middleware"," description: >-","   Create Express middleware that validates JWT tokens on protected routes."]},{"oldStart":279,"oldLines":7,"newStart":319,"newLines":7,"lines":[" "," ### Integration with Existing ID Scheme"," ","-Reads existing `request_queue/` files to find the current max `AGI-{n}` ID (reuses logic from `SandboxQueueProcessor.loadTasksFromQueue()`). New tickets start from `max + 1`.","+Reads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets."," "," ---"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"2cfb557e-e7e2-49b3-85f4-3514758c3523"}
{"parentUuid":"670b7735-2e00-444b-88c6-d4f62846953a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_014AMvBWNduYTN8793qD4h8m","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 6: Issue #1 — Replace filterEligible section with Version B (2-param)**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1150,"cache_read_input_tokens":79411,"cache_creation":{"ephemeral_5m_input_tokens":1150,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nZfcSxyCmLKw9EjE2z","type":"assistant","uuid":"74a307df-78f5-4e69-9e11-e52d5aa8d3ca","timestamp":"2026-02-14T10:15:18.446Z"}
{"parentUuid":"74a307df-78f5-4e69-9e11-e52d5aa8d3ca","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_014AMvBWNduYTN8793qD4h8m","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TS5coBpcQ2e6zn7F9G2hW5","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"### `filterEligible(actionableTasks, allTasks, active)` — Dependency + Stage Resolution\n\n**Important**: Dependency checks must run against **all tasks** (every status), not just the actionable ones. Otherwise, a dependency in `Research In Progress` (not a `Needs *` status, not in the in-memory `active` map after a restart) would be invisible and incorrectly treated as satisfied.\n\n```typescript\nprivate filterEligible(\n  actionableTasks: TaskRequest[],\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return actionableTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses only\nconst all = await this.loadAllTasks();                 // every status\nconst eligible = this.filterEligible(actionable, all, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.","new_string":"### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1150,"cache_read_input_tokens":79411,"cache_creation":{"ephemeral_5m_input_tokens":1150,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nZfcSxyCmLKw9EjE2z","type":"assistant","uuid":"2828a7c5-f56c-4f24-bd8e-fa1b1bc97d4b","timestamp":"2026-02-14T10:15:36.053Z"}
{"parentUuid":"2828a7c5-f56c-4f24-bd8e-fa1b1bc97d4b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01TS5coBpcQ2e6zn7F9G2hW5","parentToolUseID":"toolu_01TS5coBpcQ2e6zn7F9G2hW5","uuid":"2996ebe5-929f-4b35-bb32-c5702cf57170","timestamp":"2026-02-14T10:15:36.056Z"}
{"parentUuid":"2996ebe5-929f-4b35-bb32-c5702cf57170","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01TS5coBpcQ2e6zn7F9G2hW5","toolUseID":"toolu_01TS5coBpcQ2e6zn7F9G2hW5","timestamp":"2026-02-14T10:15:36.104Z","uuid":"d6c6a2c4-cf37-4020-9215-3eace57e6760"}
{"parentUuid":"d6c6a2c4-cf37-4020-9215-3eace57e6760","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01TS5coBpcQ2e6zn7F9G2hW5","toolUseID":"toolu_01TS5coBpcQ2e6zn7F9G2hW5","timestamp":"2026-02-14T10:15:36.104Z","uuid":"be63b2e3-629e-4470-9ffe-3eda84d28a4c"}
{"parentUuid":"2828a7c5-f56c-4f24-bd8e-fa1b1bc97d4b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TS5coBpcQ2e6zn7F9G2hW5","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"ce0cb71c-5928-4d45-b418-24bb1e234ca2","timestamp":"2026-02-14T10:15:36.103Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"### `filterEligible(actionableTasks, allTasks, active)` — Dependency + Stage Resolution\n\n**Important**: Dependency checks must run against **all tasks** (every status), not just the actionable ones. Otherwise, a dependency in `Research In Progress` (not a `Needs *` status, not in the in-memory `active` map after a restart) would be invisible and incorrectly treated as satisfied.\n\n```typescript\nprivate filterEligible(\n  actionableTasks: TaskRequest[],\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return actionableTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses only\nconst all = await this.loadAllTasks();                 // every status\nconst eligible = this.filterEligible(actionable, all, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.","newString":"### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses\n    const all = await this.loadAllTasks();                // every status\n    const eligible = this.filterEligible(actionable, all, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(actionableTasks, allTasks, active)` — Dependency + Stage Resolution\n\n**Important**: Dependency checks must run against **all tasks** (every status), not just the actionable ones. Otherwise, a dependency in `Research In Progress` (not a `Needs *` status, not in the in-memory `active` map after a restart) would be invisible and incorrectly treated as satisfied.\n\n```typescript\nprivate filterEligible(\n  actionableTasks: TaskRequest[],\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return actionableTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses only\nconst all = await this.loadAllTasks();                 // every status\nconst eligible = this.filterEligible(actionable, all, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot\n8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":444,"oldLines":18,"newStart":444,"newLines":18,"lines":[" "," > **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred."," ","-### `filterEligible(actionableTasks, allTasks, active)` — Dependency + Stage Resolution","+### `filterEligible(allTasks, active)` — Dependency + Stage Resolution"," ","-**Important**: Dependency checks must run against **all tasks** (every status), not just the actionable ones. Otherwise, a dependency in `Research In Progress` (not a `Needs *` status, not in the in-memory `active` map after a restart) would be invisible and incorrectly treated as satisfied.","+Takes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart."," "," ```typescript"," private filterEligible(","-  actionableTasks: TaskRequest[],","   allTasks: TaskRequest[],","   active: Map<string, Promise<void>>"," ): TaskRequest[] {","-  return actionableTasks.filter(task => {","+  return allTasks.filter(task => {","     if (active.has(task.id)) return false;","+    if (!this.isActionable(task)) return false;","     return task.dependsOn.every(depId => {","       if (active.has(depId)) return false;       // dep running in this process → wait","       const dep = allTasks.find(t => t.id === depId);"]},{"oldStart":469,"oldLines":9,"newStart":469,"newLines":8,"lines":[" The `processQueue` loop calls this as:"," "," ```typescript","-const actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses only","-const all = await this.loadAllTasks();                 // every status","-const eligible = this.filterEligible(actionable, all, active);","+const allTasks = await this.loadAllTasks();  // every status","+const eligible = this.filterEligible(allTasks, active);"," ```"," "," Four states a dependency can be in:"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"2828a7c5-f56c-4f24-bd8e-fa1b1bc97d4b"}
{"parentUuid":"ce0cb71c-5928-4d45-b418-24bb1e234ca2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01Vf2LHY9YfAVfMLCU7BDscu","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 7: Issue #1 — Update processQueue to use single loader**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":81859,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":81859,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nbAiwKoxL4fuDVpAwc","type":"assistant","uuid":"e6ef404a-8f7a-4b1d-aa52-f6c0c58b373f","timestamp":"2026-02-14T10:15:39.099Z"}
{"parentUuid":"e6ef404a-8f7a-4b1d-aa52-f6c0c58b373f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01Vf2LHY9YfAVfMLCU7BDscu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0183FVFbvLhA499PUkKib6i8","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses\n    const all = await this.loadAllTasks();                // every status\n    const eligible = this.filterEligible(actionable, all, active);","new_string":"  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":81859,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":81859,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nbAiwKoxL4fuDVpAwc","type":"assistant","uuid":"45a7b3a9-3e15-48df-89c0-60e0976ae92f","timestamp":"2026-02-14T10:15:41.400Z"}
{"parentUuid":"45a7b3a9-3e15-48df-89c0-60e0976ae92f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_0183FVFbvLhA499PUkKib6i8","parentToolUseID":"toolu_0183FVFbvLhA499PUkKib6i8","uuid":"a852036f-1766-49ad-beff-f733e0dee5dd","timestamp":"2026-02-14T10:15:41.403Z"}
{"parentUuid":"a852036f-1766-49ad-beff-f733e0dee5dd","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_0183FVFbvLhA499PUkKib6i8","toolUseID":"toolu_0183FVFbvLhA499PUkKib6i8","timestamp":"2026-02-14T10:15:41.450Z","uuid":"d8990a99-10cc-4d8d-96e1-1d720de8c645"}
{"parentUuid":"d8990a99-10cc-4d8d-96e1-1d720de8c645","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_0183FVFbvLhA499PUkKib6i8","toolUseID":"toolu_0183FVFbvLhA499PUkKib6i8","timestamp":"2026-02-14T10:15:41.450Z","uuid":"900f27b4-8cd4-4430-8412-fe90f7e8a059"}
{"parentUuid":"45a7b3a9-3e15-48df-89c0-60e0976ae92f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0183FVFbvLhA499PUkKib6i8","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"f8322862-3023-48a8-b267-ecc59e0c8e35","timestamp":"2026-02-14T10:15:41.449Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses\n    const all = await this.loadAllTasks();                // every status\n    const eligible = this.filterEligible(actionable, all, active);","newString":"  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses\n    const all = await this.loadAllTasks();                // every status\n    const eligible = this.filterEligible(actionable, all, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot\n8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":363,"oldLines":9,"newStart":363,"newLines":8,"lines":["   const active = new Map<string, Promise<void>>();"," ","   while (this.maxIterations === 0 || iteration < this.maxIterations) {","-    const actionable = await this.loadActionableTasks();  // \"Needs *\" stage statuses","-    const all = await this.loadAllTasks();                // every status","-    const eligible = this.filterEligible(actionable, all, active);","+    const allTasks = await this.loadAllTasks();  // every status","+    const eligible = this.filterEligible(allTasks, active);"," ","     if (eligible.length === 0 && active.size === 0) {","       console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"45a7b3a9-3e15-48df-89c0-60e0976ae92f"}
{"parentUuid":"f8322862-3023-48a8-b267-ecc59e0c8e35","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_012Ybu4GMatdFke1iQGRvatz","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 8: Issue #2 — Add NeedsOneshot to enum**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":340,"cache_read_input_tokens":81859,"cache_creation":{"ephemeral_5m_input_tokens":340,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nbZdq9zQ1a4tnAAtn2","type":"assistant","uuid":"af4c7505-8797-4ddf-9d71-bc713ab53210","timestamp":"2026-02-14T10:15:43.945Z"}
{"parentUuid":"af4c7505-8797-4ddf-9d71-bc713ab53210","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_012Ybu4GMatdFke1iQGRvatz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KYjt8v17jpEtkb9dVNsvte","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"  // Stage: Oneshot (fast-track, decided during research)\n  OneshotInProgress    = \"Oneshot In Progress\",","new_string":"  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\","},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":340,"cache_read_input_tokens":81859,"output_tokens":234,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":340},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7nbZdq9zQ1a4tnAAtn2","type":"assistant","uuid":"d890e4ea-03ba-40eb-9100-de1e3a297a9d","timestamp":"2026-02-14T10:15:45.962Z"}
{"parentUuid":"d890e4ea-03ba-40eb-9100-de1e3a297a9d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01KYjt8v17jpEtkb9dVNsvte","parentToolUseID":"toolu_01KYjt8v17jpEtkb9dVNsvte","uuid":"e656c245-2bb7-4f81-a999-5a614b58bb1f","timestamp":"2026-02-14T10:15:45.966Z"}
{"parentUuid":"e656c245-2bb7-4f81-a999-5a614b58bb1f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01KYjt8v17jpEtkb9dVNsvte","toolUseID":"toolu_01KYjt8v17jpEtkb9dVNsvte","timestamp":"2026-02-14T10:15:46.028Z","uuid":"f5ae0c8c-fcc5-49b0-9af5-d39d6330948a"}
{"parentUuid":"f5ae0c8c-fcc5-49b0-9af5-d39d6330948a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01KYjt8v17jpEtkb9dVNsvte","toolUseID":"toolu_01KYjt8v17jpEtkb9dVNsvte","timestamp":"2026-02-14T10:15:46.028Z","uuid":"1964ff5e-d06f-4905-9288-2238fc722eee"}
{"parentUuid":"d890e4ea-03ba-40eb-9100-de1e3a297a9d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KYjt8v17jpEtkb9dVNsvte","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"2deabfd7-c913-4dbb-a726-098ca0cd9ebe","timestamp":"2026-02-14T10:15:46.027Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"  // Stage: Oneshot (fast-track, decided during research)\n  OneshotInProgress    = \"Oneshot In Progress\",","newString":"  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot\n8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":652,"oldLines":6,"newStart":652,"newLines":7,"lines":["   ValidateInProgress   = \"Validate In Progress\","," ","   // Stage: Oneshot (fast-track, decided during research)","+  NeedsOneshot         = \"Needs Oneshot\",","   OneshotInProgress    = \"Oneshot In Progress\","," ","   // Terminal"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"d890e4ea-03ba-40eb-9100-de1e3a297a9d"}
{"parentUuid":"2deabfd7-c913-4dbb-a726-098ca0cd9ebe","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01ETLFQ4qnxi2PqJboAQ9jd6","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 9: Issue #2 — Add NeedsOneshot to stagePromptMap**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":279,"cache_read_input_tokens":82199,"cache_creation":{"ephemeral_5m_input_tokens":279,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nbuFYXhVk6RmNFqfgd","type":"assistant","uuid":"0190803d-4c28-4d06-8f1d-0ada3a29713d","timestamp":"2026-02-14T10:15:48.348Z"}
{"parentUuid":"0190803d-4c28-4d06-8f1d-0ada3a29713d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01ETLFQ4qnxi2PqJboAQ9jd6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PVk6egaaQgTJL2xxgj81YA","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"private stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n};","new_string":"private stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":279,"cache_read_input_tokens":82199,"cache_creation":{"ephemeral_5m_input_tokens":279,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nbuFYXhVk6RmNFqfgd","type":"assistant","uuid":"77be29e3-ec78-4553-b1dc-7e4b03622b86","timestamp":"2026-02-14T10:15:51.475Z"}
{"parentUuid":"77be29e3-ec78-4553-b1dc-7e4b03622b86","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01PVk6egaaQgTJL2xxgj81YA","parentToolUseID":"toolu_01PVk6egaaQgTJL2xxgj81YA","uuid":"98573bbf-b879-4b73-8f80-339e3b45034d","timestamp":"2026-02-14T10:15:51.477Z"}
{"parentUuid":"98573bbf-b879-4b73-8f80-339e3b45034d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01PVk6egaaQgTJL2xxgj81YA","toolUseID":"toolu_01PVk6egaaQgTJL2xxgj81YA","timestamp":"2026-02-14T10:15:51.526Z","uuid":"525c4fb6-a7d6-4d46-a6a2-8ae751813132"}
{"parentUuid":"525c4fb6-a7d6-4d46-a6a2-8ae751813132","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01PVk6egaaQgTJL2xxgj81YA","toolUseID":"toolu_01PVk6egaaQgTJL2xxgj81YA","timestamp":"2026-02-14T10:15:51.526Z","uuid":"8f8eb230-74fa-402a-9369-b2996f4ab6cc"}
{"parentUuid":"77be29e3-ec78-4553-b1dc-7e4b03622b86","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PVk6egaaQgTJL2xxgj81YA","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"b9a902e5-ac8a-4a65-986a-944934cfecb4","timestamp":"2026-02-14T10:15:51.525Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"private stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n};","newString":"private stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot\n8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":703,"oldLines":6,"newStart":703,"newLines":7,"lines":["   \"Needs Plan\":            \"agent2-worker-plan.md\",","   \"Needs Implement\":       \"agent2-worker-implement.md\",","   \"Needs Validate\":        \"agent2-worker-validate.md\",","+  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\","," };"," "," async dispatchWorker(task: TaskRequest): Promise<void> {"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"77be29e3-ec78-4553-b1dc-7e4b03622b86"}
{"parentUuid":"b9a902e5-ac8a-4a65-986a-944934cfecb4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01CD6z4HGrSXe3Z3X2mZTmJs","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 10: Issue #2 — Update transition diagram for Oneshot**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":585,"cache_read_input_tokens":82478,"cache_creation":{"ephemeral_5m_input_tokens":585,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7ncJeDVJ83vry9HMnf5","type":"assistant","uuid":"b041677c-e1c4-428e-8cbb-f5e1079ea580","timestamp":"2026-02-14T10:15:53.688Z"}
{"parentUuid":"b041677c-e1c4-428e-8cbb-f5e1079ea580","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01CD6z4HGrSXe3Z3X2mZTmJs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01W18P7jKgWFsrUXzfJMvsfY","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge","new_string":"  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":585,"cache_read_input_tokens":82478,"cache_creation":{"ephemeral_5m_input_tokens":585,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7ncJeDVJ83vry9HMnf5","type":"assistant","uuid":"771d87ce-3ec5-4c1a-aa6e-e541271f99f0","timestamp":"2026-02-14T10:15:55.614Z"}
{"parentUuid":"771d87ce-3ec5-4c1a-aa6e-e541271f99f0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01W18P7jKgWFsrUXzfJMvsfY","parentToolUseID":"toolu_01W18P7jKgWFsrUXzfJMvsfY","uuid":"b2be2672-0fe8-4345-9e77-78085f9ea2fe","timestamp":"2026-02-14T10:15:55.617Z"}
{"parentUuid":"b2be2672-0fe8-4345-9e77-78085f9ea2fe","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01W18P7jKgWFsrUXzfJMvsfY","toolUseID":"toolu_01W18P7jKgWFsrUXzfJMvsfY","timestamp":"2026-02-14T10:15:55.667Z","uuid":"db506153-e193-4fc6-8a25-54e582c3255b"}
{"parentUuid":"db506153-e193-4fc6-8a25-54e582c3255b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01W18P7jKgWFsrUXzfJMvsfY","toolUseID":"toolu_01W18P7jKgWFsrUXzfJMvsfY","timestamp":"2026-02-14T10:15:55.667Z","uuid":"7be89063-8275-4ea8-b2c6-0412eea245b0"}
{"parentUuid":"771d87ce-3ec5-4c1a-aa6e-e541271f99f0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01W18P7jKgWFsrUXzfJMvsfY","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"f0b4414c-73f8-4048-95e6-11797ad9f173","timestamp":"2026-02-14T10:15:55.666Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge","newString":"  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot\n8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":674,"oldLines":7,"newStart":674,"newLines":7,"lines":["   ▼"," Needs Research ──→ Research In Progress","   │","-  ├─ SIMPLE ──→ Oneshot In Progress ──→ Done / Awaiting Merge","+  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge","   │","   └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan","                │"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"771d87ce-3ec5-4c1a-aa6e-e541271f99f0"}
{"parentUuid":"f0b4414c-73f8-4048-95e6-11797ad9f173","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01NG39oY68ooinRUXdS6Lw8V","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 11: Issue #2 — Update research stage description to output \"Needs Oneshot\"**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":261,"cache_read_input_tokens":83063,"cache_creation":{"ephemeral_5m_input_tokens":261,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nccM5QgX8RnT8STDkR","type":"assistant","uuid":"3ba33781-6fa9-4ff5-8368-705ae7f59bd9","timestamp":"2026-02-14T10:15:57.901Z"}
{"parentUuid":"3ba33781-6fa9-4ff5-8368-705ae7f59bd9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01NG39oY68ooinRUXdS6Lw8V","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Y688EpKxDeqrPj4DNwVi2b","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot","new_string":"7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":261,"cache_read_input_tokens":83063,"cache_creation":{"ephemeral_5m_input_tokens":261,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nccM5QgX8RnT8STDkR","type":"assistant","uuid":"56982aae-1ef1-4cfa-bb86-e477ad9717ef","timestamp":"2026-02-14T10:16:01.704Z"}
{"parentUuid":"56982aae-1ef1-4cfa-bb86-e477ad9717ef","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01Y688EpKxDeqrPj4DNwVi2b","parentToolUseID":"toolu_01Y688EpKxDeqrPj4DNwVi2b","uuid":"9e96161a-50c4-437b-841d-14869d3fbb2a","timestamp":"2026-02-14T10:16:01.708Z"}
{"parentUuid":"9e96161a-50c4-437b-841d-14869d3fbb2a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01Y688EpKxDeqrPj4DNwVi2b","toolUseID":"toolu_01Y688EpKxDeqrPj4DNwVi2b","timestamp":"2026-02-14T10:16:01.759Z","uuid":"d06b31d7-07b3-408e-95b7-f7d5017a131b"}
{"parentUuid":"d06b31d7-07b3-408e-95b7-f7d5017a131b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01Y688EpKxDeqrPj4DNwVi2b","toolUseID":"toolu_01Y688EpKxDeqrPj4DNwVi2b","timestamp":"2026-02-14T10:16:01.759Z","uuid":"68d4cae8-c8cb-48c7-917a-6f9ef23106fb"}
{"parentUuid":"56982aae-1ef1-4cfa-bb86-e477ad9717ef","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y688EpKxDeqrPj4DNwVi2b","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"415430b3-8927-4570-bdb7-ab4dd0376199","timestamp":"2026-02-14T10:16:01.758Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot","newString":"7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot\n8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":521,"oldLines":7,"newStart":521,"newLines":7,"lines":[" 4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)"," 5. **`variant_hint`** included in worker prompt when present"," 6. Returns parsed WORK_RESULT including `nextStatus` field","-7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or transitions to oneshot","+7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)"," 8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox."," "," ### `writeResults(task, result)` — Update MD File"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"56982aae-1ef1-4cfa-bb86-e477ad9717ef"}
{"parentUuid":"415430b3-8927-4570-bdb7-ab4dd0376199","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01JNZ43JBQTxqHGzFZ6EE3Ni","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 12: Issue #3 — Remove line about local stages, all stages run in sandboxes**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":291,"cache_read_input_tokens":83324,"cache_creation":{"ephemeral_5m_input_tokens":291,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nd4UTCgA2rQXvSRGe6","type":"assistant","uuid":"80f1bd66-312f-404b-a402-1ddc158b91de","timestamp":"2026-02-14T10:16:04.282Z"}
{"parentUuid":"80f1bd66-312f-404b-a402-1ddc158b91de","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01JNZ43JBQTxqHGzFZ6EE3Ni","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LiFgJfYtdDwNwgJC9QGWHw","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.","new_string":"8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":291,"cache_read_input_tokens":83324,"output_tokens":264,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":291},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7nd4UTCgA2rQXvSRGe6","type":"assistant","uuid":"c0230880-9a6d-4df1-985b-4f4c03fa28b2","timestamp":"2026-02-14T10:16:08.185Z"}
{"parentUuid":"c0230880-9a6d-4df1-985b-4f4c03fa28b2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01LiFgJfYtdDwNwgJC9QGWHw","parentToolUseID":"toolu_01LiFgJfYtdDwNwgJC9QGWHw","uuid":"496a1530-7452-43e4-a0a1-f9bd072c8058","timestamp":"2026-02-14T10:16:08.188Z"}
{"parentUuid":"496a1530-7452-43e4-a0a1-f9bd072c8058","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01LiFgJfYtdDwNwgJC9QGWHw","toolUseID":"toolu_01LiFgJfYtdDwNwgJC9QGWHw","timestamp":"2026-02-14T10:16:08.246Z","uuid":"643b3bfc-ae40-4f24-9129-6c30aea4f0bf"}
{"parentUuid":"643b3bfc-ae40-4f24-9129-6c30aea4f0bf","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01LiFgJfYtdDwNwgJC9QGWHw","toolUseID":"toolu_01LiFgJfYtdDwNwgJC9QGWHw","timestamp":"2026-02-14T10:16:08.246Z","uuid":"89644750-4918-4f9c-b6fc-115e2d4de2ef"}
{"parentUuid":"c0230880-9a6d-4df1-985b-4f4c03fa28b2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LiFgJfYtdDwNwgJC9QGWHw","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"6f4a0b1e-6a04-4a6f-892a-5dda7e6afc04","timestamp":"2026-02-14T10:16:08.245Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.","newString":"8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":522,"oldLines":7,"newStart":522,"newLines":7,"lines":[" 5. **`variant_hint`** included in worker prompt when present"," 6. Returns parsed WORK_RESULT including `nextStatus` field"," 7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)","-8. **Sandboxes**: Research/Spec/Plan stages can run without a sandbox (local Claude). Implement/Validate/Oneshot stages require a Daytona sandbox.","+8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner."," "," ### `writeResults(task, result)` — Update MD File"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"c0230880-9a6d-4df1-985b-4f4c03fa28b2"}
{"parentUuid":"6f4a0b1e-6a04-4a6f-892a-5dda7e6afc04","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01JnhtyF2P9poG6ReRBSWnZM","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 13: Issue #1 — Replace \"Two Task Loaders\" section with single loader**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":309,"cache_read_input_tokens":83615,"cache_creation":{"ephemeral_5m_input_tokens":309,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7ndYCa9YQYZXERR7MwV","type":"assistant","uuid":"6bece58c-3286-41cd-b70f-114fe350c521","timestamp":"2026-02-14T10:16:10.813Z"}
{"parentUuid":"6bece58c-3286-41cd-b70f-114fe350c521","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01JnhtyF2P9poG6ReRBSWnZM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Fp7HmEbaH46AgWNdgk1HFL","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.","new_string":"### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":309,"cache_read_input_tokens":83615,"cache_creation":{"ephemeral_5m_input_tokens":309,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7ndYCa9YQYZXERR7MwV","type":"assistant","uuid":"20514bd7-8f43-4cd7-8ca0-91b5bdeec28d","timestamp":"2026-02-14T10:16:18.938Z"}
{"parentUuid":"20514bd7-8f43-4cd7-8ca0-91b5bdeec28d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01Fp7HmEbaH46AgWNdgk1HFL","parentToolUseID":"toolu_01Fp7HmEbaH46AgWNdgk1HFL","uuid":"7572f0eb-62cb-41f8-acad-4864c9c7a6fb","timestamp":"2026-02-14T10:16:18.941Z"}
{"parentUuid":"7572f0eb-62cb-41f8-acad-4864c9c7a6fb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01Fp7HmEbaH46AgWNdgk1HFL","toolUseID":"toolu_01Fp7HmEbaH46AgWNdgk1HFL","timestamp":"2026-02-14T10:16:19.000Z","uuid":"fa854e13-72f5-4e26-a630-31c63177c920"}
{"parentUuid":"fa854e13-72f5-4e26-a630-31c63177c920","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01Fp7HmEbaH46AgWNdgk1HFL","toolUseID":"toolu_01Fp7HmEbaH46AgWNdgk1HFL","timestamp":"2026-02-14T10:16:19.000Z","uuid":"7bfde84c-199d-41df-81c3-2c27a8f4c81e"}
{"parentUuid":"20514bd7-8f43-4cd7-8ca0-91b5bdeec28d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Fp7HmEbaH46AgWNdgk1HFL","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"b077e6b9-7db6-4433-a3a3-3f56cf3e10da","timestamp":"2026-02-14T10:16:18.999Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.","newString":"### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `filterEligible` Update\n\nThe previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:\n\n```typescript\nprivate filterEligible(\n  tasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return tasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;\n      const dep = tasks.find(t => t.id === depId);\n      return !dep || dep.status === \"Done\";\n    });\n  });\n}\n```\n\n### Two Task Loaders\n\n- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.\n- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).\n\nBoth are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":771,"oldLines":34,"newStart":771,"newLines":10,"lines":[" "," Tickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention."," ","-### `filterEligible` Update","+### Single Task Loader"," ","-The previous `filterEligible` only looked for `Backlog` tasks. Now it looks for any `Needs *` status (excluding intervention statuses) where dependencies are satisfied:","+**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally."," ","-```typescript","-private filterEligible(","-  tasks: TaskRequest[],","-  active: Map<string, Promise<void>>","-): TaskRequest[] {","-  return tasks.filter(task => {","-    if (active.has(task.id)) return false;","-    if (!this.isActionable(task)) return false;","-    return task.dependsOn.every(depId => {","-      if (active.has(depId)) return false;","-      const dep = tasks.find(t => t.id === depId);","-      return !dep || dep.status === \"Done\";","-    });","-  });","-}","-```","-","-### Two Task Loaders","-","-- **`loadActionableTasks()`** — Returns tasks in `Needs *` stage statuses (excluding intervention statuses). These are candidates for dispatch.","-- **`loadAllTasks()`** — Returns tasks in **every** status. Used by `filterEligible()` for dependency checks (must see `In Progress` and intervention statuses) and by `isTerminal()` (must see non-Done dependents).","-","-Both are needed because the dispatch list and the dependency check have different scope requirements. Using only `loadActionableTasks` for dependency checks would miss `In Progress` and intervention statuses, causing premature dispatch after process restart.","-"," ## Changes Required for Variant Support (vs. previous plan)"," "," Summary of what the variant group feature specifically adds or changes:"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"20514bd7-8f43-4cd7-8ca0-91b5bdeec28d"}
{"parentUuid":"b077e6b9-7db6-4433-a3a3-3f56cf3e10da","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01EjLpMMJEQsfDnFAHYn3XTS","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 14: Issue #6 — Update Phase 5 test-writer scope**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":640,"cache_read_input_tokens":83924,"cache_creation":{"ephemeral_5m_input_tokens":640,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7neLEkzkqqJoBjPoGhJ","type":"assistant","uuid":"73cece88-bb8d-4f74-912a-d1ea9ef1b489","timestamp":"2026-02-14T10:16:21.475Z"}
{"parentUuid":"73cece88-bb8d-4f74-912a-d1ea9ef1b489","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01EjLpMMJEQsfDnFAHYn3XTS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VwWkPWy5YwAP1nynGoPsBV","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"Every worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.","new_string":"Worker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":640,"cache_read_input_tokens":83924,"cache_creation":{"ephemeral_5m_input_tokens":640,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7neLEkzkqqJoBjPoGhJ","type":"assistant","uuid":"d65e9dfd-23ab-4e3d-a604-11e28fbf440e","timestamp":"2026-02-14T10:16:25.215Z"}
{"parentUuid":"d65e9dfd-23ab-4e3d-a604-11e28fbf440e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01VwWkPWy5YwAP1nynGoPsBV","parentToolUseID":"toolu_01VwWkPWy5YwAP1nynGoPsBV","uuid":"52e7ffb0-0f47-47a5-9321-45e523f19d77","timestamp":"2026-02-14T10:16:25.218Z"}
{"parentUuid":"52e7ffb0-0f47-47a5-9321-45e523f19d77","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01VwWkPWy5YwAP1nynGoPsBV","toolUseID":"toolu_01VwWkPWy5YwAP1nynGoPsBV","timestamp":"2026-02-14T10:16:25.267Z","uuid":"7886af46-06e5-4b0b-93c4-985566c942f4"}
{"parentUuid":"7886af46-06e5-4b0b-93c4-985566c942f4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01VwWkPWy5YwAP1nynGoPsBV","toolUseID":"toolu_01VwWkPWy5YwAP1nynGoPsBV","timestamp":"2026-02-14T10:16:25.267Z","uuid":"ec90c9a6-797f-404f-9d0c-af9ac2cedf36"}
{"parentUuid":"d65e9dfd-23ab-4e3d-a604-11e28fbf440e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VwWkPWy5YwAP1nynGoPsBV","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"222c51ba-106a-490b-ac67-ed28b2a359c4","timestamp":"2026-02-14T10:16:25.266Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"Every worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.","newString":"Worker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nEvery worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":913,"oldLines":7,"newStart":913,"newLines":7,"lines":[" "," ### Purpose"," ","-Every worker execution is followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed.","+Worker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code."," "," ### Two-Tier Testing Strategy"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"d65e9dfd-23ab-4e3d-a604-11e28fbf440e"}
{"parentUuid":"222c51ba-106a-490b-ac67-ed28b2a359c4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_017Vcd3BrqDXBUFtLUNf59aG","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 15: Issue #3/#6 — Update Phase 5 execution flow (rename executeWorker → dispatchStage, clarify scope)**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":463,"cache_read_input_tokens":84564,"cache_creation":{"ephemeral_5m_input_tokens":463,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nenz6V9erESPG7GMLh","type":"assistant","uuid":"737318b0-9b15-46ea-98e3-3cd4acaab22f","timestamp":"2026-02-14T10:16:27.998Z"}
{"parentUuid":"737318b0-9b15-46ea-98e3-3cd4acaab22f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_017Vcd3BrqDXBUFtLUNf59aG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GeSfN4vjgiAgwZ1gXA6RF2","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"The test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```","new_string":"The test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":463,"cache_read_input_tokens":84564,"output_tokens":563,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":463},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7nenz6V9erESPG7GMLh","type":"assistant","uuid":"d447e851-de63-42d2-8e84-67bf5c167a76","timestamp":"2026-02-14T10:16:36.043Z"}
{"parentUuid":"d447e851-de63-42d2-8e84-67bf5c167a76","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01GeSfN4vjgiAgwZ1gXA6RF2","parentToolUseID":"toolu_01GeSfN4vjgiAgwZ1gXA6RF2","uuid":"64105468-88e3-4505-bdce-6a50191a7b5c","timestamp":"2026-02-14T10:16:36.046Z"}
{"parentUuid":"64105468-88e3-4505-bdce-6a50191a7b5c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01GeSfN4vjgiAgwZ1gXA6RF2","toolUseID":"toolu_01GeSfN4vjgiAgwZ1gXA6RF2","timestamp":"2026-02-14T10:16:36.119Z","uuid":"adc5ad4b-4c8d-454f-8fc2-9b7de0f02253"}
{"parentUuid":"adc5ad4b-4c8d-454f-8fc2-9b7de0f02253","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01GeSfN4vjgiAgwZ1gXA6RF2","toolUseID":"toolu_01GeSfN4vjgiAgwZ1gXA6RF2","timestamp":"2026-02-14T10:16:36.119Z","uuid":"35ff76ff-820d-422b-aaa2-bf193d3e8cec"}
{"parentUuid":"d447e851-de63-42d2-8e84-67bf5c167a76","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GeSfN4vjgiAgwZ1gXA6RF2","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"44ed6ac2-8a3c-4e0d-b0a1-0c931e8420f8","timestamp":"2026-02-14T10:16:36.118Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"The test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```","newString":"The test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:\n\n```\nexecuteWorker(task):\n  1. Worker agent implements feature, commits, pushes\n  2. Test-writer agent runs in same sandbox:\n     a. Reads the git diff (all commits on this branch vs main)\n     b. Reads the ticket description + acceptance criteria\n     c. If terminal: also reads all tickets in the group chain for integration context\n     d. Writes test files to tests/\n     e. Runs `npm test` to verify all tests pass\n     f. Commits test files, pushes to same branch\n  3. Return combined WORK_RESULT (implementation + test summary)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":924,"oldLines":19,"newStart":924,"newLines":21,"lines":[" "," ### Execution Flow"," ","-The test-writer runs **inside `executeWorker()`**, after the worker agent finishes but before the sandbox is torn down:","+The test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:"," "," ```","-executeWorker(task):","-  1. Worker agent implements feature, commits, pushes","-  2. Test-writer agent runs in same sandbox:","-     a. Reads the git diff (all commits on this branch vs main)","-     b. Reads the ticket description + acceptance criteria","-     c. If terminal: also reads all tickets in the group chain for integration context","-     d. Writes test files to tests/","-     e. Runs `npm test` to verify all tests pass","-     f. Commits test files, pushes to same branch","-  3. Return combined WORK_RESULT (implementation + test summary)","+dispatchStage(task, stagePrompt):","+  1. Create Daytona sandbox","+  2. Worker agent runs stage prompt, commits, pushes","+  3. If stage is Implement, Oneshot, or Validate:","+     a. Test-writer agent runs in same sandbox","+     b. Reads the git diff (all commits on this branch vs main)","+     c. Reads the ticket description + acceptance criteria","+     d. If terminal: also reads all tickets in the group chain for integration context","+     e. Writes test files to tests/","+     f. Runs `npm test` to verify all tests pass","+     g. Commits test files, pushes to same branch","+  4. Return combined WORK_RESULT (stage output + test summary if applicable)"," ```"," "," ### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"d447e851-de63-42d2-8e84-67bf5c167a76"}
{"parentUuid":"44ed6ac2-8a3c-4e0d-b0a1-0c931e8420f8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_0197Xjz8ft8nH3WrV7q9inGz","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 16: Issue #3 — Update orchestrator integration code in Phase 5**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":608,"cache_read_input_tokens":85027,"cache_creation":{"ephemeral_5m_input_tokens":608,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nfbS6MFet9Axv8YgzZ","type":"assistant","uuid":"5a3ae7da-d867-40c4-bcb0-49561894fcc8","timestamp":"2026-02-14T10:16:38.496Z"}
{"parentUuid":"5a3ae7da-d867-40c4-bcb0-49561894fcc8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_0197Xjz8ft8nH3WrV7q9inGz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YN6kwtBb2j7UZmQ7CshzM7","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```","new_string":"### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":608,"cache_read_input_tokens":85027,"cache_creation":{"ephemeral_5m_input_tokens":608,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nfbS6MFet9Axv8YgzZ","type":"assistant","uuid":"241f2f44-e368-44ff-bf62-0dc547c6e0b7","timestamp":"2026-02-14T10:16:45.143Z"}
{"parentUuid":"241f2f44-e368-44ff-bf62-0dc547c6e0b7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01YN6kwtBb2j7UZmQ7CshzM7","parentToolUseID":"toolu_01YN6kwtBb2j7UZmQ7CshzM7","uuid":"af7825dc-b521-4885-b6a6-fbbb76105af2","timestamp":"2026-02-14T10:16:45.145Z"}
{"parentUuid":"af7825dc-b521-4885-b6a6-fbbb76105af2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01YN6kwtBb2j7UZmQ7CshzM7","toolUseID":"toolu_01YN6kwtBb2j7UZmQ7CshzM7","timestamp":"2026-02-14T10:16:45.194Z","uuid":"2bae9cdb-1a5c-47ec-ac95-328b7e2f62cf"}
{"parentUuid":"2bae9cdb-1a5c-47ec-ac95-328b7e2f62cf","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01YN6kwtBb2j7UZmQ7CshzM7","toolUseID":"toolu_01YN6kwtBb2j7UZmQ7CshzM7","timestamp":"2026-02-14T10:16:45.194Z","uuid":"fb052576-968a-45f3-8311-140e2ad17bba"}
{"parentUuid":"241f2f44-e368-44ff-bf62-0dc547c6e0b7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YN6kwtBb2j7UZmQ7CshzM7","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"875f7764-308b-4530-a30e-33c6ad32bb98","timestamp":"2026-02-14T10:16:45.193Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```","newString":"### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nModify `executeWorker()` to include the test-writer step:\n\n```typescript\nprivate async executeWorker(task: TaskRequest): Promise<WorkerResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Implementation worker\n  const implResult = await this.runWorkerAgent(sandbox, task);\n\n  // Step 2: Test-writer (same sandbox, deterministic)\n  const isTerminal = await this.isTerminal(task);\n  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n\n  return { impl: implResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":984,"oldLines":21,"newStart":984,"newLines":28,"lines":[" "," ### Orchestrator Integration"," ","-Modify `executeWorker()` to include the test-writer step:","+The `dispatchStage()` method conditionally runs the test-writer after code-producing stages:"," "," ```typescript","-private async executeWorker(task: TaskRequest): Promise<WorkerResult> {","+private readonly codeProducingStages = new Set([","+  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",","+]);","+","+private async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {","   const sandbox = await this.createSandbox(task);"," ","-  // Step 1: Implementation worker","-  const implResult = await this.runWorkerAgent(sandbox, task);","+  // Step 1: Run the stage prompt","+  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);"," ","-  // Step 2: Test-writer (same sandbox, deterministic)","-  const isTerminal = await this.isTerminal(task);","-  const testPrompt = this.buildTestWriterPrompt(task, isTerminal);","-  const testResult = await this.runTestWriterAgent(sandbox, testPrompt);","+  // Step 2: Test-writer (same sandbox, only for code-producing stages)","+  let testResult: TestResult | undefined;","+  if (this.codeProducingStages.has(task.status)) {","+    const isTerminal = await this.isTerminal(task);","+    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);","+    testResult = await this.runTestWriterAgent(sandbox, testPrompt);","+  }"," ","-  return { impl: implResult, tests: testResult };","+  return { stage: stageResult, tests: testResult };"," }"," ```"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"241f2f44-e368-44ff-bf62-0dc547c6e0b7"}
{"parentUuid":"875f7764-308b-4530-a30e-33c6ad32bb98","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_012EzPZFWWEGQsDrMktZamZB","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 17: Issue #4 — Update Files table (remove agent1/agent3 prompts, update paths)**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":658,"cache_read_input_tokens":85635,"cache_creation":{"ephemeral_5m_input_tokens":658,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7ngGBzAFNnPBdUPvjZN","type":"assistant","uuid":"ec6949eb-509e-40ad-9222-ab567342f87b","timestamp":"2026-02-14T10:16:48.080Z"}
{"parentUuid":"ec6949eb-509e-40ad-9222-ab567342f87b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_012EzPZFWWEGQsDrMktZamZB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YPFVypsGcL88tGjs1HtEtZ","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |","new_string":"| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":658,"cache_read_input_tokens":85635,"cache_creation":{"ephemeral_5m_input_tokens":658,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7ngGBzAFNnPBdUPvjZN","type":"assistant","uuid":"0632f2a3-046b-4937-be48-cd5c52faf488","timestamp":"2026-02-14T10:17:00.796Z"}
{"parentUuid":"0632f2a3-046b-4937-be48-cd5c52faf488","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01YPFVypsGcL88tGjs1HtEtZ","parentToolUseID":"toolu_01YPFVypsGcL88tGjs1HtEtZ","uuid":"05e7ee4d-9e2a-4aba-ace3-bb0595bd0edb","timestamp":"2026-02-14T10:17:00.799Z"}
{"parentUuid":"05e7ee4d-9e2a-4aba-ace3-bb0595bd0edb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01YPFVypsGcL88tGjs1HtEtZ","toolUseID":"toolu_01YPFVypsGcL88tGjs1HtEtZ","timestamp":"2026-02-14T10:17:00.848Z","uuid":"d386fc52-14b2-4ae6-ad7a-4d8ac0c71a81"}
{"parentUuid":"d386fc52-14b2-4ae6-ad7a-4d8ac0c71a81","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01YPFVypsGcL88tGjs1HtEtZ","toolUseID":"toolu_01YPFVypsGcL88tGjs1HtEtZ","timestamp":"2026-02-14T10:17:00.848Z","uuid":"b079541f-6a51-43cd-bedb-264e3966689e"}
{"parentUuid":"0632f2a3-046b-4937-be48-cd5c52faf488","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YPFVypsGcL88tGjs1HtEtZ","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"d8d6a9e3-629e-46ac-b6ed-5694770346b9","timestamp":"2026-02-14T10:17:00.846Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |","newString":"| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |\n| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":880,"oldLines":12,"newStart":880,"newLines":12,"lines":[" | `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |"," | `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |"," | `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |","-| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadActionableTasks()`, result writing with `nextStatus` parsing |","+| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |"," | `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |"," | `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |"," | `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |","-| `prompts/agent1-linear-reader.md` | **Adapt** — Replace Linear MCP calls with local `request_queue/` file reads |","-| `prompts/agent3-linear-writer.md` | **Adapt** — Replace Linear MCP calls with local MD file updates |","+| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |","+| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |"," | `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |"," "," ---"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"0632f2a3-046b-4937-be48-cd5c52faf488"}
{"parentUuid":"d8d6a9e3-629e-46ac-b6ed-5694770346b9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01ASceDLUavp76hmf5s8aziq","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 18: Issue #1 — Update variant changes table (loadAllTasks row)**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":849,"cache_read_input_tokens":86293,"cache_creation":{"ephemeral_5m_input_tokens":849,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nhRCFaFDiT2z1svGsC","type":"assistant","uuid":"7434eb5d-924a-4bb9-bad9-f1a40baed558","timestamp":"2026-02-14T10:17:03.768Z"}
{"parentUuid":"7434eb5d-924a-4bb9-bad9-f1a40baed558","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01ASceDLUavp76hmf5s8aziq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014vykQykm56P9cwFip8V4CW","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |","new_string":"| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":849,"cache_read_input_tokens":86293,"cache_creation":{"ephemeral_5m_input_tokens":849,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nhRCFaFDiT2z1svGsC","type":"assistant","uuid":"17698397-40e0-4203-9bdc-89be5261446c","timestamp":"2026-02-14T10:17:06.172Z"}
{"parentUuid":"17698397-40e0-4203-9bdc-89be5261446c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_014vykQykm56P9cwFip8V4CW","parentToolUseID":"toolu_014vykQykm56P9cwFip8V4CW","uuid":"df47f0c8-c037-486e-9389-92ad11c9e8f1","timestamp":"2026-02-14T10:17:06.175Z"}
{"parentUuid":"df47f0c8-c037-486e-9389-92ad11c9e8f1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_014vykQykm56P9cwFip8V4CW","toolUseID":"toolu_014vykQykm56P9cwFip8V4CW","timestamp":"2026-02-14T10:17:06.222Z","uuid":"c992bbe2-5b33-4dc1-abe5-05e29ad773cf"}
{"parentUuid":"c992bbe2-5b33-4dc1-abe5-05e29ad773cf","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_014vykQykm56P9cwFip8V4CW","toolUseID":"toolu_014vykQykm56P9cwFip8V4CW","timestamp":"2026-02-14T10:17:06.222Z","uuid":"e95f7341-84b0-40c2-a78b-681dbaedce1b"}
{"parentUuid":"17698397-40e0-4203-9bdc-89be5261446c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014vykQykm56P9cwFip8V4CW","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"d219c721-7db1-4647-b815-c3949ad97921","timestamp":"2026-02-14T10:17:06.221Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |","newString":"| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":792,"oldLines":7,"newStart":792,"newLines":7,"lines":[" | **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |"," | **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |"," | **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |","-| **`loadAllTasks()`** | Only loaded Backlog tasks | Also needs to read all statuses for `isTerminal()` check |","+| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |"," | **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |"," | **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"17698397-40e0-4203-9bdc-89be5261446c"}
{"parentUuid":"d219c721-7db1-4647-b815-c3949ad97921","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_017GTWqciDEz1s1wa8MbsuVu","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 19: Issue #6 — Update verification item for oneshot to use NeedsOneshot**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":292,"cache_read_input_tokens":87142,"cache_creation":{"ephemeral_5m_input_tokens":292,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nhp3BC5TKWmgnXkd8u","type":"assistant","uuid":"54262b3b-72a7-4f5f-8b42-f8a62fb5ce6e","timestamp":"2026-02-14T10:17:08.745Z"}
{"parentUuid":"54262b3b-72a7-4f5f-8b42-f8a62fb5ce6e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_017GTWqciDEz1s1wa8MbsuVu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017A7t7fU2uQmYMzdzM5fPRc","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.","new_string":"6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":292,"cache_read_input_tokens":87142,"cache_creation":{"ephemeral_5m_input_tokens":292,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nhp3BC5TKWmgnXkd8u","type":"assistant","uuid":"c38cdc30-16ec-4d3a-b106-af03278163ad","timestamp":"2026-02-14T10:17:11.033Z"}
{"parentUuid":"c38cdc30-16ec-4d3a-b106-af03278163ad","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_017A7t7fU2uQmYMzdzM5fPRc","parentToolUseID":"toolu_017A7t7fU2uQmYMzdzM5fPRc","uuid":"ae41a8c8-9d1c-4e1a-87e6-761aa15e2f72","timestamp":"2026-02-14T10:17:11.035Z"}
{"parentUuid":"ae41a8c8-9d1c-4e1a-87e6-761aa15e2f72","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_017A7t7fU2uQmYMzdzM5fPRc","toolUseID":"toolu_017A7t7fU2uQmYMzdzM5fPRc","timestamp":"2026-02-14T10:17:11.083Z","uuid":"018831d3-465e-40bb-8684-538c105dce1d"}
{"parentUuid":"018831d3-465e-40bb-8684-538c105dce1d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_017A7t7fU2uQmYMzdzM5fPRc","toolUseID":"toolu_017A7t7fU2uQmYMzdzM5fPRc","timestamp":"2026-02-14T10:17:11.083Z","uuid":"23481741-740c-4809-aff5-ab8eeafb4f95"}
{"parentUuid":"c38cdc30-16ec-4d3a-b106-af03278163ad","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017A7t7fU2uQmYMzdzM5fPRc","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"f3205986-3f76-461d-a23c-853f8de732a4","timestamp":"2026-02-14T10:17:11.082Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.","newString":"6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":897,"oldLines":7,"newStart":897,"newLines":7,"lines":[" 3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`."," 4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`."," 5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.","-6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Oneshot In Progress` → `Done`.","+6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`."," 7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing."," 8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:","    - Chains execute in parallel (AGI-5 and AGI-8 at same time)"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"c38cdc30-16ec-4d3a-b106-af03278163ad"}
{"parentUuid":"f3205986-3f76-461d-a23c-853f8de732a4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01DNCZqbi9Xm7P8BpqJVX1BS","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 20: Issue #3 — Update variant example to note all stages use sandboxes**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":423,"cache_read_input_tokens":87434,"cache_creation":{"ephemeral_5m_input_tokens":423,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7niAtJUkhmsMf92SvMW","type":"assistant","uuid":"adbe8e8a-e87e-4763-8ddd-a96a687f1e17","timestamp":"2026-02-14T10:17:13.563Z"}
{"parentUuid":"adbe8e8a-e87e-4763-8ddd-a96a687f1e17","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01DNCZqbi9Xm7P8BpqJVX1BS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012N2VkXZ3Y7ErUz8kAitAio","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"t=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox","new_string":"t=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":423,"cache_read_input_tokens":87434,"output_tokens":249,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":423},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7niAtJUkhmsMf92SvMW","type":"assistant","uuid":"c84a44e8-ea41-4a48-8537-266ae4dd918c","timestamp":"2026-02-14T10:17:16.487Z"}
{"parentUuid":"c84a44e8-ea41-4a48-8537-266ae4dd918c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_012N2VkXZ3Y7ErUz8kAitAio","parentToolUseID":"toolu_012N2VkXZ3Y7ErUz8kAitAio","uuid":"53a0437a-ab72-4f93-a484-8d153b7e10cc","timestamp":"2026-02-14T10:17:16.490Z"}
{"parentUuid":"53a0437a-ab72-4f93-a484-8d153b7e10cc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_012N2VkXZ3Y7ErUz8kAitAio","toolUseID":"toolu_012N2VkXZ3Y7ErUz8kAitAio","timestamp":"2026-02-14T10:17:16.545Z","uuid":"c7535a6e-226f-4115-bac2-9e07615eb059"}
{"parentUuid":"c7535a6e-226f-4115-bac2-9e07615eb059","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_012N2VkXZ3Y7ErUz8kAitAio","toolUseID":"toolu_012N2VkXZ3Y7ErUz8kAitAio","timestamp":"2026-02-14T10:17:16.545Z","uuid":"e1ad924b-d0b6-4c0f-b90d-1f65f02d52a7"}
{"parentUuid":"c84a44e8-ea41-4a48-8537-266ae4dd918c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012N2VkXZ3Y7ErUz8kAitAio","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"25a0a1f4-dba2-484c-a00f-2aa66ef669be","timestamp":"2026-02-14T10:17:16.544Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"t=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox","newString":"t=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":827,"oldLines":7,"newStart":827,"newLines":7,"lines":["         → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\""," "," t=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again","-        → dispatch both in parallel, each gets Implement stage prompt + Daytona sandbox","+        → dispatch both in parallel, each gets Implement stage prompt","         → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes","            → outputs next_status: \"Needs Validate\"","         → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"c84a44e8-ea41-4a48-8537-266ae4dd918c"}
{"parentUuid":"25a0a1f4-dba2-484c-a00f-2aa66ef669be","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_015vetednGQJHzXk2pS4dBpD","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 21: Issue #5 — Update TaskRequest interface with feature_request field**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":294,"cache_read_input_tokens":87857,"cache_creation":{"ephemeral_5m_input_tokens":294,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7niaLCRN8PWjyPkdZvb","type":"assistant","uuid":"d1b855a8-bd5d-4b4c-91b2-46c41f9b45de","timestamp":"2026-02-14T10:17:19.228Z"}
{"parentUuid":"d1b855a8-bd5d-4b4c-91b2-46c41f9b45de","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_015vetednGQJHzXk2pS4dBpD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019kVEwLxxHMF3GyPUVyfuGH","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```","new_string":"```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":294,"cache_read_input_tokens":87857,"cache_creation":{"ephemeral_5m_input_tokens":294,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7niaLCRN8PWjyPkdZvb","type":"assistant","uuid":"0a2e2d1b-5dac-4bab-bd75-6e752fe95214","timestamp":"2026-02-14T10:17:23.346Z"}
{"parentUuid":"0a2e2d1b-5dac-4bab-bd75-6e752fe95214","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_019kVEwLxxHMF3GyPUVyfuGH","parentToolUseID":"toolu_019kVEwLxxHMF3GyPUVyfuGH","uuid":"a3113bb4-2291-4f97-a663-14b97aa46711","timestamp":"2026-02-14T10:17:23.348Z"}
{"parentUuid":"a3113bb4-2291-4f97-a663-14b97aa46711","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_019kVEwLxxHMF3GyPUVyfuGH","toolUseID":"toolu_019kVEwLxxHMF3GyPUVyfuGH","timestamp":"2026-02-14T10:17:23.398Z","uuid":"a2ba93a2-bf5d-4895-9ea3-7734e629da46"}
{"parentUuid":"a2ba93a2-bf5d-4895-9ea3-7734e629da46","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_019kVEwLxxHMF3GyPUVyfuGH","toolUseID":"toolu_019kVEwLxxHMF3GyPUVyfuGH","timestamp":"2026-02-14T10:17:23.398Z","uuid":"7bbc3de5-d4a8-4375-9486-a4d652bbcefd"}
{"parentUuid":"0a2e2d1b-5dac-4bab-bd75-6e752fe95214","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019kVEwLxxHMF3GyPUVyfuGH","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"286e4439-842e-4100-8a09-12c7e2dcdc17","timestamp":"2026-02-14T10:17:23.397Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```","newString":"```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":605,"oldLines":6,"newStart":605,"newLines":7,"lines":[" ```typescript"," interface TaskRequest {","   id: string;","+  featureRequest: string;    // \"FR-1\" — parent feature request","   file: string;","   filePath: string;","   title: string;"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"0a2e2d1b-5dac-4bab-bd75-6e752fe95214"}
{"parentUuid":"286e4439-842e-4100-8a09-12c7e2dcdc17","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01WptLxLshcQxj1d75ett5mx","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 22: Issue #5 — Update variant example to use feature_requests/ paths**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":465,"cache_read_input_tokens":88151,"cache_creation":{"ephemeral_5m_input_tokens":465,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nj5U9XNugrZh7uPNjX","type":"assistant","uuid":"6054108e-ce1d-4f72-9135-a8277c601c6d","timestamp":"2026-02-14T10:17:25.657Z"}
{"parentUuid":"6054108e-ce1d-4f72-9135-a8277c601c6d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01WptLxLshcQxj1d75ett5mx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015zrzrUBfZrJ4TFqo6CWeLb","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"User: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:","new_string":"User: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":465,"cache_read_input_tokens":88151,"output_tokens":244,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":465},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7nj5U9XNugrZh7uPNjX","type":"assistant","uuid":"479dd8f3-b340-44ef-9f0b-a9b69ee713c8","timestamp":"2026-02-14T10:17:28.799Z"}
{"parentUuid":"479dd8f3-b340-44ef-9f0b-a9b69ee713c8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_015zrzrUBfZrJ4TFqo6CWeLb","parentToolUseID":"toolu_015zrzrUBfZrJ4TFqo6CWeLb","uuid":"16dbeb11-21ec-4388-b6d6-efae78c528d6","timestamp":"2026-02-14T10:17:28.803Z"}
{"parentUuid":"16dbeb11-21ec-4388-b6d6-efae78c528d6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_015zrzrUBfZrJ4TFqo6CWeLb","toolUseID":"toolu_015zrzrUBfZrJ4TFqo6CWeLb","timestamp":"2026-02-14T10:17:28.852Z","uuid":"faa8b776-7868-4c0c-8b34-51f5d8f7555d"}
{"parentUuid":"faa8b776-7868-4c0c-8b34-51f5d8f7555d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_015zrzrUBfZrJ4TFqo6CWeLb","toolUseID":"toolu_015zrzrUBfZrJ4TFqo6CWeLb","timestamp":"2026-02-14T10:17:28.852Z","uuid":"07e99acb-5e7d-46bd-8443-ecb8bfd9e494"}
{"parentUuid":"479dd8f3-b340-44ef-9f0b-a9b69ee713c8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015zrzrUBfZrJ4TFqo6CWeLb","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"297cb0ca-d49e-43df-850e-e1497c1fe0e3","timestamp":"2026-02-14T10:17:28.851Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"User: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:","newString":"User: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":803,"oldLines":7,"newStart":803,"newLines":7,"lines":[" "," User: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`"," ","-Spec Agent produces after clarification:","+Spec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:"," "," ```"," # Variant 1: Minimal card layout"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"479dd8f3-b340-44ef-9f0b-a9b69ee713c8"}
{"parentUuid":"297cb0ca-d49e-43df-850e-e1497c1fe0e3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01DyZ8r3ZtfJG7QtjVdicqBp","type":"message","role":"assistant","content":[{"type":"text","text":"**Edit 23: Phase 5 files update table — align with dispatchStage naming**"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":289,"cache_read_input_tokens":88616,"cache_creation":{"ephemeral_5m_input_tokens":289,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7njUwHEto4E1guw3CVW","type":"assistant","uuid":"e4e4c916-20fa-4d42-9b1c-5ec2fe591c7a","timestamp":"2026-02-14T10:17:31.424Z"}
{"parentUuid":"e4e4c916-20fa-4d42-9b1c-5ec2fe591c7a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01DyZ8r3ZtfJG7QtjVdicqBp","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Rw9aQ6JkR5qAvb99RVb2wA","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |","new_string":"| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":289,"cache_read_input_tokens":88616,"cache_creation":{"ephemeral_5m_input_tokens":289,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7njUwHEto4E1guw3CVW","type":"assistant","uuid":"778e3592-918b-4ece-8ab8-d14849eb403b","timestamp":"2026-02-14T10:17:33.932Z"}
{"parentUuid":"778e3592-918b-4ece-8ab8-d14849eb403b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01Rw9aQ6JkR5qAvb99RVb2wA","parentToolUseID":"toolu_01Rw9aQ6JkR5qAvb99RVb2wA","uuid":"f955ac42-3e0f-49e1-b0e2-66e37fdedefa","timestamp":"2026-02-14T10:17:33.935Z"}
{"parentUuid":"f955ac42-3e0f-49e1-b0e2-66e37fdedefa","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01Rw9aQ6JkR5qAvb99RVb2wA","toolUseID":"toolu_01Rw9aQ6JkR5qAvb99RVb2wA","timestamp":"2026-02-14T10:17:33.990Z","uuid":"1a6b18f7-84ec-457d-aa96-af22a215a446"}
{"parentUuid":"1a6b18f7-84ec-457d-aa96-af22a215a446","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01Rw9aQ6JkR5qAvb99RVb2wA","toolUseID":"toolu_01Rw9aQ6JkR5qAvb99RVb2wA","timestamp":"2026-02-14T10:17:33.990Z","uuid":"e333974b-b3d4-43e5-8934-5903e6e03ea7"}
{"parentUuid":"778e3592-918b-4ece-8ab8-d14849eb403b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Rw9aQ6JkR5qAvb99RVb2wA","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"0d47410a-ae93-4df6-933c-a649eb04ed0a","timestamp":"2026-02-14T10:17:33.989Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |","newString":"| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":1039,"oldLines":5,"newStart":1039,"newLines":5,"lines":[" "," | File | Change |"," |------|--------|","-| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, update `executeWorker()` to include test-writer step, update `writeResults()` to include test metadata |","+| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |"," | `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"778e3592-918b-4ece-8ab8-d14849eb403b"}
{"parentUuid":"0d47410a-ae93-4df6-933c-a649eb04ed0a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_016hvGyzCdmmsisW2AWKEkPY","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also update the `dispatchWorker` code snippet that still uses the old name and is in the \"How the Orchestrator Uses Statuses\" section."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":342,"cache_read_input_tokens":88905,"cache_creation":{"ephemeral_5m_input_tokens":342,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7njrqezkU6n8ySuudEW","type":"assistant","uuid":"c3b1f3f3-6844-4be2-b6d4-ade52d62208c","timestamp":"2026-02-14T10:17:37.251Z"}
{"parentUuid":"c3b1f3f3-6844-4be2-b6d4-ade52d62208c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_016hvGyzCdmmsisW2AWKEkPY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BivVmrrtZkXCnEQYYSCy22","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"async dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}","new_string":"async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":342,"cache_read_input_tokens":88905,"cache_creation":{"ephemeral_5m_input_tokens":342,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7njrqezkU6n8ySuudEW","type":"assistant","uuid":"7368ec17-cc6b-4839-8bcd-1ddf41a01d22","timestamp":"2026-02-14T10:17:41.840Z"}
{"parentUuid":"7368ec17-cc6b-4839-8bcd-1ddf41a01d22","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01BivVmrrtZkXCnEQYYSCy22","parentToolUseID":"toolu_01BivVmrrtZkXCnEQYYSCy22","uuid":"31ebf856-0ff6-4ad8-9f03-43ab677217b4","timestamp":"2026-02-14T10:17:41.842Z"}
{"parentUuid":"31ebf856-0ff6-4ad8-9f03-43ab677217b4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01BivVmrrtZkXCnEQYYSCy22","toolUseID":"toolu_01BivVmrrtZkXCnEQYYSCy22","timestamp":"2026-02-14T10:17:41.897Z","uuid":"04b19eeb-046d-4eb2-b24d-73296c46acb2"}
{"parentUuid":"04b19eeb-046d-4eb2-b24d-73296c46acb2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01BivVmrrtZkXCnEQYYSCy22","toolUseID":"toolu_01BivVmrrtZkXCnEQYYSCy22","timestamp":"2026-02-14T10:17:41.897Z","uuid":"186553ae-e366-474f-9a51-5d10a12bec04"}
{"parentUuid":"7368ec17-cc6b-4839-8bcd-1ddf41a01d22","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BivVmrrtZkXCnEQYYSCy22","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"3e2de411-43a5-4b52-88fd-59c1824cc437","timestamp":"2026-02-14T10:17:41.896Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"async dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}","newString":"async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchWorker(task: TaskRequest): Promise<void> {\n  const prompt = this.stagePromptMap[task.status];\n  if (!prompt) return; // not in a \"Needs *\" status — skip\n\n  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");\n  const result = await this.runWorkerAgent(sandbox, task, prompt);\n  await this.updateTaskStatus(task, result.nextStatus);\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":707,"oldLines":13,"newStart":707,"newLines":20,"lines":["   \"Needs Oneshot\":         \"agent2-worker-oneshot.md\","," };"," ","-async dispatchWorker(task: TaskRequest): Promise<void> {","-  const prompt = this.stagePromptMap[task.status];","-  if (!prompt) return; // not in a \"Needs *\" status — skip","+async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {","+  const sandbox = await this.createSandbox(task);"," ","-  await this.updateTaskStatus(task, task.status.replace(\"Needs\", \"\").trim() + \" In Progress\");","-  const result = await this.runWorkerAgent(sandbox, task, prompt);","-  await this.updateTaskStatus(task, result.nextStatus);","+  await this.updateTaskStatus(task, this.inProgressStatus(task.status));","+  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);","+","+  // Conditionally run test-writer for code-producing stages","+  let testResult: TestResult | undefined;","+  if (this.codeProducingStages.has(task.status)) {","+    const isTerminal = await this.isTerminal(task);","+    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));","+  }","+","+  return { stage: stageResult, tests: testResult };"," }"," ```"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"7368ec17-cc6b-4839-8bcd-1ddf41a01d22"}
{"parentUuid":"3e2de411-43a5-4b52-88fd-59c1824cc437","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01GXBa56k3wmET5FuePkddh8","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also update the `isActionable` function to include `NeedsOneshot`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":69816,"cache_read_input_tokens":20019,"cache_creation":{"ephemeral_5m_input_tokens":69816,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nkSbB3iPNCK5Jn1DTN","type":"assistant","uuid":"6f6d06d7-731d-4b6d-ae9a-0cd9bff92f9b","timestamp":"2026-02-14T10:17:44.826Z"}
{"parentUuid":"6f6d06d7-731d-4b6d-ae9a-0cd9bff92f9b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01GXBa56k3wmET5FuePkddh8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MYrAFMpaQ9Vk8RpzBMUiSg","name":"Read","input":{"file_path":"REDACTED.md","offset":720,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":69816,"cache_read_input_tokens":20019,"cache_creation":{"ephemeral_5m_input_tokens":69816,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nkSbB3iPNCK5Jn1DTN","type":"assistant","uuid":"07c95c3a-5bde-4eb6-aae5-17eec569a4c0","timestamp":"2026-02-14T10:17:45.906Z"}
{"parentUuid":"07c95c3a-5bde-4eb6-aae5-17eec569a4c0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01MYrAFMpaQ9Vk8RpzBMUiSg","parentToolUseID":"toolu_01MYrAFMpaQ9Vk8RpzBMUiSg","uuid":"43c76431-2d42-4f2c-9832-1e3809cc72bf","timestamp":"2026-02-14T10:17:45.909Z"}
{"parentUuid":"43c76431-2d42-4f2c-9832-1e3809cc72bf","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01MYrAFMpaQ9Vk8RpzBMUiSg","toolUseID":"toolu_01MYrAFMpaQ9Vk8RpzBMUiSg","timestamp":"2026-02-14T10:17:45.972Z","uuid":"faadf0e6-fb4a-4f69-ac39-1a0dcb6e40cd"}
{"parentUuid":"faadf0e6-fb4a-4f69-ac39-1a0dcb6e40cd","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01MYrAFMpaQ9Vk8RpzBMUiSg","toolUseID":"toolu_01MYrAFMpaQ9Vk8RpzBMUiSg","timestamp":"2026-02-14T10:17:45.972Z","uuid":"494e9081-157d-4eca-9622-6c6792aef470"}
{"parentUuid":"07c95c3a-5bde-4eb6-aae5-17eec569a4c0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MYrAFMpaQ9Vk8RpzBMUiSg","type":"tool_result","content":"   720→    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n   721→  }\n   722→\n   723→  return { stage: stageResult, tests: testResult };\n   724→}\n   725→```\n   726→\n   727→Key change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n   728→\n   729→### WORK_RESULT Stage Output\n   730→\n   731→Each stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n   732→\n   733→```yaml\n   734→WORK_RESULT"}]},"uuid":"5e837607-7f54-42c8-b5b9-de227a49594e","timestamp":"2026-02-14T10:17:45.971Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT","numLines":15,"startLine":720,"totalLines":1051}},"sourceToolAssistantUUID":"07c95c3a-5bde-4eb6-aae5-17eec569a4c0"}
{"parentUuid":"5e837607-7f54-42c8-b5b9-de227a49594e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_018H3R8Lupz2YzVZwmM18CJ6","type":"message","role":"assistant","content":[{"type":"text","text":"Good — `isActionable` uses `startsWith(\"Needs \")` which already covers `\"Needs Oneshot\"` naturally. No change needed there.\n\nLet me do a final review — read the WORK_RESULT example to check if it should mention \"Needs Oneshot\":"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":340,"cache_read_input_tokens":89835,"cache_creation":{"ephemeral_5m_input_tokens":340,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nkk3QQTrkpMQQcjyez","type":"assistant","uuid":"6082077a-54f5-4b77-8ee6-77fe1b2411f6","timestamp":"2026-02-14T10:17:50.022Z"}
{"parentUuid":"6082077a-54f5-4b77-8ee6-77fe1b2411f6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_018H3R8Lupz2YzVZwmM18CJ6","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012yReDvFDaocwEHWtzQXCeB","name":"Read","input":{"file_path":"REDACTED.md","offset":729,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":340,"cache_read_input_tokens":89835,"cache_creation":{"ephemeral_5m_input_tokens":340,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nkk3QQTrkpMQQcjyez","type":"assistant","uuid":"068f37d9-c64b-423c-96b1-36ecd12f9850","timestamp":"2026-02-14T10:17:50.800Z"}
{"parentUuid":"068f37d9-c64b-423c-96b1-36ecd12f9850","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_012yReDvFDaocwEHWtzQXCeB","parentToolUseID":"toolu_012yReDvFDaocwEHWtzQXCeB","uuid":"0547e725-157d-438d-ac57-08ca40c8c827","timestamp":"2026-02-14T10:17:50.804Z"}
{"parentUuid":"0547e725-157d-438d-ac57-08ca40c8c827","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_012yReDvFDaocwEHWtzQXCeB","toolUseID":"toolu_012yReDvFDaocwEHWtzQXCeB","timestamp":"2026-02-14T10:17:50.864Z","uuid":"e82ff353-02f5-44d5-bcc2-63aea029904b"}
{"parentUuid":"e82ff353-02f5-44d5-bcc2-63aea029904b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_012yReDvFDaocwEHWtzQXCeB","toolUseID":"toolu_012yReDvFDaocwEHWtzQXCeB","timestamp":"2026-02-14T10:17:50.864Z","uuid":"78de814c-3bf6-4d1d-937a-4fb5b49508de"}
{"parentUuid":"068f37d9-c64b-423c-96b1-36ecd12f9850","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012yReDvFDaocwEHWtzQXCeB","type":"tool_result","content":"   729→### WORK_RESULT Stage Output\n   730→\n   731→Each stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n   732→\n   733→```yaml\n   734→WORK_RESULT\n   735→---\n   736→success: true\n   737→stage_completed: research\n   738→workflow: staged          # or \"oneshot\"\n   739→next_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n   740→---\n   741→```\n   742→\n   743→### Intervention Statuses"}]},"uuid":"f62da135-716d-4e32-a221-4380e6137fbb","timestamp":"2026-02-14T10:17:50.863Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses","numLines":15,"startLine":729,"totalLines":1051}},"sourceToolAssistantUUID":"068f37d9-c64b-423c-96b1-36ecd12f9850"}
{"parentUuid":"f62da135-716d-4e32-a221-4380e6137fbb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_0156hdjtmbxaetAL89kiQoPN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JZYEXSazTW85p4sHH5Zpyu","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"next_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed","new_string":"next_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":335,"cache_read_input_tokens":90175,"cache_creation":{"ephemeral_5m_input_tokens":335,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nm7ZDGVSdYz49ELXTN","type":"assistant","uuid":"5a03edc2-8202-4662-950f-360744a4108a","timestamp":"2026-02-14T10:17:54.930Z"}
{"parentUuid":"5a03edc2-8202-4662-950f-360744a4108a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01JZYEXSazTW85p4sHH5Zpyu","parentToolUseID":"toolu_01JZYEXSazTW85p4sHH5Zpyu","uuid":"9f7c8ad2-4531-4e45-92e0-eeae5b23d828","timestamp":"2026-02-14T10:17:54.933Z"}
{"parentUuid":"9f7c8ad2-4531-4e45-92e0-eeae5b23d828","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01JZYEXSazTW85p4sHH5Zpyu","toolUseID":"toolu_01JZYEXSazTW85p4sHH5Zpyu","timestamp":"2026-02-14T10:17:54.988Z","uuid":"a6be0ae1-65aa-47cc-a2a9-3561ff213c59"}
{"parentUuid":"a6be0ae1-65aa-47cc-a2a9-3561ff213c59","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01JZYEXSazTW85p4sHH5Zpyu","toolUseID":"toolu_01JZYEXSazTW85p4sHH5Zpyu","timestamp":"2026-02-14T10:17:54.988Z","uuid":"8833c5ae-145a-4ce2-8297-8b83517afb33"}
{"parentUuid":"5a03edc2-8202-4662-950f-360744a4108a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JZYEXSazTW85p4sHH5Zpyu","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"c21e6a57-b804-4a0c-b858-bbc8dcc9e7a2","timestamp":"2026-02-14T10:17:54.988Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"next_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed","newString":"next_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":736,"oldLines":7,"newStart":736,"newLines":7,"lines":[" success: true"," stage_completed: research"," workflow: staged          # or \"oneshot\"","-next_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed","+next_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track"," ---"," ```"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"5a03edc2-8202-4662-950f-360744a4108a"}
{"parentUuid":"c21e6a57-b804-4a0c-b858-bbc8dcc9e7a2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_013VTKRZoF416BPurqyvWyty","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me do a final scan for any remaining references to `request_queue/` that should be `feature_requests/`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":236,"cache_read_input_tokens":90510,"cache_creation":{"ephemeral_5m_input_tokens":236,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nmQdNyX4fDffVTQY8r","type":"assistant","uuid":"4c736fcd-7be0-45f1-8bbe-a08d9cab9257","timestamp":"2026-02-14T10:17:58.159Z"}
{"parentUuid":"4c736fcd-7be0-45f1-8bbe-a08d9cab9257","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_013VTKRZoF416BPurqyvWyty","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SskgPXKiaCBrg1fNQdpGhV","name":"Grep","input":{"pattern":"request_queue","path":"REDACTED.md","output_mode":"content"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":236,"cache_read_input_tokens":90510,"cache_creation":{"ephemeral_5m_input_tokens":236,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nmQdNyX4fDffVTQY8r","type":"assistant","uuid":"5e487e70-3794-4a5c-9f0f-87d06697126f","timestamp":"2026-02-14T10:17:58.977Z"}
{"parentUuid":"5e487e70-3794-4a5c-9f0f-87d06697126f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01SskgPXKiaCBrg1fNQdpGhV","parentToolUseID":"toolu_01SskgPXKiaCBrg1fNQdpGhV","uuid":"d0eb6860-67cf-4586-8b23-e0c853747742","timestamp":"2026-02-14T10:17:58.981Z"}
{"parentUuid":"d0eb6860-67cf-4586-8b23-e0c853747742","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01SskgPXKiaCBrg1fNQdpGhV","toolUseID":"toolu_01SskgPXKiaCBrg1fNQdpGhV","timestamp":"2026-02-14T10:17:59.307Z","uuid":"ce0608a7-4a6b-4f10-b228-69029e70cfa3"}
{"parentUuid":"ce0608a7-4a6b-4f10-b228-69029e70cfa3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"callback"},"parentToolUseID":"toolu_01SskgPXKiaCBrg1fNQdpGhV","toolUseID":"toolu_01SskgPXKiaCBrg1fNQdpGhV","timestamp":"2026-02-14T10:17:59.307Z","uuid":"fb77f14b-41f5-40fc-a714-c7d87d2e9be1"}
{"parentUuid":"5e487e70-3794-4a5c-9f0f-87d06697126f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SskgPXKiaCBrg1fNQdpGhV","type":"tool_result","content":"No matches found"}]},"uuid":"87d940b9-9bef-41ef-9746-0544426cb6d4","timestamp":"2026-02-14T10:17:59.305Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0},"sourceToolAssistantUUID":"5e487e70-3794-4a5c-9f0f-87d06697126f"}
{"parentUuid":"87d940b9-9bef-41ef-9746-0544426cb6d4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_017KjYMvF46dFcYNAxr26gzX","type":"message","role":"assistant","content":[{"type":"text","text":"Good. Let me also check for any remaining `executeWorker` references:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":159,"cache_read_input_tokens":90746,"cache_creation":{"ephemeral_5m_input_tokens":159,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nmj2AY2Rs8erNNeXd3","type":"assistant","uuid":"2c30eef3-95bc-4489-958a-fba08aae954e","timestamp":"2026-02-14T10:18:02.310Z"}
{"parentUuid":"2c30eef3-95bc-4489-958a-fba08aae954e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_017KjYMvF46dFcYNAxr26gzX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VV9tByssrybotHqxE6VBbj","name":"Grep","input":{"pattern":"executeWorker","path":"REDACTED.md","output_mode":"content"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":159,"cache_read_input_tokens":90746,"cache_creation":{"ephemeral_5m_input_tokens":159,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nmj2AY2Rs8erNNeXd3","type":"assistant","uuid":"56da733b-eb67-4315-b6be-1f276cf39618","timestamp":"2026-02-14T10:18:03.085Z"}
{"parentUuid":"56da733b-eb67-4315-b6be-1f276cf39618","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01VV9tByssrybotHqxE6VBbj","parentToolUseID":"toolu_01VV9tByssrybotHqxE6VBbj","uuid":"776a336f-fa60-451f-9632-59c9c31bec37","timestamp":"2026-02-14T10:18:03.088Z"}
{"parentUuid":"776a336f-fa60-451f-9632-59c9c31bec37","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01VV9tByssrybotHqxE6VBbj","toolUseID":"toolu_01VV9tByssrybotHqxE6VBbj","timestamp":"2026-02-14T10:18:03.383Z","uuid":"f3c07d84-288f-4f94-aaf1-aba56f1e245d"}
{"parentUuid":"f3c07d84-288f-4f94-aaf1-aba56f1e245d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"callback"},"parentToolUseID":"toolu_01VV9tByssrybotHqxE6VBbj","toolUseID":"toolu_01VV9tByssrybotHqxE6VBbj","timestamp":"2026-02-14T10:18:03.383Z","uuid":"638e0932-203c-4880-943f-b4948b8bf23d"}
{"parentUuid":"56da733b-eb67-4315-b6be-1f276cf39618","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VV9tByssrybotHqxE6VBbj","type":"tool_result","content":"513:### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)"}]},"uuid":"b909bcd8-48eb-471e-ba22-8d51c4064342","timestamp":"2026-02-14T10:18:03.381Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"513:### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)","numLines":1},"sourceToolAssistantUUID":"56da733b-eb67-4315-b6be-1f276cf39618"}
{"parentUuid":"b909bcd8-48eb-471e-ba22-8d51c4064342","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01LHR3o2DubcoDSLNH7fC2PY","type":"message","role":"assistant","content":[{"type":"text","text":"That's fine — it's the historical note about the rename. Let me check for `loadActionableTasks` references:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":178,"cache_read_input_tokens":90905,"cache_creation":{"ephemeral_5m_input_tokens":178,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nn2RvQcmePR6kVkX5D","type":"assistant","uuid":"780e3bdf-17cf-4b88-9c58-d6f6cb6c7bab","timestamp":"2026-02-14T10:18:07.694Z"}
{"parentUuid":"780e3bdf-17cf-4b88-9c58-d6f6cb6c7bab","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01LHR3o2DubcoDSLNH7fC2PY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0132ZXQz983JeUqduJmbDhU3","name":"Grep","input":{"pattern":"loadActionableTasks","path":"REDACTED.md","output_mode":"content"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":178,"cache_read_input_tokens":90905,"cache_creation":{"ephemeral_5m_input_tokens":178,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nn2RvQcmePR6kVkX5D","type":"assistant","uuid":"710f4558-1d00-4d9e-8252-81f69fbd723d","timestamp":"2026-02-14T10:18:08.708Z"}
{"parentUuid":"710f4558-1d00-4d9e-8252-81f69fbd723d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_0132ZXQz983JeUqduJmbDhU3","parentToolUseID":"toolu_0132ZXQz983JeUqduJmbDhU3","uuid":"3ee4bf16-0e8e-4a97-b123-f97a9f8a5d06","timestamp":"2026-02-14T10:18:08.713Z"}
{"parentUuid":"3ee4bf16-0e8e-4a97-b123-f97a9f8a5d06","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_0132ZXQz983JeUqduJmbDhU3","toolUseID":"toolu_0132ZXQz983JeUqduJmbDhU3","timestamp":"2026-02-14T10:18:09.009Z","uuid":"e033e8c2-4760-4f69-a3ef-a93ca2c600fb"}
{"parentUuid":"e033e8c2-4760-4f69-a3ef-a93ca2c600fb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"callback"},"parentToolUseID":"toolu_0132ZXQz983JeUqduJmbDhU3","toolUseID":"toolu_0132ZXQz983JeUqduJmbDhU3","timestamp":"2026-02-14T10:18:09.009Z","uuid":"a25f04cd-15fe-4abd-8ca6-50860c442713"}
{"parentUuid":"710f4558-1d00-4d9e-8252-81f69fbd723d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0132ZXQz983JeUqduJmbDhU3","type":"tool_result","content":"No matches found"}]},"uuid":"2d52a7ae-2f97-41f1-a34b-573dfe4e1b4f","timestamp":"2026-02-14T10:18:09.008Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"","numLines":0},"sourceToolAssistantUUID":"710f4558-1d00-4d9e-8252-81f69fbd723d"}
{"parentUuid":"2d52a7ae-2f97-41f1-a34b-573dfe4e1b4f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_013QBhcVX1P678xJrPWgzNhQ","type":"message","role":"assistant","content":[{"type":"text","text":"Clean. Let me check for remaining `agent1` or `agent3` references that should be updated:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":300,"cache_read_input_tokens":91083,"cache_creation":{"ephemeral_5m_input_tokens":300,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nnSbitD7CGkxoxPacC","type":"assistant","uuid":"00b02ebb-5e4e-4d77-9001-5274dfd6b9cf","timestamp":"2026-02-14T10:18:12.371Z"}
{"parentUuid":"00b02ebb-5e4e-4d77-9001-5274dfd6b9cf","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_013QBhcVX1P678xJrPWgzNhQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SGb8YxjRj4gknkTVa811Fd","name":"Grep","input":{"pattern":"agent[13]-linear","path":"REDACTED.md","output_mode":"content"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":300,"cache_read_input_tokens":91083,"cache_creation":{"ephemeral_5m_input_tokens":300,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nnSbitD7CGkxoxPacC","type":"assistant","uuid":"c05766bd-cc84-4d3a-a18d-13a7b534f090","timestamp":"2026-02-14T10:18:13.274Z"}
{"parentUuid":"c05766bd-cc84-4d3a-a18d-13a7b534f090","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01SGb8YxjRj4gknkTVa811Fd","parentToolUseID":"toolu_01SGb8YxjRj4gknkTVa811Fd","uuid":"cb5d160a-ad4d-46da-ae84-64ec4ebf7502","timestamp":"2026-02-14T10:18:13.278Z"}
{"parentUuid":"cb5d160a-ad4d-46da-ae84-64ec4ebf7502","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01SGb8YxjRj4gknkTVa811Fd","toolUseID":"toolu_01SGb8YxjRj4gknkTVa811Fd","timestamp":"2026-02-14T10:18:13.575Z","uuid":"4758b71b-0a97-428c-860e-38740d2196cc"}
{"parentUuid":"4758b71b-0a97-428c-860e-38740d2196cc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"callback"},"parentToolUseID":"toolu_01SGb8YxjRj4gknkTVa811Fd","toolUseID":"toolu_01SGb8YxjRj4gknkTVa811Fd","timestamp":"2026-02-14T10:18:13.575Z","uuid":"a8e88f50-493c-4de8-baa6-78abaad35685"}
{"parentUuid":"c05766bd-cc84-4d3a-a18d-13a7b534f090","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SGb8YxjRj4gknkTVa811Fd","type":"tool_result","content":"39:| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n47:| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n895:| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n896:| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |"}]},"uuid":"0461eead-5033-4778-999a-6ba04b086e17","timestamp":"2026-02-14T10:18:13.573Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"39:| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n47:| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n895:| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n896:| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |","numLines":4},"sourceToolAssistantUUID":"c05766bd-cc84-4d3a-a18d-13a7b534f090"}
{"parentUuid":"0461eead-5033-4778-999a-6ba04b086e17","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01EGtHzTmwFme2D8m9WK3Auw","type":"message","role":"assistant","content":[{"type":"text","text":"All correctly marked as \"Removed\". Let me do one final check on the adaptation guidelines which mention reading/writing local MD files — those should still reference the right directory:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":394,"cache_read_input_tokens":91383,"cache_creation":{"ephemeral_5m_input_tokens":394,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nnnBT4ohZKo33hzCjF","type":"assistant","uuid":"e1b69ffc-6d03-4395-9536-605e534a02ce","timestamp":"2026-02-14T10:18:18.510Z"}
{"parentUuid":"e1b69ffc-6d03-4395-9536-605e534a02ce","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01EGtHzTmwFme2D8m9WK3Auw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VcnBcMjZSBxD5rFeiksQjT","name":"Read","input":{"file_path":"REDACTED.md","offset":85,"limit":12},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":394,"cache_read_input_tokens":91383,"cache_creation":{"ephemeral_5m_input_tokens":394,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7nnnBT4ohZKo33hzCjF","type":"assistant","uuid":"f1d3269b-1629-477c-a2a5-4041084347b2","timestamp":"2026-02-14T10:18:19.235Z"}
{"parentUuid":"f1d3269b-1629-477c-a2a5-4041084347b2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01VcnBcMjZSBxD5rFeiksQjT","parentToolUseID":"toolu_01VcnBcMjZSBxD5rFeiksQjT","uuid":"9610bb55-609c-4044-8db2-ee6abd856a03","timestamp":"2026-02-14T10:18:19.239Z"}
{"parentUuid":"9610bb55-609c-4044-8db2-ee6abd856a03","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01VcnBcMjZSBxD5rFeiksQjT","toolUseID":"toolu_01VcnBcMjZSBxD5rFeiksQjT","timestamp":"2026-02-14T10:18:19.344Z","uuid":"fa892a5b-2079-4f81-9edf-edc04b9cb074"}
{"parentUuid":"fa892a5b-2079-4f81-9edf-edc04b9cb074","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01VcnBcMjZSBxD5rFeiksQjT","toolUseID":"toolu_01VcnBcMjZSBxD5rFeiksQjT","timestamp":"2026-02-14T10:18:19.344Z","uuid":"6ac4cde3-a1c8-4f86-a5a7-65444fae9ce6"}
{"parentUuid":"f1d3269b-1629-477c-a2a5-4041084347b2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VcnBcMjZSBxD5rFeiksQjT","type":"tool_result","content":"    85→\n    86→### Adaptation Guidelines for Horizon → Napoli Prompts\n    87→\n    88→When editing prompts that reference Horizon/Linear:\n    89→\n    90→1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n    91→2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n    92→3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n    93→4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n    94→5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n    95→6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n    96→"}]},"uuid":"ec09c68d-26d1-4f5c-8ea8-3b78041adf74","timestamp":"2026-02-14T10:18:19.343Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n","numLines":12,"startLine":85,"totalLines":1051}},"sourceToolAssistantUUID":"f1d3269b-1629-477c-a2a5-4041084347b2"}
{"parentUuid":"ec09c68d-26d1-4f5c-8ea8-3b78041adf74","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01Wnh5BnzMoU1BHDkcef2ejE","type":"message","role":"assistant","content":[{"type":"text","text":"This section is about adapting the worker prompts (agent2-worker-*.md) — those prompts don't directly read/write queue files (the orchestrator does), so point 1 is less relevant now. Let me update it:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":396,"cache_read_input_tokens":91777,"cache_creation":{"ephemeral_5m_input_tokens":396,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7noCkJtZHS3jCm3yZDP","type":"assistant","uuid":"5ea733e2-ddf7-470f-803d-60e8c96d293d","timestamp":"2026-02-14T10:18:23.142Z"}
{"parentUuid":"5ea733e2-ddf7-470f-803d-60e8c96d293d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01Wnh5BnzMoU1BHDkcef2ejE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UkpatVjQRbQNjUMVkAeDkE","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files","new_string":"1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":396,"cache_read_input_tokens":91777,"cache_creation":{"ephemeral_5m_input_tokens":396,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7noCkJtZHS3jCm3yZDP","type":"assistant","uuid":"4b751ad9-be24-4b3d-8aa8-d8cdfb3d5f07","timestamp":"2026-02-14T10:18:24.894Z"}
{"parentUuid":"4b751ad9-be24-4b3d-8aa8-d8cdfb3d5f07","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01UkpatVjQRbQNjUMVkAeDkE","parentToolUseID":"toolu_01UkpatVjQRbQNjUMVkAeDkE","uuid":"90b59cc5-3c9e-4643-856b-e07bb88d946b","timestamp":"2026-02-14T10:18:24.896Z"}
{"parentUuid":"90b59cc5-3c9e-4643-856b-e07bb88d946b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01UkpatVjQRbQNjUMVkAeDkE","toolUseID":"toolu_01UkpatVjQRbQNjUMVkAeDkE","timestamp":"2026-02-14T10:18:24.947Z","uuid":"2cd1daee-e4e5-4c0a-8cd8-6a34c63cf6e0"}
{"parentUuid":"2cd1daee-e4e5-4c0a-8cd8-6a34c63cf6e0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01UkpatVjQRbQNjUMVkAeDkE","toolUseID":"toolu_01UkpatVjQRbQNjUMVkAeDkE","timestamp":"2026-02-14T10:18:24.947Z","uuid":"0f82613f-9dd0-485a-80e2-688c34815969"}
{"parentUuid":"4b751ad9-be24-4b3d-8aa8-d8cdfb3d5f07","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UkpatVjQRbQNjUMVkAeDkE","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"c86d5001-ace1-488a-aa58-10bf39485a12","timestamp":"2026-02-14T10:18:24.946Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files","newString":"1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents","originalFile":"# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":87,"oldLines":7,"newStart":87,"newLines":7,"lines":[" "," When editing prompts that reference Horizon/Linear:"," ","-1. **Replace `mcp__linear__*` tool calls** with instructions to read/write local MD files","+1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents"," 2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list."," 3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic"," 4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"4b751ad9-be24-4b3d-8aa8-d8cdfb3d5f07"}
{"parentUuid":"c86d5001-ace1-488a-aa58-10bf39485a12","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01TncHVUeJiExkVGqiVJFgLY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QNcnoNiyUwiF1ZabMdq2XU","name":"TaskUpdate","input":{"taskId":"1","status":"completed"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":292,"cache_read_input_tokens":92173,"output_tokens":70,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":292},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7nocng3PoKMAp8LF6Zi","type":"assistant","uuid":"bdfdb09a-8df8-47f8-bd8f-1e5815dab273","timestamp":"2026-02-14T10:18:27.701Z"}
{"parentUuid":"bdfdb09a-8df8-47f8-bd8f-1e5815dab273","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:TaskUpdate","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01QNcnoNiyUwiF1ZabMdq2XU","parentToolUseID":"toolu_01QNcnoNiyUwiF1ZabMdq2XU","uuid":"9f668a78-60c7-4c20-9481-82c3e750002e","timestamp":"2026-02-14T10:18:27.704Z"}
{"parentUuid":"9f668a78-60c7-4c20-9481-82c3e750002e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:TaskUpdate","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01QNcnoNiyUwiF1ZabMdq2XU","toolUseID":"toolu_01QNcnoNiyUwiF1ZabMdq2XU","timestamp":"2026-02-14T10:18:38.695Z","uuid":"f1f442a5-579e-472b-a4c9-b0689b5ffeca"}
{"parentUuid":"bdfdb09a-8df8-47f8-bd8f-1e5815dab273","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QNcnoNiyUwiF1ZabMdq2XU","type":"tool_result","content":"Updated task #1 status"}]},"uuid":"21226ff1-abcc-47f4-a994-dcc0e4099ec0","timestamp":"2026-02-14T10:18:38.692Z","toolUseResult":{"success":true,"taskId":"1","updatedFields":["status"],"statusChange":{"from":"in_progress","to":"completed"}},"sourceToolAssistantUUID":"bdfdb09a-8df8-47f8-bd8f-1e5815dab273"}
{"parentUuid":"21226ff1-abcc-47f4-a994-dcc0e4099ec0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01LMUSaronmSdE35ptryT6Ny","type":"message","role":"assistant","content":[{"type":"text","text":"All 6 issues applied. Here's what changed:\n\n| Issue | Edits made |\n|-------|-----------|\n| **#1 filterEligible → Version B** | Replaced 3-param with 2-param signature, updated `processQueue` to use single `loadAllTasks()`, replaced \"Two Task Loaders\" section with \"Single Task Loader\", updated variant changes table and Files table |\n| **#2 Add NeedsOneshot** | Added to `TaskStatus` enum, `stagePromptMap`, transition diagram, WORK_RESULT example, research stage description, verification item |\n| **#3 All stages in sandboxes** | Replaced line 486 local/sandbox split with \"all stages in Daytona sandboxes\", unified `dispatchStage` as single method, updated \"How the Orchestrator Uses Statuses\" code snippet |\n| **#4 Absorb agent1/agent3** | Marked as \"Removed\" in prompt mapping table and Files table, updated pipeline diagram to show orchestrator handling read/write, updated reference architecture table, updated adaptation guidelines |\n| **#5 FR-{n} feature request layer** | Replaced TODO comment + flat `request_queue/` with full `feature_requests/FR-{n}/` directory structure with variant subdirs, added `request.md` format, added `featureRequest` field to `TaskRequest`, updated all path references throughout |\n| **#6 Test-writer scope** | Updated Purpose to specify Implement/Oneshot/Validate only, updated execution flow pseudocode, updated orchestrator integration code with `codeProducingStages` set, updated Phase 5 files table |"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":88,"cache_read_input_tokens":92465,"cache_creation":{"ephemeral_5m_input_tokens":88,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7npdTdhq63U9cMGZzFM","type":"assistant","uuid":"57c7af47-b149-41c4-b943-86e09beec02b","timestamp":"2026-02-14T10:18:50.178Z"}
{"parentUuid":"57c7af47-b149-41c4-b943-86e09beec02b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"82cb480e-0e21-4c0f-92f0-7d9f0c7618b9","toolUseID":"82cb480e-0e21-4c0f-92f0-7d9f0c7618b9","timestamp":"2026-02-14T10:18:50.251Z","uuid":"06f063e1-83a3-4a92-8a96-c2a7da1814f0"}
{"parentUuid":"06f063e1-83a3-4a92-8a96-c2a7da1814f0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"82cb480e-0e21-4c0f-92f0-7d9f0c7618b9","toolUseID":"82cb480e-0e21-4c0f-92f0-7d9f0c7618b9","timestamp":"2026-02-14T10:18:50.252Z","uuid":"d1cd38c0-b7d7-4ee4-a15a-fadffaf54ea0"}
{"parentUuid":"d1cd38c0-b7d7-4ee4-a15a-fadffaf54ea0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T10:18:50.693Z","uuid":"dec7007f-7a40-4102-99d8-a1dfc66accb9","toolUseID":"82cb480e-0e21-4c0f-92f0-7d9f0c7618b9"}
{"parentUuid":"dec7007f-7a40-4102-99d8-a1dfc66accb9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"system","subtype":"turn_duration","durationMs":305467,"timestamp":"2026-02-14T10:18:50.694Z","uuid":"75f4dd2e-25a2-4e7b-b37e-a6e354ef0347","isMeta":false}
{"type":"file-history-snapshot","messageId":"fd418968-e5b6-4052-b065-0e72453f23e2","snapshot":{"messageId":"fd418968-e5b6-4052-b065-0e72453f23e2","trackedFileBackups":{"IMPLEMENTATION_PLAN.md":{"backupFileName":"7cb5415938e35d8f@v2","version":2,"backupTime":"2026-02-14T10:23:49.453Z"}},"timestamp":"2026-02-14T10:23:49.450Z"},"isSnapshotUpdate":false}
{"parentUuid":"75f4dd2e-25a2-4e7b-b37e-a6e354ef0347","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":"<local-command-caveat>Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.</local-command-caveat>"},"isMeta":true,"uuid":"c204ebd6-2474-42f0-9fde-48b62f124f24","timestamp":"2026-02-14T10:23:49.449Z"}
{"parentUuid":"c204ebd6-2474-42f0-9fde-48b62f124f24","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":"<command-name>/compact</command-name>\n            <command-message>compact</command-message>\n            <command-args></command-args>"},"uuid":"fd418968-e5b6-4052-b065-0e72453f23e2","timestamp":"2026-02-14T10:23:47.734Z"}
{"parentUuid":"fd418968-e5b6-4052-b065-0e72453f23e2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":"<local-command-stderr>Error: Compaction canceled.</local-command-stderr>"},"uuid":"c71a58e7-ae1a-4dd4-9d71-7f62a779150a","timestamp":"2026-02-14T10:23:49.449Z"}
{"type":"queue-operation","operation":"enqueue","timestamp":"2026-02-14T10:24:59.979Z","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","content":"Clarify what the final structure of the requests_queue will be which stores the requests queues and tickets created by the spec agent"}
{"type":"file-history-snapshot","messageId":"56aa410c-779b-4276-8c69-104b6ccaa924","snapshot":{"messageId":"56aa410c-779b-4276-8c69-104b6ccaa924","trackedFileBackups":{"IMPLEMENTATION_PLAN.md":{"backupFileName":"7cb5415938e35d8f@v2","version":2,"backupTime":"2026-02-14T10:23:49.453Z"}},"timestamp":"2026-02-14T10:25:09.957Z"},"isSnapshotUpdate":false}
{"type":"file-history-snapshot","messageId":"21259a2a-02ef-4914-a85d-db9b8994b2c2","snapshot":{"messageId":"21259a2a-02ef-4914-a85d-db9b8994b2c2","trackedFileBackups":{"IMPLEMENTATION_PLAN.md":{"backupFileName":"7cb5415938e35d8f@v2","version":2,"backupTime":"2026-02-14T10:23:49.453Z"}},"timestamp":"2026-02-14T10:25:09.957Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"logicalParentUuid":"c71a58e7-ae1a-4dd4-9d71-7f62a779150a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"system","subtype":"compact_boundary","content":"Conversation compacted","isMeta":false,"timestamp":"2026-02-14T10:25:09.956Z","uuid":"9037792d-6477-4777-b5b7-162c58f75cd2","level":"info","compactMetadata":{"trigger":"manual","preTokens":93314}}
{"parentUuid":"9037792d-6477-4777-b5b7-162c58f75cd2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":"This session is being continued from a previous conversation that ran out of context. The summary below covers the earlier portion of the conversation.\n\nAnalysis:\nLet me chronologically analyze the conversation:\n\n1. The user asked me to re-read IMPLEMENTATION_PLAN.md and summarize the core agent workflow, checking for contradictions and alignment issues.\n\n2. I provided a summary and identified 6 issues/contradictions in the plan.\n\n3. The user asked me to dig into all 6 issues and ask questions to resolve them one at a time.\n\n4. Issue #1 (filterEligible): User asked me to explain considerations rather than choose. I explained the two jobs (dispatch narrowing vs dependency checking) and the two versions. User pointed out that no one would realistically pass only actionable tasks since the orchestrator is the only caller. I confirmed Version B works. User asked me to confirm all In Progress statuses are excluded. I confirmed isActionable() handles all of them. User chose Version B.\n\n5. Issue #2 (Oneshot dispatch gap): I presented two options. User chose \"Add NeedsOneshot status\".\n\n6. Issue #3 (naming conflict): User clarified they intended all stages to run in sandboxes to keep the orchestrator lightweight. This eliminated the local vs sandbox distinction and resolved the naming conflict. User confirmed \"Yes, all stages in sandboxes\".\n\n7. Issue #4 (Agent 1 & 3): User asked if Agent 1 still needs to reason about prioritization, and if Agent 3 still needs LLM for parsing. I explained both are deterministic operations. User confirmed \"ok proceed with TypeScript\".\n\n8. Issue #5 (Dual ID TODO): User chose \"Add feature request layer\" with FR-{n} IDs and directories. Then chose \"Subdirs per variant group\".\n\n9. Issue #6 (Test-writer scope): User chose \"Implement + Oneshot + Validate\" for test-writer triggers.\n\n10. User asked me to apply all changes to the plan. I made 23 edits to IMPLEMENTATION_PLAN.md.\n\nLet me enumerate all the specific edits made to the file.\n\nSummary:\n1. Primary Request and Intent:\n   The user asked me to re-read IMPLEMENTATION_PLAN.md, summarize the core agent workflow, and check for contradictions and alignment issues. After I identified 6 issues, the user asked me to dig into each one, ask clarifying questions, and then apply all resolved changes to the plan file.\n\n2. Key Technical Concepts:\n   - Multi-agent pipeline: Spec Agent → Orchestrator → Workers (in Daytona sandboxes) → Test-Writer\n   - Stage-aware dispatch: one stage per worker invocation, orchestrator re-dispatches based on WORK_RESULT `next_status`\n   - TaskStatus enum with 17+ granular statuses (Needs Research → Research In Progress → ... → Done)\n   - `filterEligible` function: narrows all tasks to dispatch candidates using `isActionable()` guard\n   - `isTerminal` check: only terminal tickets (nothing non-Done depends on them) get PR + merge\n   - Feature request layer: FR-{n} IDs for user requests, AGI-{n} IDs for implementation tickets\n   - Variant support: duplicate dependency chains with independent IDs, shared group branches\n   - WORK_RESULT structured YAML output format for inter-agent communication\n   - ClaudeSpawner for local Spec Agent execution\n\n3. Files and Code Sections:\n   - `REDACTED.md`\n     - This is the sole file modified. It's the comprehensive implementation plan for the napoli-matcha agent pipeline.\n     - **23 edits were applied** to resolve 6 identified issues:\n\n     **Issue #1 - filterEligible → Version B (2-param):**\n     - Replaced 3-param `filterEligible(actionableTasks, allTasks, active)` with 2-param `filterEligible(allTasks, active)` using `isActionable()` guard inside\n     - Updated `processQueue` from two loaders to single `loadAllTasks()`:\n       ```typescript\n       const allTasks = await this.loadAllTasks();  // every status\n       const eligible = this.filterEligible(allTasks, active);\n       ```\n     - Replaced \"Two Task Loaders\" section with \"Single Task Loader\" section describing `loadAllTasks()` globbing `feature_requests/**/AGI-*.md`\n     - Updated variant changes table and Files table to remove `loadActionableTasks()` references\n\n     **Issue #2 - Add NeedsOneshot status:**\n     - Added `NeedsOneshot = \"Needs Oneshot\"` to TaskStatus enum\n     - Added `\"Needs Oneshot\": \"agent2-worker-oneshot.md\"` to stagePromptMap\n     - Updated transition diagram: `SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done`\n     - Updated WORK_RESULT example comment: `# or \"Needs Oneshot\" for fast-track`\n     - Updated research stage description to output `\"Needs Oneshot\"` for fast-track\n     - Updated verification item #6\n\n     **Issue #3 - All stages in sandboxes:**\n     - Replaced line 486 `\"Research/Spec/Plan stages can run without a sandbox\"` with `\"All worker stages run in Daytona sandboxes. Only the Spec Agent runs locally via ClaudeSpawner.\"`\n     - Unified `dispatchStage` as the single method. Updated the \"How the Orchestrator Uses Statuses\" code snippet:\n       ```typescript\n       async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n         const sandbox = await this.createSandbox(task);\n         await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n         const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n         let testResult: TestResult | undefined;\n         if (this.codeProducingStages.has(task.status)) {\n           const isTerminal = await this.isTerminal(task);\n           testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n         }\n         return { stage: stageResult, tests: testResult };\n       }\n       ```\n\n     **Issue #4 - Absorb agent1/agent3 into TypeScript:**\n     - Marked `agent1-linear-reader.md` and `agent3-linear-writer.md` as \"Removed\" in both the prompt mapping table and Files table\n     - Updated pipeline diagram to show Orchestrator (TypeScript) handling read/write instead of agent1/agent3\n     - Updated reference architecture table to note agent1/agent3 are \"Absorbed into TypeScript orchestrator\"\n     - Updated adaptation guidelines: `\"Remove mcp__linear__* tool call references — queue reading and result writing are now handled by the TypeScript orchestrator\"`\n\n     **Issue #5 - FR-{n} feature request layer with variant subdirs:**\n     - Removed the HTML TODO comment at line 257\n     - Replaced flat `request_queue/` with `feature_requests/FR-{n}/` directory structure:\n       ```\n       feature_requests/\n         FR-1/\n           request.md              # Original user request + clarification Q&A\n           dashboard-v1/           # Variant group subdirectory\n             AGI-5.md\n           dashboard-v2/\n             AGI-8.md\n         FR-2/\n           request.md\n           AGI-11.md               # No group → lives directly in FR dir\n       ```\n     - Added `request.md` format with YAML frontmatter\n     - Added `feature_request: FR-1` field to ticket frontmatter\n     - Added `featureRequest: string` to `TaskRequest` interface\n     - Updated all path references from `request_queue/` to `feature_requests/` throughout the document\n     - Updated Integration with Existing ID Scheme to glob `feature_requests/**/AGI-*.md`\n\n     **Issue #6 - Test-writer scope (Implement + Oneshot + Validate only):**\n     - Updated Purpose: \"Worker stages that produce code (Implement, Oneshot, Validate) are followed by a test-writer step\"\n     - Updated execution flow pseudocode from `executeWorker` to `dispatchStage` with conditional test-writer\n     - Updated orchestrator integration code with `codeProducingStages` set:\n       ```typescript\n       private readonly codeProducingStages = new Set([\n         \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n       ]);\n       ```\n     - Updated Phase 5 files table to reference `dispatchStage()`\n\n4. Errors and fixes:\n   - No code errors. The issues were contradictions/gaps within the plan document itself.\n   - User feedback on Issue #1: Asked me to explain considerations rather than present options. After I explained, user pointed out no realistic scenario exists for passing only actionable tasks since the orchestrator is the only caller → confirmed Version B.\n   - User feedback on Issue #3: Corrected my assumption that Research/Spec/Plan could run locally. User intended all stages in sandboxes to avoid blocking the orchestrator from dispatching other tasks.\n   - User feedback on Issue #4: Asked me to explain whether LLM reasoning was still needed for agent1 (prioritization) and agent3 (WORK_RESULT parsing) before deciding → I explained both are deterministic, user confirmed TypeScript.\n\n5. Problem Solving:\n   - Identified 6 contradictions/gaps in the implementation plan\n   - Resolved each through targeted questions to the user\n   - Applied all resolutions as edits, then verified with grep searches that no stale references remained (`request_queue`, `executeWorker`, `loadActionableTasks`, `agent1-linear`, `agent3-linear` all cleaned up)\n\n6. All user messages:\n   - \"Re-read @IMPLEMENTATION_PLAN.md top to bottom carefully, and summarize the core agent workflow that this plan will implement in napoli-matcha. I made several independent changes to this plan and want to double check that this plan is not contradictory and is aligned to what I had in mind.\"\n   - \"Dig into all 6 issues and Ask me questions to resolve them one at a time.\"\n   - \"Explain the considerations of what filterEligible should achieve and I will use that to determine which version (A/B) i had in mind.\"\n   - \"in what scenario will someone pass only actionable tasks? since the user only passes feature requests to the spec-agent and spec-agent determines the start state of a task.\"\n   - \"before u confirm version B, clarify that all tickets (* In Progress) should never be dispatched, not just Research In Progress as you mentioned above.\"\n   - \"yes choose Version B and move on to issue #2 and the rest.\"\n   - (Issue #2 answer via tool): \"Add NeedsOneshot status\"\n   - \"I actually intended for Research/Spec/Plan to also be ran in the sandbox because running it in the Orchestrator locally will block worker agents from claiming the next non-blocking ticket in the queue right?\"\n   - (Issue #3 answer via tool): \"Yes, all stages in sandboxes\"\n   - \"Is Agent 1 still required to reason about which tickets to prioritize and claim before others? My intention was for the spec agent to do so deterministically with running IDs of tickets, but would it be more robust to use an Agent to also 'double check' this? For Agent 3, would an LLM still be useful to parse the WORK_RESULT logic from the worker agent's completed work or in the new design this is already done?\"\n   - \"ok proceed with TypeScript\"\n   - (Issue #5 answer via tool): \"Add feature request layer\"\n   - (Issue #5 follow-up via tool): \"Subdirs per variant group\"\n   - (Issue #6 answer via tool): \"Implement + Oneshot + Validate\"\n   - \"yes apply all changes to the plan\"\n\n7. Pending Tasks:\n   - None explicitly pending. All 6 issues were resolved and applied.\n\n8. Current Work:\n   All 6 resolved issues have been applied to IMPLEMENTATION_PLAN.md with 23 edits. Grep verification confirmed no stale references remain. The task was marked completed.\n\n9. Optional Next Step:\n   No explicit next step was requested. The user may want to review the updated plan or begin implementation.\n\nIf you need specific details from before compaction (like exact code snippets, error messages, or content you generated), read the full transcript at: /Users/ob1/.REDACTED.jsonl"},"isVisibleInTranscriptOnly":true,"isCompactSummary":true,"uuid":"56aa410c-779b-4276-8c69-104b6ccaa924","timestamp":"2026-02-14T10:25:09.956Z"}
{"parentUuid":"56aa410c-779b-4276-8c69-104b6ccaa924","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":"<local-command-caveat>Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.</local-command-caveat>"},"isMeta":true,"uuid":"f1dedbbb-f401-49ea-a7d5-a9c128beaec0","timestamp":"2026-02-14T10:24:06.723Z"}
{"parentUuid":"f1dedbbb-f401-49ea-a7d5-a9c128beaec0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":"<command-name>/compact</command-name>\n            <command-message>compact</command-message>\n            <command-args>changes that were made to @IMPLEMENTATION_PLAN</command-args>"},"uuid":"21259a2a-02ef-4914-a85d-db9b8994b2c2","timestamp":"2026-02-14T10:24:06.723Z"}
{"parentUuid":"21259a2a-02ef-4914-a85d-db9b8994b2c2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":"<local-command-stdout>\u001b[2mCompacted (ctrl+o to see full summary)\u001b[22m</local-command-stdout>"},"uuid":"46539241-0133-4a0a-9818-800d40802ea0","timestamp":"2026-02-14T10:25:10.056Z"}
{"parentUuid":"46539241-0133-4a0a-9818-800d40802ea0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:compact","command":"entire hooks claude-code session-start"},"parentToolUseID":"c8124305-5059-49ba-9872-20d51c43462d","toolUseID":"c8124305-5059-49ba-9872-20d51c43462d","timestamp":"2026-02-14T10:25:09.683Z","uuid":"77a0d543-efc6-4285-a70e-5bbe247881c6"}
{"type":"queue-operation","operation":"dequeue","timestamp":"2026-02-14T10:25:10.788Z","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022"}
{"type":"file-history-snapshot","messageId":"3569af24-a974-4dd9-88b7-752aa6e7ee02","snapshot":{"messageId":"3569af24-a974-4dd9-88b7-752aa6e7ee02","trackedFileBackups":{"IMPLEMENTATION_PLAN.md":{"backupFileName":"7cb5415938e35d8f@v2","version":2,"backupTime":"2026-02-14T10:23:49.453Z"}},"timestamp":"2026-02-14T10:25:11.153Z"},"isSnapshotUpdate":false}
{"parentUuid":"77a0d543-efc6-4285-a70e-5bbe247881c6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":"Clarify what the final structure of the requests_queue will be which stores the requests queues and tickets created by the spec agent"},"uuid":"3569af24-a974-4dd9-88b7-752aa6e7ee02","timestamp":"2026-02-14T10:25:10.789Z","thinkingMetadata":{"maxThinkingTokens":31999},"todos":[],"permissionMode":"acceptEdits"}
{"parentUuid":"3569af24-a974-4dd9-88b7-752aa6e7ee02","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01BtnG5fPTptUXdHNtkwRrK9","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":6077,"cache_read_input_tokens":20019,"cache_creation":{"ephemeral_5m_input_tokens":6077,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7oKZJuZkY7HtTGrGGtA","type":"assistant","uuid":"8ac92897-1194-47b5-8fd3-c9c9535a6d03","timestamp":"2026-02-14T10:25:13.266Z"}
{"parentUuid":"8ac92897-1194-47b5-8fd3-c9c9535a6d03","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01BtnG5fPTptUXdHNtkwRrK9","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to clarify the final structure of the request queue / feature requests directory as described in the updated IMPLEMENTATION_PLAN.md. Let me read the current state of the file to see what's there.","signature":"Ev4CCkYICxgCKkBB93KEPQ6GnFcvDqlvw7QEJZAOMlXqjeorEvGhfq4iRBwsUuN8omSJ/FIaYiV8vvr8Q0LjDj6eQzdQoVV19568Egz99K0B6rmRGPMKIA4aDGMlYxC9zKY2gdN/hiIwtTOLQeK8rZD4w6LymDxBhY5PsskYQQpg7B3BNMUs7nlacxfb4o2QEvRGuG6u+MYeKuUBdukxusC5FDar7rnLKNUAz/Os62yzb0TA81doROxLMq4Yt6dwqa6W2wBU0H5+9AdUVyAy1XCZPzyEOiv7WlwL8S3S4UoUZL9uHRYbmtyKKZL2bXP+339Zx39jaHFOfccYwALwcgj6ZZ9p//VOrjhOBvy2a5isLFOhenDFrIv+W0qtRk9VKhwsf8QXBcj68pa2LlrIFCc3AmRH+T61Kk0vRMDhP+6oMsq5v3JgJ9VhW6qZ5TWQ+kImCavJg4vMEWWuyycMYayTQ5P5SFARx0267npZQtaH8Q/saaPHCevxbcuZYHjr9BgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":6077,"cache_read_input_tokens":20019,"cache_creation":{"ephemeral_5m_input_tokens":6077,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7oKZJuZkY7HtTGrGGtA","type":"assistant","uuid":"7bc5e682-2932-4090-a34e-86c592292c08","timestamp":"2026-02-14T10:25:14.365Z"}
{"parentUuid":"7bc5e682-2932-4090-a34e-86c592292c08","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01BtnG5fPTptUXdHNtkwRrK9","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the current state of the plan to see how the directory structure is described."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":6077,"cache_read_input_tokens":20019,"cache_creation":{"ephemeral_5m_input_tokens":6077,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7oKZJuZkY7HtTGrGGtA","type":"assistant","uuid":"3fea414d-e050-4f92-b6a7-8ae4d89f8e72","timestamp":"2026-02-14T10:25:15.060Z"}
{"parentUuid":"3fea414d-e050-4f92-b6a7-8ae4d89f8e72","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01BtnG5fPTptUXdHNtkwRrK9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Dd8h4j55zGL2SvTGztdeM1","name":"Grep","input":{"pattern":"feature_requests|request_queue|FR-\\{|AGI-","path":"REDACTED.md","output_mode":"content","-n":true},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":6077,"cache_read_input_tokens":20019,"cache_creation":{"ephemeral_5m_input_tokens":6077,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7oKZJuZkY7HtTGrGGtA","type":"assistant","uuid":"814509e6-07aa-43eb-a3a6-3b88812f3f26","timestamp":"2026-02-14T10:25:16.429Z"}
{"parentUuid":"814509e6-07aa-43eb-a3a6-3b88812f3f26","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01Dd8h4j55zGL2SvTGztdeM1","parentToolUseID":"toolu_01Dd8h4j55zGL2SvTGztdeM1","uuid":"573ffe37-2c16-4a21-86f0-80a7ec1a8528","timestamp":"2026-02-14T10:25:16.432Z"}
{"parentUuid":"573ffe37-2c16-4a21-86f0-80a7ec1a8528","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01Dd8h4j55zGL2SvTGztdeM1","toolUseID":"toolu_01Dd8h4j55zGL2SvTGztdeM1","timestamp":"2026-02-14T10:25:16.779Z","uuid":"fad96eb5-36be-4f2a-9579-6c25dbb576d5"}
{"parentUuid":"fad96eb5-36be-4f2a-9579-6c25dbb576d5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"callback"},"parentToolUseID":"toolu_01Dd8h4j55zGL2SvTGztdeM1","toolUseID":"toolu_01Dd8h4j55zGL2SvTGztdeM1","timestamp":"2026-02-14T10:25:16.779Z","uuid":"702f3956-bff6-494b-b0dd-b4782f794567"}
{"parentUuid":"814509e6-07aa-43eb-a3a6-3b88812f3f26","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Dd8h4j55zGL2SvTGztdeM1","type":"tool_result","content":"45:> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n48:> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n49:> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n92:  │ Writes tickets to feature_requests/FR-{n}/\n95:  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n136:  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n140:  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n236:- id: AGI-{n}\n240:  depends_on: [{list of AGI-IDs this depends on, or empty}]\n244:- id: AGI-{n+1}\n285:- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n286:- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n288:After the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n291:feature_requests/\n295:      AGI-5.md\n296:      AGI-6.md\n297:      AGI-7.md\n299:      AGI-8.md\n300:      AGI-9.md\n301:      AGI-10.md\n304:    AGI-11.md               # No group → lives directly in FR dir\n327:id: AGI-8\n347:Reads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n433:1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n437:5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n452:- id: AGI-{n}\n558:id: AGI-8\n640:  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n809:**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n828:| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n838:Spec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n842:AGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\n843:AGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\n844:AGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n848:AGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\n849:AGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\n850:AGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n857:t=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n859:        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n860:        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n862:t=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n864:        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n866:        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n869:t=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n871:        → Worker E: AGI-5 validates → next_status: \"Done\"\n872:           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n873:        → Worker F: AGI-8 validates → next_status: \"Done\"\n874:           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n876:t=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n880:t=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n881:      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n883:t=5   AGI-6 validates → Done. AGI-9 validates → Done.\n884:        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n886:t=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n889:t=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n890:      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n892:t=8   AGI-7 validates → Done. AGI-10 validates → Done.\n893:        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n894:        → AGI-7 creates PR for feat/dashboard-v1\n895:        → AGI-10 creates PR for feat/dashboard-v2\n900:- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n901:- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n936:   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n937:   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)"}]},"uuid":"969d8273-d8c7-4123-9f43-f475964da979","timestamp":"2026-02-14T10:25:16.777Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"45:> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n48:> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n49:> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n92:  │ Writes tickets to feature_requests/FR-{n}/\n95:  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n136:  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n140:  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n236:- id: AGI-{n}\n240:  depends_on: [{list of AGI-IDs this depends on, or empty}]\n244:- id: AGI-{n+1}\n285:- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n286:- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n288:After the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n291:feature_requests/\n295:      AGI-5.md\n296:      AGI-6.md\n297:      AGI-7.md\n299:      AGI-8.md\n300:      AGI-9.md\n301:      AGI-10.md\n304:    AGI-11.md               # No group → lives directly in FR dir\n327:id: AGI-8\n347:Reads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n433:1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n437:5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n452:- id: AGI-{n}\n558:id: AGI-8\n640:  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n809:**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n828:| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n838:Spec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n842:AGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\n843:AGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\n844:AGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n848:AGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\n849:AGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\n850:AGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n857:t=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n859:        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n860:        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n862:t=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n864:        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n866:        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n869:t=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n871:        → Worker E: AGI-5 validates → next_status: \"Done\"\n872:           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n873:        → Worker F: AGI-8 validates → next_status: \"Done\"\n874:           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n876:t=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n880:t=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n881:      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n883:t=5   AGI-6 validates → Done. AGI-9 validates → Done.\n884:        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n886:t=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n889:t=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n890:      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n892:t=8   AGI-7 validates → Done. AGI-10 validates → Done.\n893:        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n894:        → AGI-7 creates PR for feat/dashboard-v1\n895:        → AGI-10 creates PR for feat/dashboard-v2\n900:- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n901:- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n936:   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n937:   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)","numLines":64},"sourceToolAssistantUUID":"814509e6-07aa-43eb-a3a6-3b88812f3f26"}
{"parentUuid":"969d8273-d8c7-4123-9f43-f475964da979","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01EenP78rsSE3tGMbxkggVNu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01W6qGBqiysJWtsfG7MMe1XT","name":"Read","input":{"file_path":"REDACTED.md","offset":280,"limit":80},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2059,"cache_read_input_tokens":26096,"cache_creation":{"ephemeral_5m_input_tokens":2059,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7oKyZvKcjuU59aGi1RF","type":"assistant","uuid":"6acefe18-ac26-46df-b788-cd604cfeb985","timestamp":"2026-02-14T10:25:20.117Z"}
{"parentUuid":"6acefe18-ac26-46df-b788-cd604cfeb985","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01W6qGBqiysJWtsfG7MMe1XT","parentToolUseID":"toolu_01W6qGBqiysJWtsfG7MMe1XT","uuid":"0cbd89d8-8f11-400e-99fd-4361abd1d13d","timestamp":"2026-02-14T10:25:20.120Z"}
{"parentUuid":"0cbd89d8-8f11-400e-99fd-4361abd1d13d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01W6qGBqiysJWtsfG7MMe1XT","toolUseID":"toolu_01W6qGBqiysJWtsfG7MMe1XT","timestamp":"2026-02-14T10:25:20.170Z","uuid":"ad973971-400c-4e75-b468-6798583a80b6"}
{"parentUuid":"ad973971-400c-4e75-b468-6798583a80b6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01W6qGBqiysJWtsfG7MMe1XT","toolUseID":"toolu_01W6qGBqiysJWtsfG7MMe1XT","timestamp":"2026-02-14T10:25:20.170Z","uuid":"c7e5a5e1-35d0-41cb-90f6-bad0c2c39c92"}
{"parentUuid":"6acefe18-ac26-46df-b788-cd604cfeb985","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01W6qGBqiysJWtsfG7MMe1XT","type":"tool_result","content":"   280→\n   281→### Writing Tickets\n   282→\n   283→The Spec Agent uses two ID schemes:\n   284→\n   285→- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n   286→- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n   287→\n   288→After the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n   289→\n   290→```\n   291→feature_requests/\n   292→  FR-1/\n   293→    request.md              # Original user request + clarification Q&A\n   294→    dashboard-v1/           # Variant group subdirectory\n   295→      AGI-5.md\n   296→      AGI-6.md\n   297→      AGI-7.md\n   298→    dashboard-v2/           # Variant group subdirectory\n   299→      AGI-8.md\n   300→      AGI-9.md\n   301→      AGI-10.md\n   302→  FR-2/\n   303→    request.md\n   304→    AGI-11.md               # No group → lives directly in FR dir\n   305→```\n   306→\n   307→**`request.md`** stores the original request and clarification history:\n   308→\n   309→```markdown\n   310→---\n   311→id: FR-1\n   312→created: 2026-02-14T12:00:00Z\n   313→---\n   314→\n   315→## Original Request\n   316→Build a dashboard with auth, give me 2 versions to compare\n   317→\n   318→## Clarifications\n   319→Q: What auth provider should be used?\n   320→A: JWT with our existing user table\n   321→```\n   322→\n   323→**Ticket MD files** use YAML frontmatter:\n   324→\n   325→```markdown\n   326→---\n   327→id: AGI-8\n   328→feature_request: FR-1\n   329→title: Add auth middleware\n   330→description: >-\n   331→  Create Express middleware that validates JWT tokens on protected routes.\n   332→  Success criteria: unauthorized requests return 401, valid tokens pass through.\n   333→repo: 'https://github.com/user/repo'\n   334→depends_on: []\n   335→group: dashboard-v2\n   336→variant_hint: >-\n   337→  Use a data-dense table layout. Prioritize information density over whitespace.\n   338→number_of_sandboxes: 1\n   339→status: Needs Plan\n   340→---\n   341→```\n   342→\n   343→The `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n   344→\n   345→### Integration with Existing ID Scheme\n   346→\n   347→Reads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n   348→\n   349→---\n   350→\n   351→## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n   352→\n   353→Simplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n   354→\n   355→```typescript\n   356→interface SpawnResult {\n   357→  finalOutput: string;\n   358→  cost: number;\n   359→  duration: number;"}]},"uuid":"b354efa3-0e89-4bac-aa5b-5f6d2452d60d","timestamp":"2026-02-14T10:25:20.168Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;","numLines":80,"startLine":280,"totalLines":1076}},"sourceToolAssistantUUID":"6acefe18-ac26-46df-b788-cd604cfeb985"}
{"parentUuid":"b354efa3-0e89-4bac-aa5b-5f6d2452d60d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","message":{"model":"claude-opus-4-6","id":"msg_01TMnYdMJzGtsrEETpRpZk3r","type":"message","role":"assistant","content":[{"type":"text","text":"Here's the final structure as it stands in the plan:\n\n### Directory Layout\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n### Two file types\n\n1. **`request.md`** — one per FR, stores the original user request and clarification Q&A history (frontmatter: `id: FR-1`, `created: ...`)\n\n2. **`AGI-{n}.md`** — one per ticket, YAML frontmatter with `id`, `feature_request`, `title`, `description`, `repo`, `depends_on`, `group`, `variant_hint`, `number_of_sandboxes`, `status`\n\n### How things land in the structure\n\n- **With variant groups**: tickets go into named subdirs (`dashboard-v1/`, `dashboard-v2/`) under their FR directory\n- **Without variant groups**: tickets sit directly in the FR directory (e.g., `FR-2/AGI-11.md`)\n\n### How the orchestrator discovers tickets\n\n`loadAllTasks()` globs `feature_requests/**/AGI-*.md` — this finds all tickets regardless of nesting depth (direct children or inside variant subdirs).\n\n---\n\nIs there something about this structure that feels off or that you'd like to change? A few things I could see worth clarifying:\n\n1. **Where does `feature_requests/` live?** — Is it at the repo root of napoli-matcha itself, or somewhere configurable?\n2. **Who creates the FR directory and `request.md`?** — The Spec Agent creates both during its run, correct?\n3. **Ticket body content** — The tickets currently only have YAML frontmatter with no markdown body below the `---`. Should the Spec Agent write additional context (acceptance criteria, implementation notes) in the body, or is the `description` field in frontmatter sufficient?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1062,"cache_read_input_tokens":28155,"cache_creation":{"ephemeral_5m_input_tokens":1062,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7oLDzqLkPgSo4iUXd7T","type":"assistant","uuid":"a25825f5-32c6-4608-af2d-d85f553b6585","timestamp":"2026-02-14T10:25:32.248Z"}
{"parentUuid":"a25825f5-32c6-4608-af2d-d85f553b6585","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"44ada270-f962-4363-88fe-9ab5b6a38cde","toolUseID":"44ada270-f962-4363-88fe-9ab5b6a38cde","timestamp":"2026-02-14T10:25:32.275Z","uuid":"e5a1eeb5-d9bd-47d0-8edb-661bd1d3e03d"}
{"parentUuid":"e5a1eeb5-d9bd-47d0-8edb-661bd1d3e03d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"44ada270-f962-4363-88fe-9ab5b6a38cde","toolUseID":"44ada270-f962-4363-88fe-9ab5b6a38cde","timestamp":"2026-02-14T10:25:32.276Z","uuid":"3f40d25f-790d-4499-bbe2-69044c60bfe8"}
{"parentUuid":"3f40d25f-790d-4499-bbe2-69044c60bfe8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"665369bc-1ebb-4fe8-981f-44a473807022","version":"2.1.42","gitBranch":"ralph-loop","slug":"goofy-cooking-creek","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T10:25:32.553Z","uuid":"60761d66-53dc-458c-bcdd-0a9fa296afdf","toolUseID":"44ada270-f962-4363-88fe-9ab5b6a38cde"}
