{"type":"file-history-snapshot","messageId":"c01161d1-0df8-42bf-987a-b2db745a7ad5","snapshot":{"messageId":"c01161d1-0df8-42bf-987a-b2db745a7ad5","trackedFileBackups":{},"timestamp":"2026-02-14T10:17:41.972Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:clear","command":"entire hooks claude-code session-start"},"parentToolUseID":"6cb573c6-53b9-49c9-a73f-d0a57218321b","toolUseID":"6cb573c6-53b9-49c9-a73f-d0a57218321b","timestamp":"2026-02-14T10:17:41.744Z","uuid":"ed7fbed4-44a5-4b07-b04b-efd295203218"}
{"parentUuid":"ed7fbed4-44a5-4b07-b04b-efd295203218","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"user","message":{"role":"user","content":"<local-command-caveat>Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.</local-command-caveat>"},"isMeta":true,"uuid":"e8eed39b-7ac2-4a45-a7e0-897eab38f00e","timestamp":"2026-02-14T10:17:41.972Z"}
{"parentUuid":"e8eed39b-7ac2-4a45-a7e0-897eab38f00e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"user","message":{"role":"user","content":"<command-name>/clear</command-name>\n            <command-message>clear</command-message>\n            <command-args></command-args>"},"uuid":"c01161d1-0df8-42bf-987a-b2db745a7ad5","timestamp":"2026-02-14T10:17:41.619Z"}
{"parentUuid":"c01161d1-0df8-42bf-987a-b2db745a7ad5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"user","message":{"role":"user","content":"<local-command-stdout></local-command-stdout>"},"uuid":"0666e94a-06cc-470d-940e-845c32f3cb1b","timestamp":"2026-02-14T10:17:41.972Z"}
{"type":"file-history-snapshot","messageId":"f461c5b3-5216-4a70-b7e0-fa2e5582df3f","snapshot":{"messageId":"f461c5b3-5216-4a70-b7e0-fa2e5582df3f","trackedFileBackups":{},"timestamp":"2026-02-14T10:21:51.767Z"},"isSnapshotUpdate":false}
{"parentUuid":"0666e94a-06cc-470d-940e-845c32f3cb1b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"user","message":{"role":"user","content":"Read through @IMPLEMENTATION_PLAN.md carefully top to bottom to read back the clarity of the plan is aligned with the feature enhancements I had in mind, especially since I have edited the plan indepedently multiple times"},"uuid":"f461c5b3-5216-4a70-b7e0-fa2e5582df3f","timestamp":"2026-02-14T10:21:51.357Z","thinkingMetadata":{"maxThinkingTokens":31999},"permissionMode":"default"}
{"parentUuid":"f461c5b3-5216-4a70-b7e0-fa2e5582df3f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_011oL9rDWpKR8RZMDXFwYrV5","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20947,"cache_read_input_tokens":20020,"cache_creation":{"ephemeral_5m_input_tokens":20947,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7o4rnTbbpHG2e7DmrsY","type":"assistant","uuid":"fe9c5393-517e-4f50-b3b8-3a49b7750698","timestamp":"2026-02-14T10:21:54.503Z"}
{"parentUuid":"fe9c5393-517e-4f50-b3b8-3a49b7750698","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_011oL9rDWpKR8RZMDXFwYrV5","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to read through the IMPLEMENTATION_PLAN.md carefully and assess whether the plan is clear, coherent, and internally consistent - especially since they've edited it multiple times independently. They want me to identify any inconsistencies, ambiguities, or areas where the plan might have drifted from alignment.\n\nThe file was already read via the system reminder, so I have the full contents. Let me analyze it thoroughly.\n\nLet me go through the plan systematically:\n\n## Structure Overview\n1. Reference Architecture section (Horizon CLI Agent comparison)\n2. Prompts Directory mapping\n3. Full Pipeline overview\n4. Phase 1: Spec Agent\n5. Phase 2: ClaudeSpawner\n\n\n6. Phase 3: Orchestrator refactor\n7. Phase 4: Entry Point\n8. TaskRequest Interface Update\n9. Task Status Model\n10. Variant Example\n11. Phase 5: Test-Writer Subagent\n\nNow I'm identifying the inconsistencies and issues. There's a mismatch between the phase numbering and the execution order described in the Horizon Agent Instructions - the comment suggests executing certain phases in parallel and in a specific sequence, but the actual phase numbers don't align with that execution strategy. I'm also noticing potential ambiguities around dependencies and whether all the interface updates and models are properly integrated into the phase structure.\n\nLooking at the `isActionable()` method in the orchestrator, I see it filters for statuses starting with \"Needs \" while excluding human review and decision states, which correctly captures the actionable task states like \"Needs Research\" and \"Needs Implement\". However, the \"Backlog\" status exists in the enum but never gets matched by this logic since the Spec Agent bypasses it and assigns tasks directly to their starting status. This suggests Backlog might be dead code in the automated pipeline.\n\nThe Research stage transitions align with the diagram—moving to either \"Needs Specification\", \"Needs Plan\" for complex tasks, or \"Needs Oneshot\" for simple ones. I also notice the `inProgressStatus()` helper is referenced throughout the code but not yet defined, though it's clearly meant to map \"Needs X\" states to their \"X In Progress\" equivalents. The Spec Agent's `start_status` field can be set to \"Needs Research\", \"Needs Specification\", \"Needs Plan\", or a few other values, which should align with the Task Status enum.\n\nNow I'm spotting a potential issue with the test-writer trigger logic. The plan says test-writer runs during \"Implement, Oneshot, Validate\" stages, and `codeProducingStages` lists \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\". But there's a timing problem—by the time `dispatchStage` executes, the task status has already been transitioned to its \"In Progress\" variant, so checking against the \"Needs\" versions would fail. This looks like a bug in the pseudocode flow.\n\nThere's also an ambiguity about whether `updateTaskStatus` modifies the local `task` object in memory or just the file, which affects whether the status check at line 742 sees the old or new value. Worth clarifying.\n\nI also notice `dispatchStage` appears in both Phase 3 and Phase 5 with slightly different implementations—Phase 5 has the more complete version, which makes sense since that's where it's being refined.\n\nThe worker prompt references mention needing \"LOW\" adaptation for file path updates, but the actual guidance on what to change is pretty vague. And there's a naming inconsistency where the YAML example uses `number_of_sandboxes` but the TaskRequest interface calls it `numberOfSandboxes`—this field might be leftover from the old design since the new stage-aware approach creates sandboxes per stage, not per ticket. Finally, the merge strategy runs git operations locally on the orchestrator rather than in a sandbox, which could be a concern.\n\nLooking at the status update flow, there's potential confusion between `writeResults` and `updateTaskStatus` both potentially touching the status field in the markdown file. The code writes results first, then updates status separately, but the example shows the status already updated in the frontmatter, so it's unclear whether both functions are modifying the same field or if there's a race condition here.\n\nThe glob pattern `feature_requests/**/AGI-*.md` correctly matches the nested directory structure with files like `feature_requests/FR-1/dashboard-v1/AGI-5.md`. The `request.md` files are intentionally excluded from the task loading since they serve only for provenance tracking, though I should verify if any code actually reads them. The phase ordering appears incomplete in the document.\n\nLooking at the structure, the Task Status Model and Variant sections are inserted between Phase 4 and Phase 5, which breaks the flow since the Task Status Model is referenced earlier in Phase 3. There are also two separate Files tables—one covering the general implementation and another for Phase 5 specifics that adds `SandboxQueueProcessor.ts` updates and `agent2-worker-test.md`—which could easily be overlooked. The `Backlog` status is defined in the enum but never actually used since the Spec Agent always assigns tickets to their `start_status` values, which are always \"Needs *\" statuses.\n\nThe prompt loading mechanism is vague—the Reference Architecture says Napoli should load from `prompts/` like the existing pattern, and `stagePromptMap` maps statuses to filenames, but the actual file reading and template variable interpolation isn't spelled out. Similarly, the Test-Writer prompt references template variables like `{ticket title + description}` and `{git diff main...HEAD}`, but it's unclear whether these are interpolated by the orchestrator before passing to workers or handled within `buildTestWriterPrompt()` itself.\n\nThere's also ambiguity around `runWorkerAgent` versus `runTestWriterAgent`—both are referenced but their signatures and whether they both use Daytona sandbox execution isn't documented. The HTML comment block at the top with \"HORIZON AGENT INSTRUCTIONS\" seems like meta-instructions for a different system and might confuse readers of the plan itself.\n\nLooking more closely at the `dispatchStage` code...\n\nExamining the task status mutation...\n\nActually, I see the real issue now. The `stagePrompt` parameter was already resolved back in `processQueue` when the status was still \"Needs Implement\", so that's not the problem. The bug is specifically on line 742 where I'm checking `codeProducingStages` against the mutated status instead of the original one. I need to capture the status before calling `updateTaskStatus` to fix this.","signature":"ErFOCkYICxgCKkCHewU5iOVFCKTDi+IKOs+9XMOuG1XH+V5HOBsB3wOazLzPByJ1R4HVmxxQQbbi2AOYOXsYV4o53nkdq9PIwk6rEgxn9qsIrWki+/knfZYaDMCv919ZAPST/64C+SIwkEY077NNIED9l3v08K59A2DBR6mTusPZNxMVS79Xh1oV2Z7o80DS0zoLCRzXU47VKphNDNi52Gk/Rmi0vO9hQWAu3AzuZkiFAwwguEyAaPolOz9K1hSirZnT+5Ck9sdCqlkukR0HhSr/rJUelXeQ3yX8x4o23gSH1zH2QqkM4hRw92WgE55jxhoCvMMTTNh113ACbleXSyFNtQsHfCe1rSOegH/CPOo3K2+d5wdjPgcEb/n4Dby+uDbnCCK7+hDh7WrEFt0MudnxVqSjhJm61p7y3ac6Oh7Gk1TXkN9F06hO6vazvL5Bd28D0zngzC0GQbIEWmz41x116JVVkrasJwla7U+FEFDLNrQlcl7ZHOvxIu0yGtBTXhf/cEbSlCjNXjP6m9bptvXCwYs8jK9UJgLvfVk2tu7ccfQZx1TLKHXiiYeQAD7xVrjvdyawINdxoJNYFNAvqpNp/WSeo/Xr8Ts1YMeys8tMn7b7tMjiIXCbCxT3OFYxbub2EfHPEPuIIFzsS1H8Ds950nI4QBJyIU+aYT6+oQsjr4/vPpzUUR97MXaNeUqC0kx0gneNNJwyU86b5WXUL0I6J9qBseDl6oXy0GIVntcT7mFaVEVc5u5uJ9RgzT12268ghk93hdoQ6sqqYPbFizklEL+pVzBqnKSyBP776nqlLISxbSzDijpAtXdiGB/vBpRUxnhDTZFKZEm/3LhBVabB0V9KbLUL5CzxMaNH3JQxMEmeurEaiaTafjkG+RhmNuYTdlTPp3GayGPgUQrtNjnqEEq9Ml1pb6mb8e8HlBltRrQZlRTE0fg5dSCtGvoKNYcc0vVgsvpOAKn0t90IDbd0wF4o0xACCtgzByXScnG1EV2P2qC44JJ/5+wnUp4wLxC1cCiEDtUyT5vUr9bEtaGaLO2TX4IYE76qqCeUmQUXUeUyY/4kPO0UUe4ddhUwHnH2uB+L848wYh2farFmtEOR0WHkTF9if3JxZQKs1ApolrfcEipfhIlmYzNnZi+rKANKVwdSM3YQHGm9ZhULWpdaGAk7Ysr8nfaQvU87f8E6yulZvTpY8rd6vvqhweth46tF6xSZO9UMgh2JjxEwrLwm8nFrK35BEd+ocStoIpLJLXgHPrS61m2xpjcxFMnIh0cqc/yhhzz6MsTRKhsYf5J9y8vzP1hnWjo96dVfHEsxJrnLY5hcQFtJXp6UdvHKaLffxk0OaBlvcT4AQ0bjq3K+xZjzQSsX4VQOB9f2MS6qlfTsNP81GJeWEh1sAC4ns7hjDQCzhf0ziEc2/9TUhmZgsdoAXkiuW3k1PkRmDDtZfp7q3x1ovjUTO7emjSmiWicixfCL6LPzcy8xN3sVxh5UkhOy3VJSvvfbozy2aB+OhdtJU7bdFV1k1/PFf3KRHMfRKxaxCbNnvBJjWzFxBmrrDldYpfcl7Ykvl5GZW12zuXfecTR78VI0Vr/VR1gJeuxg+5cwoJcwkeXR5FnvSAOjbHFfhettYQCLLtMw+mgYtwKITco8CrKrky2O1fWlm/0xUaZ/fmFX0n+bGHM4STX310urYlnRQ7UOzAuhhMJHdjdnSwYjiMBtosjBxxySefI3zGHk+tWiICcO2W1oKkkNNQyAgXuJ5jWoHINc6tJ2OvpnnMhI36OX/f7qMCsyQUQh7qluU+h2jZ6OwtyMvyQ9GzAHAQAvPj4tVDxSnOVVHW9hh0TKOlXCAKeuEysbpQshSivGKE2kQ8Q+UFbJOg1hMNawRmlwyA1NhlS0a3VumBanSwXImUgMo/Z0VnWOqfJQezuTgqUfdH+vCp5whe/mlFTYBnVq+IyBjztk7cdPNK9AfyvzKsp/r2m52792O82fCKKu8lp/K8oooQhHgjE9T0E7kglEQiXTD74PhhTFE3C6+fPqwhFiLuHtQM8ifUnWudaKtDqkiUYWHSVnEcpUzaqGyfjnjIXeESrwCB8m24+4VY910nJcDOrrwtmrYxgbdsNdGpWLrTtSiz9Hkl8okPbi+LHR4FPk6wC3YHsKS0S9I98WRm6GD0bkG3sCDgB6YKmcc6UvEUXyGyKIy6YYCPel2sqAD4rFyQ3MBT0QicHzF0CuypTFWBOFQW+RKqUBmD591PfdQNiU54ZPJF/3SFfNnhha0wpAXjHId1ewc65KKkg1m9PhPajYoxUi/30Od0T4VVSQU/MGFST/D5B835zic5uDNWxBEFNduyAKfjxsntaXsRMgEeDZwBZEqXik/wZcQ+vDMj6izo1gPZcDP0bKdkAGFH1kY63rG72ushW5wVSg4G1sjETx4sb6WA2at4Z8ohHQ9TCimuN4d//YP4hHIrXSmUU9D7O6G9Zr4zv4c3xoXlMjKNHN0RTPNtRCkbyabg8zofat9OiPs/MU/k0hd6MI9rcKkK+gbosGnKIV23G6mkSNB/AB1jd+Jw9B0PGeVGvAFPYJbiJP1QgaCsigYx0fII1PktO4CtKHTgJAeALmmq+gdu5L420nazv5CSHk2u8BmcQ8tEDudPIPCFF8AURAmAgteTYmi7UTcIRj54CktjdO1m5we0C4BU+ohZYITNQl9gDbIkxhDDGSAjMCJKcwFTtEMMWYJJuRQCd6hjIsbDCiO11St1kQzH++uTVLqnKwVXU0YH6aoDNPhj4VLyRZgLFpeW9i1HcamucoVdMaHHX/SC4ptMuoVvPg5EZCsmBgR4uttrv0KpioatlliORB71efpmf+cvDRtSlbqe3neURdbPAZJ+TlkO59ZtfIHmepR5QKgGZliQRLiXjmULNoL7vrkqPCX3kumBBT7oQm6NveYq1OhWfW95wL9OlLCoc58boNZsX9yd/GHrU86CvcCTIxJqhq97g3wYTpcy5FV+LntzuSgOrrloc7nzzGXdtOKpy3lENqZSP/A9N/C9JGBChY2/En26MztePl1ICzc3TcwugzJgkIAcchkB9WfxbMkEKCDOgxWehD2HqWc+0s2U9KQKFvwb37zA+0a1b5Rm3qMGgDu/oRyQiUEMkFVzr3qnAaNGIJ9Rfrr3JfZebLBBCaaN4rCtnvAC61o1aI2MJWvncAIWsnRxyFTiQcsDibHt0nBlTVcVuCpSnURkjeNhbhWMUrjPk2RmBiYzkWiWKoPGz6x52Gk8mu8c6+MhZnV4H8eZ7EVZal0kuqeA6mZ2o4nsFlCLo1E+StOISOBVN/tQA7ctlaOxLAO6aXI+vhR74NR2nyABlfOSt5W5l24srlr6xAu7NWf9qGhqn56BDoyYlmKBY7bChx5WBA7YnoUWE5AOCQ3fRdTun31rNlFQdLgdtsfoaPy1AcQJbsmLZwNkwFl6iCHoq6sMyp790umLUbSlFnl2h8ljXZVdEwTexqt/Vsl/scB8ib2BnyRAPeDLzH5pLE5IuG1jU8uJLy5xMqTmGOKVCG8SiUv+VLZFCBtFX8MsozTL2bJPuxDShnmEkFavnzrhGPlWtJNiPC9HRTw8CcLIyKfwizTvSa70LuBm0XKcAf/8AaewovDgHQSIITBnd291P6iBSKX5F7OKjiOw4X6uiKbz2MI8MImhw5F43HTIw1YJ2b6V1wMlaK5WxEbbikOXVUZN4xtmDFPsgzqmeA5tzNPfORBpH8vg/zSPLxW8qMuJcE61CwI9UmHTPcd4lsitpgFOUkapYDo2pd32cdpyROH++uxDB93ESWszUcKcZTyl5XUtRUN9D8NLa5Yzd/skFZeEu7tUDrZ+6pXOGR1zfDedBsNVzfqliNV2Yqm7Q3UW++b3OxHB1qR9lrim+NuYlHmU+LstXL1gyJjv8lBFcrZz20X5JWQYz6QcY2LVeW3D+8Kk1qL7adP5OwMXxndpLJRkqZZcyLz2r6WbQVZRLceFIHWj8bzVJ0fHBjqXJs5Nf4z95DoVP+XsEoRZ/HeAapjrNTCYwYMWkigH1Ac3RCM0OKO+I65VgFwV3vqH1cTFK7GrXzv6Ocx4MGqOMFphYs8xsddqoYfloV/GOm/z9vyW7j0ZEld6KLw72DF2lYRrNm8n2i49ZfZcnLxOV0qQMsEk7Ux1yY9Xr81ts5pv8TO4o0QHfvKtBiWSVJURgJWJ09ojwgp1M2rL9R0UdxCOFQd2+XPway6HMGN90HQEHfEp18f/GiMeRAgokC78wvtcfSsgUpVVtldMHKpgKHGfscwMSfkxgPCr1q6rBj+5buC3bO40O2JziEyQPu6GsScN5pt/F2VHEzfBHsqrd4sUEQ7T0x49X2GcBnqPdHOzYZf4lmIqyaeJRvnYXKNI86rz+vDwvL+iCoK7XbkKBYCiPEJfyRlIssnzndRqmMVDO6alwBf2eue7Skwr8GpLP1obkFaOg3+RpwnZ5BVSX8X5QH4Lc8LfS3lnVGjrpqgy0ba+ErgKcTpMlZydekTeep21HcA8tvq5iNqo43BmREXTGRzWT2lohTRNm/weIDBVpcDtUW22e/Y1jV4DZmZXr2P8as3fRvLJu59wuyAaZFqlfxESMqZzynMbUCWc0IXzxFBayjmMNCArEj/H8Fsv5nQhfnmksGh+pGcY/P7/4YutmMPxQ8nhyyFiqvi+g+mey7KYT6i3ms3wJDcb+P1UxfKig2JaAuHAhU6DM2Sc243wdZo+AeC4loWFiK3oYner3CyW69ZaTw8pimjNn2P1zs7YHGz+gecoJ4/J6UX4CuQyVYWJyPZigUBcG2MrLDcRlKlpO9LWf+1sJJWN1tfi2jSo6yzzTEnKdBM098pKNSJLpvPKHhk85oAFD+K9ahxbNZC0txDshOsWDlkeK6r13cpgNdUmuxX4gF/8cxQAdl1G7DjgHAyHieoiKEZIN8SOagr69pV7wGjSH0yzNImkR3koQq5nJvkh4a3bFuAovCkwmsLLHi5J3NM/rMykreV/1hJKSBd4z+QUj00Ii4+OghYSzSR8LahJPniY8d1UDfLxHZfhKLPDF66TvO52uZSURTdn9QG2cirgjrqcEByfTHcdegpFrjBeLOgsBkBr+HTfWiPdmxq4pCmPo62kVhD60dmlI+3+LC3ZYjCAevqHw0KesrikdlnUGLLEsJ0FYrG4vrZxSrp6AhXd0MFPtES71aBVWrIhvXoXXvE25iswQuAZO+615stg9Pxj7gNyjbCbDLOiQfdzI/MD4E/HacPAJaxLVYg84oQZS5XXedql2twO3gw4ui5MSif/lEYGlQP6JD33qpR9pLQEkSdj4X3SD3sKV6NoXXgzOtd9eyWAs32Fytn63oMja3hHLAquUPM5ENTOhflSwA1cPxzW8DMSnbPyeSXCC+i2EMJYKdWcLANaTtBdoBWpLuhIo2+LzBWcHjPBKAURCLyZzO3BNT6vZZf8EE8gi0EVea2d67Ng84d3ejkYuie8NZI5Vgike6NHxhZiaZ77CBNevFf8VdQQaCxpS/gR4XbWU/ba2vTbYuPFeyK0zNC2po6b7d+GiZFRAfETAs6DLwmbP6N7XmkSa3U64BnBjePjg+jOSxTg1/9IKjk9QCSkR+WK1XLo5ZTWp7V8napUAVXvOMyI/RoYYRTg3Zhbom8AXx36DGU1TS6OFy4SPUlWghT+lneJOfls1JDeqkylq36USro3vSLAFUaHhtZ5C4smnaRuJ2bjz4lr9Su5Mx/4JN4N/ayBuxo80qeWNl3+X1nD+YWt6yQubQeaeMpPM6hgrKH5Z7QEWfvQM1fifTuguijx3VzNkoTge2RUEwLfBs4sgeW34vUuUPzWtjTTk46ofZ+d3iKTgrnUIcodAHhmD2OEEcSgpSfXJc7e/8Tsmu1MP3RO0imUtG5zQLQg9wd1LjgXD4ACfFEVrGe231lHaH1Kf7zYtJP5ksTiK5Kq+llCF3tXO6CMBcXtwDMd3RRk8CFOPucelDbpvb/A0cqQNeswuUSGIeMybDXEPU5mNzMCxuyNAQGcc+rbhmGDCvcV31HJKI911vl/VBeGWAqoW1+57HeIbjP1gNgVRyTUU5G/7yPaLTKyDUrSdtI4T+skeANoOSZd1K8EB4OakV/+bmpohGTvH9mUadeiRFqaA0C+owemeOVQxcTAidGVGJlTqzhiOeDn+jMojVVAkO8z3KJM5+V1EnaeQoXVR70pn/C8LAstDtsrJ1V0uk9XwKO7FhnnDFcczS6DiAOjCs+t29P/LB0W+9KVPS6kuvq+7LlASOsGNtmOpuBimHwQUalwg2M8uj9i54/HQsZ8AmHxLjFcHN4V7yHUzBoy9cMBhq7auYsgy7dy/R0BYctDa2Hlgnkxze66VuEV93eXIlOWKcS24fiW40yUVorlFX3+24nYZtsM7IjQ4kdm3QIHDvwwekBoADUQuAoQK5C7j2j807yaZ4y8wp1NL6mlKXh4ZiilKRH48GujXF31+kmun95UPr0V0nZZ0Lhdz06xybLh3l/VNfJ4IDf/U59s/cJ6ts3BH7991ED69KZUNHaJG/0EcXG+Fn8iJzIq8572JwEVIRLuwb/lkJr+Qc8E+z+rfhV3V6fx9cI9TjR6DzDAxWZ688lmNYVD7YjrBnzt2Hn3fOGqWSL9oUxgRb+L8LvCa2PlG9T2lwLeKGKEGIwjIdebP3HqkrDRBTU9j1cb4SWmpvQTncihYXHTkT5rDGw4cLepCwTM0ZV1/Ne8rJFR35vuN6nHQgqmqxZn3mvc97uf/K+k+gNOKx2FoUJ8cMGp148yTb6fVZk8O/mdsol3AdlIlqLc29J3ABCuW2uDGKOzK7HrMgUUHfepqikI0K1FB7ml3tujYJI/esQhgS+k/GC1vUTuFGCmxybJQLOZzZtYZxRGgqXhLJXl7TY1MXVzmnjLuTpHHF+J97T2oyIFnVxFCsUj8FNtbfJxMAgmrVm/JICToR6QaLGUFtA7hgbs5rkfbF/Fq1kqSI7KZIS3I2kgz5x3L+gGJ6vafeC4vu9l6/DGd9Q9gFexoxX9eKnGCShqMQtldWbWTqILiMbBLRQj1ify6UWmPERZ83z4FrkUcxiSudKHIOzU114swru+tF7CVcriVjTgZgZJOZFBuFHi+4vUDjgfIDlN5MGvZWhOjLyHRWd5yaUO2K3LmrAC+N4CjuqGZyGIxoD5moy6rXPhd3mg6835BdK2VmiM3PkC1+tlXKt7TFe/lj7XEOLCTguVXwQ9mN6UDWOVIb0pFlFcGEhaY9vUmPmWe/MQwPnBidkjA50LtJBRsjtxlHzEl+iRXUoBhV+0ZRLuRRmd7h5vb3L7N1Ec9saBL7/Bwe3ct6vbQLc4Rsv001SLaHcMsfby5tm3v9dngzj/OyWGL0cxGmE92/fKYUmSmDXYXkJdqPuN32QjIutMtQjkGOG8RiU4qBLboCMPRNG6UoBZzS8jPIo4H2dV0nk8pnSgSWFz9THmxhG6iZCt/wrNv8z3QK7B6aXEVAp67xBNfaC+rC9LBidnSHmM8vc26XgRxSF5atXWTbJmUnVNmu5WOV1mm+RQdXAVaPSzQNTsu6sh1dwUN+Scwgk53C2X4CjB5e1cJOURTv3SitSKbO+A0yyJmTtSspRgfXDwOeDrdZD0zv0plquxkQmpwqGRyE4vaatnLOnS4VFtQ7kjLpPKk6QHKs+ZpNR+OffMyOGJ5boJts0JG35K/D2jkabu/KR6VhiaYeBjDe0MjiDFW7VY3+ynG3GIAL4BPcp5S6i4BpnPxxPAwQfdik/xsObcBsdAOzLJS/AOWxyZxFDASkicQ9LG0uYkU3vU1qaK2NXnNXk2cWSB6n6kXVxgQzvfpxGfAb4fFgCKzgJ71d6K8PnA8H7agWZzREqA7xO8zMcQjbvtxFQVAu+DPUPsI2hpHwZldyoomXmYf/OaE5+VrdBgHabc3w1Oc7dtUgSYzEO0jgoj6MSMrRqTJsOq2zzm6olfv1GxB2AlIAJ63fzYdvHskM5wvKH7FrurilyBD+cC8LXrPA39RSfp/PLDjSPSBCxP/4XxWFMnY8sif0CJ/QLn4vG6U/cvUZ6KI85Tm52lDsQbMSDU2bd0XthLr9QnUoa4hGDIoaRdYpl6+fnbJz1SPhyZDHLs/z0HV4AYRU2ka6Y77vA3lBKPybW3qb/NvQ0H90d4Pw31QIYPRz3+oBD5XkbI2teC4eI9hC+a1cgiq/+la7bFEnXuzVoUMnKRnFLIz0DeZ1rliMOgSMhDEv9OaJSR2O3VyeEQ7+GWeT4o7bKUSa2N8OpMutercCDYOfYpncI0vCoVfhsE+MiB/7mzbUwh3GZqWHZtZXDw1QjNLDvG9ExcGJ/kq5uMkHNeJKmCoVnD8b6kqjE6ddG7k+4S0hpu6367WEVoFkmylGC9r+8qd38ONmenJzx6xFovOJlenslib65WMhPu+u/0fi+Ia42sDM8n4wCc1aTop4onEpUh2R0dusCETupUQOQBVg9SiHnGG3GkmH6+IfU5Rlh7H66fD8cW72Qcvt/kC9FtJ4uHzRHGExhPDeLRL8j/r4qmXBbQiVxaTmT1R4FFSQYm5CXqByXkKb42uMiHyrbdvEOVXNE1k0PvjR2Teer7xGefzyn7yZDjCpUex9NfO5fYhE7ZFeyS+zeRtyI9YUODlzabfMKRrKdkObK5ccFxPodzFg8T0wy1XHRvizVxYlBY+N0EYIjNaLI84/JFh6uGuHD+pPHO9Hri4+yIPCt2jPeI6gOKBWyM40jL33kjaIw7y75C16+teXpF2MCYUTZguhUzu4tD93DUCdSWpwVR+THso+HnykWu5cjcaClNvw6mFApD2auS8vEzhNql0LB2LpQiWk0FtPU41261dg2xFYIequqwNMBvOX0kIZ20H6Dph2uv+TH9s8O3hW4UifdP0eHLceo0Y9jfu4kNj5fyNZDT6C86ohSBIY72Rqd4HY9dLJgJODdKuOamZ1jyj90Yg+3OlZMAlIdSIfkBUtILvm0La19bFpQXpW+bdWojTVhdrA1ZIg9rHTP1OD3GG7LUEH/l37q7mygpFOkl3qaRu0Kd75ajd68WSjt00yUlBauFvs3wgueP95jH3XjIHBZ4bIlqJdRGFBqpV99any7mo4vceyV0N2z+0mn35pGMQZuzHZj2JMtFlRB8yV0Wa8JAugixqNSKg1//YJxTlP48r/sMY+9/nluABr8jLudMlgQrFsZr0019k1SSUp2toGq4O2g1v0L8TnPGEC32j4sToTQasPIganZSHXX5zUbhgIzdwvnVgkFcr1SrSfkhOXTP2NVaF9MKv7aaCF4mZLyL9/CpRKwmEhpO7U0duPFzKqL02qrViyyMECKMxuoImGLsL5sDDR8H/NJ4xdOg4An28qP45jYFxCVRbww76vHIlBM/cwW5EdfYiFB60H4IQ7m4D9VxRwXCQB/qBi1jqkkde+lxOij/zKi4U3+tbY48NFPpvzJvEPytGzX2+WglF47MhSie/a1sHTE7uDEs6oK52OIi3yjeBxxyVaSFxWbhfTwLNPiVW/61B6iViyNr82qyVnOP9lhawq9jFL84mwLlOZixOpaviPft87nMjj0JKiRMgv+t9eZlG6ChSfoDR1i30hn2DgA6ucr/bmBX2mnTqAFc54qGpkws0IRqPFTEn54YO06LN0hLLmklEt0BAnI1rlYakN3/bpo1kW+fIZyyRmEjjoTVvMvPqioR/cpJZ7+wU1nm/DFQq8aLcLcYKN8FIDiT4WWdpcaXeMsbZGdTwgtO3VZFG+EDu8dpQfmcYU4F0s5k9oCz9tVK2HLq3WjCxpNiMnZDz9IrQGFBTir8vK7aRwgJybtxf+P6vbetCqjZpacK8Y0aYcSQHHDfAYo4Ut4foIqBBRx/i/p95dz3FtrOhoMfNayEXMYwfvAhDlvvw55P52BPv+Hk2K1A2I9TxqnwXjEM5ZBbDk/HjAD5HBHVdaJoBdC1o+MuNq/YwbVapQsnkx+dn0LqX+xH96J2BNagqPgAb1wLg6xEIMMDpSN/niIjM4UX/S1xifKO8R1L8nqlB2cyTxJQqxNh7H8SCdJ6dZ5rfW2vsFc6X96L8tWCPr3ZNLIAkqBbxGjUjHxVnbOGjQ00n2TIB2lJ1yROSOvk4+ZppQkjV9WkhmElXdZg+yNioBB1gfEz5/uswZziSZM2QDMmm76gF1ZrjL8aqOt+JWegy5GTTE3DBiGxZTl+UG6ZEp76OON7p0cUrNETd+EVGn64wOMZqLGZuFD5N9H1ull479mrM12DKw7+C+lTiYMh7eEXK7B0fvYaj4/VvQ+YAw0NHIf7mhzu27R+2Ibx5Q5F1DbObb+ZeaaUwLsjw7dVENReRXOSncSLZv3p+M2B/R5UgiUQk1H+QAs5KHCOJwkiIUIieQ1Xp1M5lpVQjh6lhMJsFhjsr/SvUJVioW4uU60C4qUanW2yaPKL7OGuy6L7uZwhZjqSXqgNv+JERCesbiIfeGF8jCjnh30Wf1z/PHfJr6JUiDRi5ZC06fmdiwoBC8Por+ssRmYjnZ1Bq7JX7GHLXSjsmSECU3AyIOb5Uh7nyPUx+Gd0QYyXZeLhMpQqFy5VU4W5p5aASNMwhy0d6msuGFzY9sHk6P4d2trxU1ZhnKomUlTW/1E0ipwj6125/NR9FpJ5YLb5wM7eDyNdN5Bw7mJhPh2hz6wvqWn1KxaOt06UQSIIa+ZUgfeERGzj+iLBXf/Ypk/1iy4ATAJok3InO8Ycv6jeBii9qcQMME/JZX3H//qOXbZSjfu2lKuUwjF0wBur1YyeApxDTBS4c1JAX8Dr1TQ9Yjb7XiIyvJq01d9gpJdcSnrFpm70iVrXWjJj/lyR56vpd5+6VV9fJxP6pjw2jIAHtcd4TqBFEd9ejOcSEDD7Dc7wxgIDcOSrYf17JaK7b0bNs+QjCiBWbuvKfSqK2ezcD4AwyeKRZm4HfEME5hOkN1bRLIXme0bfyFt+t4QOVm9aji/12mqyh0t1ksyAvNn9O4l+IcZylh7R9sMy6wPUgwLey5vspJJqpzguqAvm4eZ6aB3lYvgL9wxcITDYKmGUFicTU8jzbH0t3Id/rBUp24N+HCCJDMS4JzTqOnOWTgkU1gVCNNDz2ODOCykeaDIx2CJlT5tj2czvY7E/thsQGAbxwFRvO3Xullj3ZesO3WeXDwVLfxAM9EjHkHjXrI2/VKXafgKnDAeQUvPuUiOTHZO4xlhHb5BwzcQAjJ7GoKSlM8D6bg15atzujY7SrVUrSE/NrBIvyE7OEhEn6T027u+gVVi6W3E9v4NBuqrSkLjzvlNvQubCp9Pa0M15vTaZPrqb0yjTY28N5x7Y6gY+UUg0W+55ZaspKloYPBfux5ICYkPMIH5Cpez+TBrY8fXdjRNF00DXJPOF6wpBnRzcC/+fHC9P4hZzORAVff2+RmiOa53YUfSmourdFG+niKoyStt45R4krTiH57FrbopJDvxuvzlSkjDRDOgEGRCCJi+tU23vh4KDtrWwD62uJskAdCEkSGCxAgy4+XpAWn0BhfXYrQAFHnIWAywc6U+cmUu2yLLqC56qQN5UNwqsn3L9+FH3Wnj58WrVLI9JJYxL216+RICPg/aXsyAPCMKOKpmNjJ2iCoh2rdXsS0m0wQyUC+Mjhe8m+SHaVZZzF5kKsfVF6Qmi+Acr0pIijVYezuFxUjS+3pl7wGP3sXO53Cx1FmDKfCdmoZ6dx/wMJJ4cO5k1RRoAsoXariErovlVVZjqnv3SgHLNB9E6+U3E2diTkog6XWf33I9oYK/AWOwKsXkOj61bQWY2eewm4TE4SXbWMNpcsOz8dcGYaR3zsPnLzvslX9i6mAU4Ge7sh1KqY52REqIjJW7n+OJ+RVVvRRmTOT+EEbTFxhNlIQFZ6sFSmQquvKRKd/4fj3W7aH/0dFAA+8u5QZL5QtW8+pa2dF5/XW5zkN+kpBAVvK4yRN584ZTBkakbaiw/ugdZgzbms3CZ9tLI7rhRg6AVu1/aFZ9+djM0CLwQiwYcLUP+EaeY8/Jvf4LqTOtLF+ApbggPFehPXu6ld+rz25yaMv8qNSDywSkZs9gPayFXEMCVGnBYC9ubEw6Vaahbf5vPsGrvCNTqIhBpdKotaDX8QM/K/VzBTTt8lwkpXF9NPTb0uyi7icqBKj337Tx0rtqkiy04hC4YACFNfl+s6QRtYtZxbPTPer2TVhlfPcArjfAqYaCHqYfVrVJlF9JwftVfQUXjv5npp3cLhFBX5d0+dp3hR0jjoAnrPRnY/8p0+bLe9OVvFULsgAQ/oZEA8Dmfzwl8QgwarttP9JNgMvRs0JpF16dUU/XHO9O6/ijfrTnXwtTg2NEtZMAqU0/cmHPFTPHnIvbq7ph4tFn7ZrTmlmLpAj9rhq+T6HBthQEfXilBqjJuo3IiaFLym9tp78PdcorFXtCmv1c4P67wLcyDzALZckcFICDYLLfzaEn84GbfY2bFhSFnzvIfwPo2iScEAisTjbK/3aaLeoiWLNzbhAQTkJEwIEaljoQTj+sAOXaQ+SD6BtmE100ZK5mToflM/+teqYbxJi4paNVOqGmxTQn2ngLQbwN/cu5X0V4LFJdICG4B6o+1Jv1BpYYNpesjmdFPUNymQf+yYcKMqPJeJ2YYhhm07mIpbY4zdRo0FBwEvxApeMvGBZkBeSEIbsSjW2qf3ldp8fVkadeVLH+n7IyXaCTzLGzuqzIoRsDR0kL7uIeAzpr4lWcsh0Dl4iX7RoW4w4kLk9jlVqf+bktBdq+0X3Dfpa+fT6lEOLL3jMyVr5gOmnonQfG7waLpP0YBgMTPNtTn8W7mmdvz9iouHEDwhxBgu/9ooVHKWnRmwktRgmSJ+cc3lCpTF3qOIRpT5kPk+4sY1ORdKXypHPLtcGunRbg58nT8HYr3mRac0tSBeWaSs7FqS48cxOQcXSUdFaFMZwbLsrsO54PM0gKx8XoRZT/x909kOaNw0eHvQeKsDRxZjZ1F9hbwAiMM3nvyha/7hEFlulRJ8G8AQbu5uthIhnOSI3zByaizWrCONLDAnXpCuPUHwMgDooigpPkIuG8XkPb8KGYmwaa2XPWSusEsnwbl1SMt64uu9xYUFvVKXOLRATvaDqrMJVHufrdOSlZz1TmbfheLvMorLmE1Q7OspPSJhI0B1s8o3Uu1sHwOhqkPefwOk9RKeItY779eerZmYGDGmT1Y6T6SVN6lala/djUrcf0fwM62uW3SEJQNvqyz3a/axNUmkU9cRnF+mQNfMpHepv+3Di/sj0Mf5HYBXLbd+3FIgdBCc8mf+Q1r8WezrHEykRakpwljPJv5VT9ATO/cy0byg7SkEePXw/mc0vKhhaZLBin92JFducPR/Rl7EpTBgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20947,"cache_read_input_tokens":20020,"cache_creation":{"ephemeral_5m_input_tokens":20947,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7o4rnTbbpHG2e7DmrsY","type":"assistant","uuid":"a40c5ec9-57bb-40c2-91fb-8c2023833b5e","timestamp":"2026-02-14T10:22:56.197Z"}
{"parentUuid":"a40c5ec9-57bb-40c2-91fb-8c2023833b5e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_011oL9rDWpKR8RZMDXFwYrV5","type":"message","role":"assistant","content":[{"type":"text","text":"I've read through the full plan carefully. It's well-structured and the overall architecture is sound — the 3-agent → 2-component simplification (absorbing reader/writer into the orchestrator) is clean, and the stage-aware dispatch model is a good fit. Here's what I found:\n\n---\n\n## Inconsistencies & Bugs\n\n### 1. `codeProducingStages` check races with status update (Phase 5 / Phase 3 overlap)\n\nIn `dispatchStage()` (lines 737-742), the status is updated to \"In Progress\" **before** checking `codeProducingStages`:\n\n```typescript\nawait this.updateTaskStatus(task, this.inProgressStatus(task.status)); // → \"Implement In Progress\"\n// ...\nif (this.codeProducingStages.has(task.status)) // checks \"Needs Implement\" or \"Implement In Progress\"?\n```\n\nIf `updateTaskStatus` mutates `task.status` in memory, the check against `{\"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\"}` will **never match** because the status is now `\"* In Progress\"`. Need to either capture the original status or check against the in-progress variants.\n\n### 2. `writeResults` vs `updateTaskStatus` — double status write\n\nIn `processQueue()` (lines 408-409):\n```typescript\nawait this.writeResults(task, result);\nawait this.updateTaskStatus(task, result.nextStatus);\n```\n\nBut the `writeResults` example (line 559) shows the MD frontmatter with `status: Done` already set. If `writeResults` also writes the status field into frontmatter, then `updateTaskStatus` overwrites it. Either `writeResults` should **not** touch the status field, or they should be combined. Currently ambiguous.\n\n### 3. `number_of_sandboxes` — possibly vestigial\n\nThe ticket YAML example (line 337) includes `number_of_sandboxes: 1` and `TaskRequest` has `numberOfSandboxes: number` (line 638). But in the stage-aware model, the orchestrator creates **one sandbox per stage invocation** — the ticket doesn't control sandbox count. Is this field still needed? If it's for parallel sandbox workers on the same ticket, that's not described anywhere.\n\n---\n\n## Ambiguities\n\n### 4. `Backlog` status — never entered\n\nThe enum defines `Backlog` and the transition diagram shows `Backlog → Needs Research`, but:\n- The Spec Agent sets `start_status` to one of the `Needs *` statuses directly\n- `isActionable()` only matches statuses starting with `\"Needs \"`\n- No code path sets a ticket to `Backlog`\n\nIs `Backlog` reserved for manually-created tickets? Or is it dead code?\n\n### 5. Where does merge happen?\n\n`tryMerge()` (lines 582-594) runs `git fetch/checkout/rebase/merge` — but is this on the **orchestrator's local machine** or in a sandbox? Workers run in Daytona sandboxes, but the orchestrator is described as \"pure TypeScript, continuous loop.\" If the orchestrator runs locally, it needs a local clone with write access to push merged main. This is probably intentional but isn't stated explicitly.\n\n### 6. Prompt template interpolation\n\nThe test-writer prompt uses `{ticket title + description}`, `{git diff main...HEAD}`, `{true/false}`, and the worker prompts presumably also need variable injection. `buildTestWriterPrompt()` is referenced but the general mechanism for loading and interpolating prompt templates (for all stage prompts) isn't described. The Reference Architecture mentions Horizon's `src/lib/prompts.ts` — is a similar loader needed here?\n\n### 7. Sandbox lifecycle across stages\n\nThe plan says each stage gets an independent worker/sandbox (stateless). But for grouped non-first tickets, it says \"the sandbox clones the repo, then checks out the existing group branch\" (line 544). Who sets up the clone and checkout? Is that the orchestrator's responsibility before handing off to the worker, or does the worker prompt instruct Claude to do it? In Horizon, how is this handled?\n\n---\n\n## Structural / Editorial Issues\n\n### 8. Phase 5 separated from the other phases\n\nPhase 5 (Test-Writer) appears after the Variant Example section, separated by ~200 lines from Phases 1-4. It also provides a **second, updated version** of `dispatchStage()` that supersedes the Phase 3 version. Someone reading linearly might not realize Phase 3's `dispatchStage` is incomplete until they reach Phase 5.\n\n### 9. Two Files tables\n\nThe main Files table (line 910) and the Phase 5 Files table (line 1070) both update `SandboxQueueProcessor.ts`. A reader could miss Phase 5's additions. Consider consolidating.\n\n### 10. HTML comment block at top\n\nLines 1-23 contain Horizon Agent decomposition instructions. This is meta-instructions for a CI/agent system, not part of the plan itself. It could confuse human readers — consider moving to a separate file or clearly labeling it as \"meta / CI instructions.\"\n\n---\n\n## Minor Gaps\n\n### 11. `runWorkerAgent` / `runTestWriterAgent` — undefined\n\nBoth are called in `dispatchStage()` but neither signature nor behavior is described. Are they wrappers around Daytona SDK calls? Do they use `ClaudeSpawner`? (ClaudeSpawner is described as \"local Claude CLI\" for the Spec Agent only, while workers run in sandboxes.)\n\n### 12. Error handling on stage failure\n\nThe plan describes intervention statuses (`Blocked`, `Needs Human *`) but doesn't specify what happens if a worker **crashes** (exit code != 0, no WORK_RESULT output). The text mentions \"A worker crash doesn't lose progress — the ticket stays at its last In Progress status\" (line 443), but there's no retry logic or timeout described. Does the orchestrator retry? How many times? Does it eventually set an intervention status?\n\n---\n\n## What Reads Well\n\n- The dependency resolution in `filterEligible` is clean — single loader, `isActionable()` guard, simple `!== Done` check\n- The variant example (end-to-end walkthrough) is excellent for verifying the model\n- The Horizon comparison table makes the architectural delta very clear\n- The stage-skipping rules tied to Spec Agent judgment are well-reasoned\n- The WORK_RESULT contract between workers and orchestrator is well-defined\n\n---\n\n**Bottom line**: The architecture is solid and internally consistent at the high level. The main items to resolve are the status mutation race (#1), the double-write ambiguity (#2), and deciding whether `numberOfSandboxes` / `Backlog` are still needed (#3, #4). The rest are documentation clarity items that would help implementers but don't affect the design.\n\nWant me to propose edits for any of these?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":20947,"cache_read_input_tokens":20020,"cache_creation":{"ephemeral_5m_input_tokens":20947,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7o4rnTbbpHG2e7DmrsY","type":"assistant","uuid":"af077fee-af65-47b6-b2ff-96192c288640","timestamp":"2026-02-14T10:23:30.100Z"}
{"parentUuid":"af077fee-af65-47b6-b2ff-96192c288640","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"0607f00d-c34b-430e-85b7-a5e4bafef760","toolUseID":"0607f00d-c34b-430e-85b7-a5e4bafef760","timestamp":"2026-02-14T10:23:30.144Z","uuid":"7b681d1c-2aac-4082-9cae-b48d7606c8e5"}
{"parentUuid":"7b681d1c-2aac-4082-9cae-b48d7606c8e5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"0607f00d-c34b-430e-85b7-a5e4bafef760","toolUseID":"0607f00d-c34b-430e-85b7-a5e4bafef760","timestamp":"2026-02-14T10:23:30.144Z","uuid":"a911e886-aa7f-4bb8-b0c8-b3617bae55f3"}
{"parentUuid":"a911e886-aa7f-4bb8-b0c8-b3617bae55f3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T10:23:30.408Z","uuid":"fdfa4d10-fff9-40a3-956f-5f0b119a6c34","toolUseID":"0607f00d-c34b-430e-85b7-a5e4bafef760"}
{"parentUuid":"fdfa4d10-fff9-40a3-956f-5f0b119a6c34","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"system","subtype":"turn_duration","durationMs":98642,"timestamp":"2026-02-14T10:23:30.409Z","uuid":"dde9ad4c-89d1-448c-abb3-2d10fe2fc378","isMeta":false}
{"type":"file-history-snapshot","messageId":"9bf5fae2-d38c-4624-bc35-39649fdcaa00","snapshot":{"messageId":"9bf5fae2-d38c-4624-bc35-39649fdcaa00","trackedFileBackups":{},"timestamp":"2026-02-14T10:29:44.167Z"},"isSnapshotUpdate":false}
{"parentUuid":"dde9ad4c-89d1-448c-abb3-2d10fe2fc378","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"user","message":{"role":"user","content":"Solve all ambituities by asking me questions, and applying changes 1 by 1 after the issue is clarified."},"uuid":"9bf5fae2-d38c-4624-bc35-39649fdcaa00","timestamp":"2026-02-14T10:29:43.785Z","thinkingMetadata":{"maxThinkingTokens":31999},"permissionMode":"default"}
{"parentUuid":"9bf5fae2-d38c-4624-bc35-39649fdcaa00","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01MpJsEB3vfx5LQrwaaZMmnh","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":28719,"cache_read_input_tokens":16625,"cache_creation":{"ephemeral_5m_input_tokens":28719,"ephemeral_1h_input_tokens":0},"output_tokens":10,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7ofghxi42psypYHwbGe","type":"assistant","uuid":"c03e5f79-c61a-4891-9f2d-c9d71401e44f","timestamp":"2026-02-14T10:29:46.478Z"}
{"parentUuid":"c03e5f79-c61a-4891-9f2d-c9d71401e44f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01MpJsEB3vfx5LQrwaaZMmnh","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to go through each ambiguity/issue one by one, ask clarifying questions, and apply fixes after each is clarified. Let me start with the most impactful issues first.\n\nLet me start with issue #1 since it's an actual bug.","signature":"EpUDCkYICxgCKkDDRDi4frB+AdmDqguLnK2F6WmKmZE9d4JSqmrns8hL9InVxymc5MveufAbGOT/+uPnqWHofZLbQAqbBuhzWRLBEgxedf/7mqf1dXez7xAaDCCkapb+qmdRNZBG9CIwDqtDNCREOtqRJKkVkcMXmJGCdLwnro4/6n9W+ABCbuKo9PdBGnTV4x0DdJAmPtoeKvwBf6WFGWnJ5xlsB8HsJyne15h1tGPv9dnl2aU3/RxbVrCSp16w5B7WLXcYnBDSgiRFEaCStxxXcOhFWeaE5mmsLSvoivqncwknmsYhdZanBSs6vXAXb5zdaYZEvKT/qmkcLpUnc5u7N/5XRMGY1XDpBzkr0iB7YNPDXFIzl6wHl6lJ9iRLdxN8L4kFfNK4I+UXas9dh7vX8H+1FcavZDBSLBdxXSv1w2UWxzA+bydyqEB2zlLEEV81K+bLzxmHkBDQvCF7bqwMOnOSwAaRGCl9LM7V5Hx8UpSm5rm1JwaEXJhaVGMuXKfcYcmbmL13g8Wnr5E08reuHlc4TRM3GAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":28719,"cache_read_input_tokens":16625,"cache_creation":{"ephemeral_5m_input_tokens":28719,"ephemeral_1h_input_tokens":0},"output_tokens":10,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7ofghxi42psypYHwbGe","type":"assistant","uuid":"697734b7-fb8a-42b8-b629-5d3afa5868ec","timestamp":"2026-02-14T10:29:47.845Z"}
{"parentUuid":"697734b7-fb8a-42b8-b629-5d3afa5868ec","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01MpJsEB3vfx5LQrwaaZMmnh","type":"message","role":"assistant","content":[{"type":"text","text":"Let's start with **Issue #1: `codeProducingStages` check races with status update**.\n\nThe current pseudocode does:\n```typescript\nawait this.updateTaskStatus(task, this.inProgressStatus(task.status)); // mutates to \"Implement In Progress\"\n// ... run worker ...\nif (this.codeProducingStages.has(task.status)) // checks against {\"Needs Implement\", ...} — will never match\n```"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":28719,"cache_read_input_tokens":16625,"cache_creation":{"ephemeral_5m_input_tokens":28719,"ephemeral_1h_input_tokens":0},"output_tokens":10,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7ofghxi42psypYHwbGe","type":"assistant","uuid":"aeb58afe-9e6c-4401-a555-266ac5a8b20a","timestamp":"2026-02-14T10:29:49.749Z"}
{"parentUuid":"aeb58afe-9e6c-4401-a555-266ac5a8b20a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01MpJsEB3vfx5LQrwaaZMmnh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0145sfw1qDWB13nJdZUN5Pjo","name":"AskUserQuestion","input":{"questions":[{"question":"For the status mutation race in dispatchStage(), which fix do you prefer?","header":"Status race","options":[{"label":"Capture original status","description":"Save const originalStatus = task.status before the updateTaskStatus call, use originalStatus for the codeProducingStages check"},{"label":"Check in-progress variants","description":"Change codeProducingStages to {\"Implement In Progress\", \"Oneshot In Progress\", \"Validate In Progress\"} so it matches post-transition"},{"label":"Don't mutate task object","description":"updateTaskStatus only writes to the MD file, never mutates the in-memory task.status. The local object stays at \"Needs *\" for the duration of dispatchStage()"}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":28719,"cache_read_input_tokens":16625,"cache_creation":{"ephemeral_5m_input_tokens":28719,"ephemeral_1h_input_tokens":0},"output_tokens":10,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7ofghxi42psypYHwbGe","type":"assistant","uuid":"ff627f26-50c7-4f1f-a5a5-f21e0e6cdfbc","timestamp":"2026-02-14T10:29:54.521Z"}
{"parentUuid":"ff627f26-50c7-4f1f-a5a5-f21e0e6cdfbc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_0145sfw1qDWB13nJdZUN5Pjo","parentToolUseID":"toolu_0145sfw1qDWB13nJdZUN5Pjo","uuid":"8fe0b07f-9f0e-4629-946d-acf284e74204","timestamp":"2026-02-14T10:29:54.524Z"}
{"parentUuid":"ff627f26-50c7-4f1f-a5a5-f21e0e6cdfbc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). To tell you how to proceed, the user said:\nThe user wants to clarify these questions.\n    This means they may have additional information, context or questions for you.\n    Take their response into account and then reformulate the questions if appropriate.\n    Start by asking them what they would like to clarify.\n\n    Questions asked:\n- \"For the status mutation race in dispatchStage(), which fix do you prefer?\"\n  (No answer provided)","is_error":true,"tool_use_id":"toolu_0145sfw1qDWB13nJdZUN5Pjo"}]},"uuid":"a731d752-abf8-4fc6-8c32-f50ea7f6c4e6","timestamp":"2026-02-14T10:31:54.705Z","toolUseResult":"Error: The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). To tell you how to proceed, the user said:\nThe user wants to clarify these questions.\n    This means they may have additional information, context or questions for you.\n    Take their response into account and then reformulate the questions if appropriate.\n    Start by asking them what they would like to clarify.\n\n    Questions asked:\n- \"For the status mutation race in dispatchStage(), which fix do you prefer?\"\n  (No answer provided)","sourceToolAssistantUUID":"ff627f26-50c7-4f1f-a5a5-f21e0e6cdfbc"}
{"parentUuid":"a731d752-abf8-4fc6-8c32-f50ea7f6c4e6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01WoaUJDTY5FThKmk5CcQGTM","type":"message","role":"assistant","content":[{"type":"text","text":"What would you like to clarify about this issue? Happy to provide more context on any of the options or discuss a different approach entirely."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":590,"cache_read_input_tokens":45344,"cache_creation":{"ephemeral_5m_input_tokens":590,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7oqJchszotthWsVTjAZ","type":"assistant","uuid":"4548481c-b0f6-4e1a-8e81-392eae14f650","timestamp":"2026-02-14T10:31:57.532Z"}
{"parentUuid":"4548481c-b0f6-4e1a-8e81-392eae14f650","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"3029ee54-d8e7-42e0-bc5c-3dee633d1ac0","toolUseID":"3029ee54-d8e7-42e0-bc5c-3dee633d1ac0","timestamp":"2026-02-14T10:31:57.642Z","uuid":"fb1cce67-7f33-4d22-83d5-22ba08f4afdc"}
{"parentUuid":"fb1cce67-7f33-4d22-83d5-22ba08f4afdc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"3029ee54-d8e7-42e0-bc5c-3dee633d1ac0","toolUseID":"3029ee54-d8e7-42e0-bc5c-3dee633d1ac0","timestamp":"2026-02-14T10:31:57.643Z","uuid":"591ef803-3335-49e4-8f39-68b197e8e89b"}
{"parentUuid":"591ef803-3335-49e4-8f39-68b197e8e89b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T10:31:57.909Z","uuid":"95a93e65-182b-46c7-b4fb-620c179aea8a","toolUseID":"3029ee54-d8e7-42e0-bc5c-3dee633d1ac0"}
{"type":"file-history-snapshot","messageId":"99ecd3b4-ef0e-416a-aa66-04d5e7c2b4e2","snapshot":{"messageId":"99ecd3b4-ef0e-416a-aa66-04d5e7c2b4e2","trackedFileBackups":{},"timestamp":"2026-02-14T11:54:11.680Z"},"isSnapshotUpdate":false}
{"parentUuid":"95a93e65-182b-46c7-b4fb-620c179aea8a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"user","message":{"role":"user","content":"Actually by using cloud sandboxes and the orchestrator to change the state of the tickets, does it still make sense for tickets to be local, or is it better to use Linear or an external database which can safely edit the states of the tickets that continuously change while all my agents are running in sandboxes and completing tasks at different speeds"},"uuid":"99ecd3b4-ef0e-416a-aa66-04d5e7c2b4e2","timestamp":"2026-02-14T11:54:11.215Z","thinkingMetadata":{"maxThinkingTokens":31999},"permissionMode":"default"}
{"parentUuid":"99ecd3b4-ef0e-416a-aa66-04d5e7c2b4e2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01XHoYwoMbM2D2ZdLDGKjuY1","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":46056,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":46056,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7v7EQM1NiW2CZDeiYa1","type":"assistant","uuid":"c157589a-85c2-4410-a034-496317acda9a","timestamp":"2026-02-14T11:54:14.042Z"}
{"parentUuid":"c157589a-85c2-4410-a034-496317acda9a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01XHoYwoMbM2D2ZdLDGKjuY1","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"This is a great architectural question. The user is questioning whether local MD files are the right storage mechanism for ticket state, given that:\n\n1. Workers run in cloud sandboxes (Daytona) — they can't directly read/write the local `feature_requests/` directory\n2. The orchestrator needs to atomically update ticket statuses as workers complete at different speeds\n3. Multiple workers running in parallel need consistent state reads\n4. There's a risk of race conditions when reading/writing MD files concurrently\n\nLet me think about the tradeoffs:\n\n**Local MD files (current plan):**\n- Pros: Simple, no external deps, version-controlled, human-readable, works offline\n\n\n- Cons: No atomic updates, no concurrent access guarantees, sandbox workers can't read ticket state directly (they get it injected via prompt), and the orchestrator must be the single writer to avoid race conditions\n\n**Linear:**\n- Pros: Already has the API (Horizon uses it), atomic status updates, built-in UI for viewing/managing tickets, real-time state, multiple readers/writers safe\n- Cons: External dependency, API rate limits, costs money, adds complexity, and the user was trying to move AWAY from Linear (that's why napoli-matcha exists — it replaced Linear with local files)\n\n**External DB (e.g., SQLite, Postgres, Redis):**\n- Pros: Atomic transactions, concurrent access control, workers can query state directly, no rate limits\n- Cons: More infrastructure to maintain, probably overkill for what's essentially a task queue\n\nActually, I'm realizing the local MD file approach works fine given the current architecture—the orchestrator is the only process writing to state, workers just return results via stdout, so there's no concurrent write problem. The orchestrator reads all tickets, dispatches workers, collects their results, and updates the files sequentially.\n\nBut the user's concern about scaling is worth exploring. The real question is whether we're optimizing for a single orchestrator instance or planning for multiple instances, and whether we need external state management or can stay independent with local files.","signature":"EqoaCkYICxgCKkDGEJuB95ampoP+V+GBLaBQrjZqWcdm3FffJXcyNNAP7Ip3VMKPVJ6dIwnxj+V+NheuUnPXR9tjV6Sg2k7rRt+UEgztKiq9rZ9npomE3GcaDF3Oq54SrTq88jhf9yIwaCQkM1J6UF6wpYGD3R59noVCEzi9IpcScHDs13uW7ha5j4SJL6GsDwaMqUycvFeTKpEZwZ6uBAylf31mFY+lg498Y7AkhtUUviyjiBDmU1zr8yeU8jQfAxVa/riNxPNoNCgbw+3YmmezYjcPAd44mDxn+GB8ZIexXGait+8WjYmhc93lac6IswwVKmmpVYZQieVGbwT+/NIVY3UWILX7dIKPn7nHPPbr/XL3AUxFcgUpYo2sJ5zY7NLIcwq7VVOx8X9+L+roQTHofagLqh6QJ0rkJBEgkPeBhKnEcmiCxFe+pyMLK9JOv6uX8X2KtKuTBB37sRQWU2H97Y1hc0/SYuWJnYIp0qv4EB8laFotz8mADS48CvK5ktn2knYakch25gL6iQNw7PVDNWZJOTFn7jKFsPV2YDZUY9e2cJuyY4R4QnzfH3yq9yKFxY3jB5sVSB7+xEK5KyFB3R/oY6gXOip0nGv7KPLS5bQMFLoPriQ+yn7rs+L/0ed7vx9F20891oay0+rbsHRAA8NZjYQpw4Oxdl/SSBnuwJBjLhgtJOJf04rTuvAO9z1vbWFELF3Qn0Eg8jQQEW3YfwRuavcfEYjnjLdidw0c1IKxLfBoINc+gVPBJe19h81aHExU/H9AFQdCYPJOVDx0MWyvEUsmy+mLuuWBYprQJQAf6dqQ+OPDVuT1Dby3Ygd0V8JHFOA/JoQX0BrbrySWEPRrNaTef8RwwPkby92+uo/ZnBKCi9Gbw40Bbp0Z67aX/qH7+Bsa4MOmq5EyLezD9TaC4zcP5KUYgL+F4ZN7RtBU5ntPkX+MIDBy9jB2CmTZCELXlDEc97jhygW6MwSugKIpGSjoa85nXA43jH9AQW+vtQAgNOelXX9aGPlseTkAWfcsJfpYBvx8YZ25PllzReUg3/5HfgzgLmmpJ76MZKHQVo9rXqNs3Oko365dqc+mX2Rfns/p514BCvYsmKOAo3Su1ig2L7UouoDKx0fSwVSrL5mZLoCm8kYJpxm4+iEfjP3bPi1eEorD5x3CdKmeoUYDW1KKlXhpgXeWvGh04fiojYYlatJPo7k677eNvS66YAft9VhxIrKwAr8CUAeTk56NZsNpnJ5bf8MK0hHhBSHQPsYxCH/e7rfpybNJMz+7tEyBvvkGiquVh/7yzKS+BHGPRvQxbpgeMnOLgGisC97qzbw32Lu/FSTg0JCSqnsF4VfcG1CrlTeehWll2/T4pWJcG8WQnD78IjkxvoV/BoorH36+1mAFbqPxqsa/sVPRZVgPBzlEWu79S1g4dwJUM7ocOfMW4b8/kZsEJnTrhPMeNTf0qxcx4Xcqess2feHndlniKWZpklTvFLKZfZ6tOnpZmwrERgvY3+SxLi84mMziG+xGvKMF2pC3wFvhBcLUrcEntyMtGpV9YCyUfYPdGMv+Kf99EW9ymxCcVxKxNs5rLPNmHkGfxli2o6zLebVbNVQyk1u7ewgOryxqdfTwgH2ZqYG++Pa0+zXke7ZbygAup9uLAQH4E89a75kVuBIFjzZ1/fbKBLziMV6L97SYdzP8upMw9tCNaQn70prAsPRL7jWqOfuLNsoqIessIcpAwe53z0cyjQTXn8RB+qtUsQYHgWyapy7+IaTqdUFdaulxLxYDMCkogF9BcwQM6fVvxMCD5EVqf7TLcESfARBeuuwoS/5XFopE9Rbb9Mc+KJ3WpDcmTk6a1W29a9U8Cf1cxDSAmU65yXrr1OrIa8i+ccThdDieRWfK3Ty0W0pgK/jbqvM6pYv2LY9lnqSIap7o4wuwPS3R1z1iqo9ZU0IUztD6ebcEYxxvbNs5Nd6jBb9w3JxTTl7XjqvDdL1hTaB+03zESPATxjjpqK8GsAV8lfchbZUxwbcjJZxads3W1S6gTs5MALatqhL4Q/Kb4Jpo2f9y8A87unVXcBwYefdBk0saLBtEFBItEI4TgdQhPN+WFdddPe8OjMkmZgkj9qP++IUfeudyXkVJkx62h1cWdalNeSsnImfwr25S8QsJx2VO14GBq6t7bIoxx3dK7F8uVOHNr9RRC4bO4kU63pn1mF9COvNlp+Apqx7gLNfPSR1hHUAEEF4rTwShe7K0p1rRfBiN7b9/Jh1o80rPkMbKhnpq+ZHHoCvGUFBW9/D5mc8Z5FJYV13MErbs2EDoZXTEkuxeW4N8HYCeJB/BHgM1Ell+Pkj8I5A/YIYrA6+FEi/HfrU2Doh/cHqk5PbnR3L/CfheqSXr9oqe9CaUoNy12tVIN9Z058gD6pObzBtpS5Szfm2TRD51iGXHK/yo4turW0QzC+qzvgFAEVzzJ70ZBH1vl2U2RO/apCyzTjxkI1aS+1hgkYc6lY0DYNO72jBSPC9wqGI5h7IzorVVZx651PTvX5ss0ZuqTDdsAQQb3sCSmxCNlf9tDsRg3K0PMhxoWX6f/AzIMtOyc9iOMiSve+FqfepGQjVbg7zzFm66B6gFDaPeHvUsZM3JNhE5OzvZ3eOoSMhJug9oqKt1UEr4iLO/5qv3emvLYb2CQKJuifTM61OKXrg0bCkABKQgF/LeWoKSnzWTlBPoFC1nP2MBNLZRuwMOFE9hon4gxph09YM7tm8xwmL4Y4hTTVRQq4zT8F8a57scbnVewbLYkB+xHaqb4yBWZwg1tz/lPno+uvlRK9nJvdG4PGTrSuBgAZjVUL7elZbxBq3L9JmORi/qVfCRSYWGHlbAMJ5B2uB9WNMajNW8AThWfqe2mLzwZVKCcG6IPMe5eZbLmv5pr1+plsxyzcQfKtEeA095vPkSmHYsaMkH8d4HBjWfrH0TQv67HAWnLGpOyGUwVfgV5US9Oj2udgorNF2ADFrRrcvnAs01yVvPd61rUc6GgUOiyZbHCpmJ6OyLzSut9VrZ+RpnkqTBUsX9SKeYJttEddBCRA0OrNqZeobzJsi+N64LuoPYGshgiURp345kLbzvy950QgTHJk+wZrETlNf/wtPonxJFz6T30kH7hFC78y4Ifg8xL9ZO3xE5TLCDKxD/X1i8KRXO6yYLR5M0S79lhgIrC528GEnz8YIGNozkqFKth98pgqr17Vx8nONAvetzVJTD+tVMP/BV9qql5tjM3xuogroaGXs1MW85nMOjwfhUp6KDm5xtX0VEXAktULVBkPatu/lsvCOVYj+9Z+BEWdbnde+Vb5FKPX4J6R9JPkuVDQ/zCVPHGNPcefk5OfRwI98y/hgO5Wt4FCVHRn03A95iugKsNTfHDOOykP507RakUB8UdsabL/syhUVQ9qXiRBUMYCDJlk78WGZwhPRwxG890wtj17zL//NNi4YUqyiRuW9L8suDPihCKlEGp+IU6ZrmEY6Y1UYE2sGgALuNhNcgP5AjcTzkFFryLm0LX/RcFU5DqyrCvfMuyjWkFheFkniNlci/DpLBs7CaH1EFoerfiFDwA2c67RZi4OPW47ytW2c9agoZRAH0ZCvotWAltK1tWhQoNWNUWHofd879to2t0LQBX88LLjZ3r4rLPwje+jyYN/OWsSVFN66IOg990cu+TaeaV2L+Gfxph953vzIhVoRmEgpkvmXER4iauRqtUV37toPL44kkCEAqX0T6CrV8+xHv3WVz+VDvyo5aNqXgV3YjPqPbZPbvmYNdmDBZHhLlpQXSJTolWREt0XcCqdzkjBj8+5eeGCow6eTQL6QKCHnMUUqOomgyAMHZoEtKjV8WjLs09zrm2rOsHcWlt35pZfCV/7DlK5xeOmilFyWMKAF+JAJsjXss78gRoPT1npYuyclcFY9+77BToDNNO7Gj2n+wjsSpE9EqelqKcAyzv+uS8QPUwKIGMeivogF6yUx1xTBft/ZyPUeRSHHhCfZwkrsN8lRiz6EAVTN78bwXGuuMPvtqcNWgp68qwaWZ6ZzDBSwmjFE+LC9j67zD0jSS6UqcR2BNk8xdCVHMPLN0LhtkkSlMifFpJnnhhgxpKh32WD72OKEFvQolzCvtbs3cQRFs8yftRsFmLNPeTqoGSOBrOJwN66q2UDD7OjsowQfmXe+mxd7/qGE9gihhg7hKN8Pdtxdb9z2YJXfPAcWaomjyVZP7lTkOBHV7HyDtiaXlTyEjwfGxPIVjp1tKZi4V1mSXkKGA4ST1PwU5H1m1cgfn0Yp+vxTo2UzzXAP8xpTzx+yHfCqpG2fW4Iy+4+RbNVvWVBZ2wwEWuoOcaEjFdwDpE0r1U4TqkXlF4TqcgusBFHMy78U2bx3HsSVog+CGkR9v5SRm7bq9cHgq7cViQggSM1qdF0xxbzXjrILXezSiRKlCnnl0Z7RealcnT3TRyiazCx7PZOBiTxFURY9LNthJV5NRklBQ1P9v2hdId5efzN3WHO7zc4rlkhgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":46056,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":46056,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7v7EQM1NiW2CZDeiYa1","type":"assistant","uuid":"9bfdd44b-0abf-4f9a-afbc-9eb0533880e7","timestamp":"2026-02-14T11:54:32.439Z"}
{"parentUuid":"9bfdd44b-0abf-4f9a-afbc-9eb0533880e7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01XHoYwoMbM2D2ZdLDGKjuY1","type":"message","role":"assistant","content":[{"type":"text","text":"Great question — this gets at a fundamental architectural decision. Let me lay out the tradeoffs as I see them, then ask you some targeted questions.\n\n**Why local MD files still work in the current design:**\n- The orchestrator is the **single writer** — workers in sandboxes never touch ticket files. They output WORK_RESULT via stdout, and the orchestrator parses it and writes to MD.\n- No concurrent write problem exists as long as there's one orchestrator process.\n\n**Where local MD files get shaky:**\n- If you ever want **multiple orchestrator instances** (e.g., one per repo, or horizontal scaling), you get race conditions on file writes\n- No built-in UI to see ticket state at a glance — you'd have to `cat` files or build something\n- If the orchestrator runs on a cloud server (not your laptop), the `feature_requests/` dir needs to be somewhere accessible — now you're syncing via git, which adds latency and merge risk\n\n**Where Linear/external DB shines:**\n- Atomic status updates from any number of concurrent processes\n- Built-in dashboard for monitoring agent progress\n- Horizon already proved the pattern works with Linear"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":46056,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":46056,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7v7EQM1NiW2CZDeiYa1","type":"assistant","uuid":"71996a60-3bc6-4336-8c84-644639bbbc41","timestamp":"2026-02-14T11:54:38.866Z"}
{"parentUuid":"71996a60-3bc6-4336-8c84-644639bbbc41","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01XHoYwoMbM2D2ZdLDGKjuY1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017bXw1AjBzTDtLWWJfUt31i","name":"AskUserQuestion","input":{"questions":[{"question":"Will the orchestrator always be a single process, or do you want to support multiple orchestrator instances running concurrently?","header":"Concurrency","options":[{"label":"Single process","description":"One orchestrator runs at a time. It dispatches multiple sandbox workers in parallel but is itself the sole state manager."},{"label":"Multiple instances","description":"I want to be able to run multiple orchestrators (e.g., per-repo, or scaled horizontally) that share ticket state."}],"multiSelect":false},{"question":"Where will the orchestrator process itself run?","header":"Orchestrator host","options":[{"label":"My local machine","description":"I run the orchestrator on my laptop/desktop. feature_requests/ lives on my filesystem."},{"label":"Cloud server / CI","description":"The orchestrator runs on a server, VM, or CI pipeline — not my local machine."},{"label":"Either / both","description":"I want it to work in both contexts."}],"multiSelect":false},{"question":"Do you want a visual dashboard to monitor ticket progress while agents run, or is CLI/log output sufficient?","header":"Monitoring","options":[{"label":"CLI/logs are fine","description":"I'll monitor via terminal output and reading MD files directly."},{"label":"Want a dashboard","description":"I want a web UI to see ticket states, agent progress, and intervention requests in real-time. Linear gives this for free."}],"multiSelect":false},{"question":"How important is staying free of external service dependencies (Linear API, database hosting)?","header":"Dependencies","options":[{"label":"Prefer self-contained","description":"Minimize external deps. Local files or embedded DB (SQLite) preferred."},{"label":"External services OK","description":"I'm fine depending on Linear or a hosted DB if it's the better architecture."},{"label":"Linear specifically","description":"I already use Linear and want to converge with Horizon's approach."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":46056,"cache_read_input_tokens":0,"output_tokens":1567,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":46056},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7v7EQM1NiW2CZDeiYa1","type":"assistant","uuid":"10bc1d62-6e88-4386-847b-3951ba0c9b22","timestamp":"2026-02-14T11:54:50.498Z"}
{"parentUuid":"10bc1d62-6e88-4386-847b-3951ba0c9b22","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_017bXw1AjBzTDtLWWJfUt31i","parentToolUseID":"toolu_017bXw1AjBzTDtLWWJfUt31i","uuid":"291bbdb4-0f5b-41d9-ad97-f9264d275d2a","timestamp":"2026-02-14T11:54:50.502Z"}
{"parentUuid":"291bbdb4-0f5b-41d9-ad97-f9264d275d2a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_017bXw1AjBzTDtLWWJfUt31i","toolUseID":"toolu_017bXw1AjBzTDtLWWJfUt31i","timestamp":"2026-02-14T11:56:45.904Z","uuid":"9064e865-0ae5-441e-b354-c6c794402c4b"}
{"parentUuid":"10bc1d62-6e88-4386-847b-3951ba0c9b22","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Will the orchestrator always be a single process, or do you want to support multiple orchestrator instances running concurrently?\"=\"Single process\", \"Where will the orchestrator process itself run?\"=\"My local machine\", \"Do you want a visual dashboard to monitor ticket progress while agents run, or is CLI/log output sufficient?\"=\"CLI/logs are fine\", \"How important is staying free of external service dependencies (Linear API, database hosting)?\"=\"Prefer self-contained\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_017bXw1AjBzTDtLWWJfUt31i"}]},"uuid":"0df6b4fd-4604-4402-aeb7-b845c2c69ce5","timestamp":"2026-02-14T11:56:45.901Z","toolUseResult":{"questions":[{"question":"Will the orchestrator always be a single process, or do you want to support multiple orchestrator instances running concurrently?","header":"Concurrency","options":[{"label":"Single process","description":"One orchestrator runs at a time. It dispatches multiple sandbox workers in parallel but is itself the sole state manager."},{"label":"Multiple instances","description":"I want to be able to run multiple orchestrators (e.g., per-repo, or scaled horizontally) that share ticket state."}],"multiSelect":false},{"question":"Where will the orchestrator process itself run?","header":"Orchestrator host","options":[{"label":"My local machine","description":"I run the orchestrator on my laptop/desktop. feature_requests/ lives on my filesystem."},{"label":"Cloud server / CI","description":"The orchestrator runs on a server, VM, or CI pipeline — not my local machine."},{"label":"Either / both","description":"I want it to work in both contexts."}],"multiSelect":false},{"question":"Do you want a visual dashboard to monitor ticket progress while agents run, or is CLI/log output sufficient?","header":"Monitoring","options":[{"label":"CLI/logs are fine","description":"I'll monitor via terminal output and reading MD files directly."},{"label":"Want a dashboard","description":"I want a web UI to see ticket states, agent progress, and intervention requests in real-time. Linear gives this for free."}],"multiSelect":false},{"question":"How important is staying free of external service dependencies (Linear API, database hosting)?","header":"Dependencies","options":[{"label":"Prefer self-contained","description":"Minimize external deps. Local files or embedded DB (SQLite) preferred."},{"label":"External services OK","description":"I'm fine depending on Linear or a hosted DB if it's the better architecture."},{"label":"Linear specifically","description":"I already use Linear and want to converge with Horizon's approach."}],"multiSelect":false}],"answers":{"Will the orchestrator always be a single process, or do you want to support multiple orchestrator instances running concurrently?":"Single process","Where will the orchestrator process itself run?":"My local machine","Do you want a visual dashboard to monitor ticket progress while agents run, or is CLI/log output sufficient?":"CLI/logs are fine","How important is staying free of external service dependencies (Linear API, database hosting)?":"Prefer self-contained"}},"sourceToolAssistantUUID":"10bc1d62-6e88-4386-847b-3951ba0c9b22"}
{"parentUuid":"0df6b4fd-4604-4402-aeb7-b845c2c69ce5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01QDshCg1SwDT1aPP8QJrHZp","type":"message","role":"assistant","content":[{"type":"text","text":"Good — your answers confirm that **local MD files are the right call** for your setup:\n\n- Single orchestrator process = no concurrent write problem\n- Local machine = `feature_requests/` is right there on your filesystem\n- CLI/logs = no need for Linear's dashboard\n- Self-contained = no external service dependency\n\nThe architecture already handles this correctly: the orchestrator is the sole writer, workers communicate results via stdout (WORK_RESULT), and workers never touch ticket files directly. The sandboxes are stateless — all ticket context is injected into the worker prompt by the orchestrator.\n\nNo changes needed to the plan on this front. Let's move to resolving the actual ambiguities.\n\n---\n\n**Issue #1: `codeProducingStages` check races with status update**\n\nIn `dispatchStage()`, the status transitions to \"In Progress\" before the `codeProducingStages` check. Since `codeProducingStages` contains `{\"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\"}`, the check would fail after mutation."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1691,"cache_read_input_tokens":46056,"cache_creation":{"ephemeral_5m_input_tokens":1691,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vJbsEkDrRk3pUVZGBQ","type":"assistant","uuid":"1730aece-aeb2-4d9c-9010-fc9f405f9633","timestamp":"2026-02-14T11:56:53.244Z"}
{"parentUuid":"1730aece-aeb2-4d9c-9010-fc9f405f9633","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01QDshCg1SwDT1aPP8QJrHZp","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PoSmXqDWvMkqhsA7kVkyab","name":"AskUserQuestion","input":{"questions":[{"question":"For the status mutation race in dispatchStage(), which fix do you prefer?","header":"Status race","options":[{"label":"Capture original status (Recommended)","description":"Save `const originalStatus = task.status` before updateTaskStatus, use it for the codeProducingStages check. Simple, explicit, one extra line."},{"label":"Don't mutate task object","description":"updateTaskStatus only writes to the MD file, never mutates task.status in memory. The local object stays at 'Needs *' for the full dispatchStage() call."},{"label":"Check in-progress variants","description":"Change codeProducingStages to {'Implement In Progress', 'Oneshot In Progress', 'Validate In Progress'} so it matches post-transition."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1691,"cache_read_input_tokens":46056,"cache_creation":{"ephemeral_5m_input_tokens":1691,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vJbsEkDrRk3pUVZGBQ","type":"assistant","uuid":"371a194e-822d-4a06-8d05-962827de43e9","timestamp":"2026-02-14T11:56:56.132Z"}
{"parentUuid":"371a194e-822d-4a06-8d05-962827de43e9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01PoSmXqDWvMkqhsA7kVkyab","parentToolUseID":"toolu_01PoSmXqDWvMkqhsA7kVkyab","uuid":"054fb961-6219-4a37-842f-1cb462ab535b","timestamp":"2026-02-14T11:56:56.134Z"}
{"parentUuid":"054fb961-6219-4a37-842f-1cb462ab535b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01PoSmXqDWvMkqhsA7kVkyab","toolUseID":"toolu_01PoSmXqDWvMkqhsA7kVkyab","timestamp":"2026-02-14T11:58:41.487Z","uuid":"50f11408-08c2-42ab-9654-55d5d4114de5"}
{"parentUuid":"371a194e-822d-4a06-8d05-962827de43e9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"For the status mutation race in dispatchStage(), which fix do you prefer?\"=\"Capture original status (Recommended)\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01PoSmXqDWvMkqhsA7kVkyab"}]},"uuid":"a96e9a6c-5960-4053-84cc-3cfa9393a2e1","timestamp":"2026-02-14T11:58:41.483Z","toolUseResult":{"questions":[{"question":"For the status mutation race in dispatchStage(), which fix do you prefer?","header":"Status race","options":[{"label":"Capture original status (Recommended)","description":"Save `const originalStatus = task.status` before updateTaskStatus, use it for the codeProducingStages check. Simple, explicit, one extra line."},{"label":"Don't mutate task object","description":"updateTaskStatus only writes to the MD file, never mutates task.status in memory. The local object stays at 'Needs *' for the full dispatchStage() call."},{"label":"Check in-progress variants","description":"Change codeProducingStages to {'Implement In Progress', 'Oneshot In Progress', 'Validate In Progress'} so it matches post-transition."}],"multiSelect":false}],"answers":{"For the status mutation race in dispatchStage(), which fix do you prefer?":"Capture original status (Recommended)"}},"sourceToolAssistantUUID":"371a194e-822d-4a06-8d05-962827de43e9"}
{"parentUuid":"a96e9a6c-5960-4053-84cc-3cfa9393a2e1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_012a2YpmP7GH6s1PwLBxYoFu","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UwWgVnj1Gbw5LMAtxEcrhJ","name":"Read","input":{"file_path":"REDACTED.md","offset":730,"limit":25},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":669,"cache_read_input_tokens":47747,"cache_creation":{"ephemeral_5m_input_tokens":669,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vT82AzZpSjkcSJuGFq","type":"assistant","uuid":"04a50ac0-693c-423f-ad51-159451a6ccf8","timestamp":"2026-02-14T11:58:45.078Z"}
{"parentUuid":"04a50ac0-693c-423f-ad51-159451a6ccf8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01UwWgVnj1Gbw5LMAtxEcrhJ","parentToolUseID":"toolu_01UwWgVnj1Gbw5LMAtxEcrhJ","uuid":"06194ad3-8605-4ca4-8304-c001d63c154e","timestamp":"2026-02-14T11:58:45.082Z"}
{"parentUuid":"06194ad3-8605-4ca4-8304-c001d63c154e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01UwWgVnj1Gbw5LMAtxEcrhJ","toolUseID":"toolu_01UwWgVnj1Gbw5LMAtxEcrhJ","timestamp":"2026-02-14T11:58:45.136Z","uuid":"b1aea40b-332f-49eb-9120-4522a361eedf"}
{"parentUuid":"b1aea40b-332f-49eb-9120-4522a361eedf","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01UwWgVnj1Gbw5LMAtxEcrhJ","toolUseID":"toolu_01UwWgVnj1Gbw5LMAtxEcrhJ","timestamp":"2026-02-14T11:58:45.136Z","uuid":"d466060e-061a-4454-aff0-8db45b70d9fb"}
{"parentUuid":"04a50ac0-693c-423f-ad51-159451a6ccf8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UwWgVnj1Gbw5LMAtxEcrhJ","type":"tool_result","content":"   730→  \"Needs Implement\":       \"agent2-worker-implement.md\",\n   731→  \"Needs Validate\":        \"agent2-worker-validate.md\",\n   732→  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n   733→};\n   734→\n   735→async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n   736→  const sandbox = await this.createSandbox(task);\n   737→\n   738→  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n   739→  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n   740→\n   741→  // Conditionally run test-writer for code-producing stages\n   742→  let testResult: TestResult | undefined;\n   743→  if (this.codeProducingStages.has(task.status)) {\n   744→    const isTerminal = await this.isTerminal(task);\n   745→    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n   746→  }\n   747→\n   748→  return { stage: stageResult, tests: testResult };\n   749→}\n   750→```\n   751→\n   752→Key change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n   753→\n   754→### WORK_RESULT Stage Output"}]},"uuid":"af94e2c7-56c4-4dc0-8ed5-031a128995ef","timestamp":"2026-02-14T11:58:45.135Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output","numLines":25,"startLine":730,"totalLines":1076}},"sourceToolAssistantUUID":"04a50ac0-693c-423f-ad51-159451a6ccf8"}
{"parentUuid":"af94e2c7-56c4-4dc0-8ed5-031a128995ef","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01GFaVD7JywVR72hnEzzKUwh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QwVb3Q25wXaHpFJJB2iHXU","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}","new_string":"async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":527,"cache_read_input_tokens":48416,"cache_creation":{"ephemeral_5m_input_tokens":527,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vTPb41F35uhn8LDZxM","type":"assistant","uuid":"5913f588-bdab-4acd-b04f-fce8a352760e","timestamp":"2026-02-14T11:58:51.969Z"}
{"parentUuid":"5913f588-bdab-4acd-b04f-fce8a352760e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01QwVb3Q25wXaHpFJJB2iHXU","parentToolUseID":"toolu_01QwVb3Q25wXaHpFJJB2iHXU","uuid":"509ce584-4998-4576-b222-1d06a3f50c0e","timestamp":"2026-02-14T11:58:51.972Z"}
{"type":"file-history-snapshot","messageId":"5913f588-bdab-4acd-b04f-fce8a352760e","snapshot":{"messageId":"99ecd3b4-ef0e-416a-aa66-04d5e7c2b4e2","trackedFileBackups":{"IMPLEMENTATION_PLAN.md":{"backupFileName":"7cb5415938e35d8f@v1","version":1,"backupTime":"2026-02-14T11:58:59.599Z"}},"timestamp":"2026-02-14T11:54:11.680Z"},"isSnapshotUpdate":true}
{"parentUuid":"509ce584-4998-4576-b222-1d06a3f50c0e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01QwVb3Q25wXaHpFJJB2iHXU","toolUseID":"toolu_01QwVb3Q25wXaHpFJJB2iHXU","timestamp":"2026-02-14T11:58:59.606Z","uuid":"5c848054-b1a0-4991-aa7d-47737724d019"}
{"parentUuid":"5c848054-b1a0-4991-aa7d-47737724d019","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01QwVb3Q25wXaHpFJJB2iHXU","toolUseID":"toolu_01QwVb3Q25wXaHpFJJB2iHXU","timestamp":"2026-02-14T11:58:59.606Z","uuid":"1bf15b1b-d00e-4a6c-8d3a-8760a8130fa8"}
{"parentUuid":"5913f588-bdab-4acd-b04f-fce8a352760e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QwVb3Q25wXaHpFJJB2iHXU","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"87b862db-f1a5-4233-8ada-5bc76f02f67d","timestamp":"2026-02-14T11:58:59.604Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}","newString":"async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":734,"oldLines":13,"newStart":734,"newLines":14,"lines":[" "," async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {","   const sandbox = await this.createSandbox(task);","+  const originalStatus = task.status;  // capture before mutation"," ","   await this.updateTaskStatus(task, this.inProgressStatus(task.status));","   const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);"," ","   // Conditionally run test-writer for code-producing stages","   let testResult: TestResult | undefined;","-  if (this.codeProducingStages.has(task.status)) {","+  if (this.codeProducingStages.has(originalStatus)) {","     const isTerminal = await this.isTerminal(task);","     testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));","   }"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"5913f588-bdab-4acd-b04f-fce8a352760e"}
{"parentUuid":"87b862db-f1a5-4233-8ada-5bc76f02f67d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_011Gbzn27wEyE1zuAZ23BEMk","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also fix the same issue in the Phase 5 duplicate of this method."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":589,"cache_read_input_tokens":48943,"cache_creation":{"ephemeral_5m_input_tokens":589,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vUTRGFs1xofdHaG79a","type":"assistant","uuid":"e7e6c74e-6b70-4516-9e4a-0df91f9510b1","timestamp":"2026-02-14T11:59:02.366Z"}
{"parentUuid":"e7e6c74e-6b70-4516-9e4a-0df91f9510b1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_011Gbzn27wEyE1zuAZ23BEMk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VS1uSi51NVkBciFnDMLTHW","name":"Read","input":{"file_path":"REDACTED.md","offset":1024,"limit":22},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":589,"cache_read_input_tokens":48943,"cache_creation":{"ephemeral_5m_input_tokens":589,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vUTRGFs1xofdHaG79a","type":"assistant","uuid":"407283fe-51a0-4c64-8e24-7f9695f9f297","timestamp":"2026-02-14T11:59:03.136Z"}
{"parentUuid":"407283fe-51a0-4c64-8e24-7f9695f9f297","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01VS1uSi51NVkBciFnDMLTHW","parentToolUseID":"toolu_01VS1uSi51NVkBciFnDMLTHW","uuid":"43b0df9b-878c-495a-a6e0-c2ec5161e4ac","timestamp":"2026-02-14T11:59:03.140Z"}
{"parentUuid":"43b0df9b-878c-495a-a6e0-c2ec5161e4ac","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01VS1uSi51NVkBciFnDMLTHW","toolUseID":"toolu_01VS1uSi51NVkBciFnDMLTHW","timestamp":"2026-02-14T11:59:03.205Z","uuid":"40fa799a-1721-429b-8643-4dab6bcd242f"}
{"parentUuid":"40fa799a-1721-429b-8643-4dab6bcd242f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01VS1uSi51NVkBciFnDMLTHW","toolUseID":"toolu_01VS1uSi51NVkBciFnDMLTHW","timestamp":"2026-02-14T11:59:03.205Z","uuid":"0e1d4b98-a9d8-4e60-abb6-83c9dcb16f88"}
{"parentUuid":"407283fe-51a0-4c64-8e24-7f9695f9f297","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VS1uSi51NVkBciFnDMLTHW","type":"tool_result","content":"  1024→private readonly codeProducingStages = new Set([\n  1025→  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n  1026→]);\n  1027→\n  1028→private async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  1029→  const sandbox = await this.createSandbox(task);\n  1030→\n  1031→  // Step 1: Run the stage prompt\n  1032→  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n  1033→\n  1034→  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  1035→  let testResult: TestResult | undefined;\n  1036→  if (this.codeProducingStages.has(task.status)) {\n  1037→    const isTerminal = await this.isTerminal(task);\n  1038→    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  1039→    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  1040→  }\n  1041→\n  1042→  return { stage: stageResult, tests: testResult };\n  1043→}\n  1044→```\n  1045→"}]},"uuid":"374d0928-52fe-4619-94dc-f04c05c2c7fb","timestamp":"2026-02-14T11:59:03.204Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"private readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n","numLines":22,"startLine":1024,"totalLines":1077}},"sourceToolAssistantUUID":"407283fe-51a0-4c64-8e24-7f9695f9f297"}
{"parentUuid":"374d0928-52fe-4619-94dc-f04c05c2c7fb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01456i1MLtV6qTDXa73fFRtc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HZVktV2jb3pJD8peWXRRen","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"private async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}","new_string":"private async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":485,"cache_read_input_tokens":49532,"cache_creation":{"ephemeral_5m_input_tokens":485,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vUiimYr2dXzHyPH16y","type":"assistant","uuid":"a91487d1-dd6e-484f-973b-a545db73e8ad","timestamp":"2026-02-14T11:59:09.489Z"}
{"parentUuid":"a91487d1-dd6e-484f-973b-a545db73e8ad","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01HZVktV2jb3pJD8peWXRRen","parentToolUseID":"toolu_01HZVktV2jb3pJD8peWXRRen","uuid":"5dce956e-75cf-454e-9a9a-894be4e08e91","timestamp":"2026-02-14T11:59:09.491Z"}
{"parentUuid":"5dce956e-75cf-454e-9a9a-894be4e08e91","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01HZVktV2jb3pJD8peWXRRen","toolUseID":"toolu_01HZVktV2jb3pJD8peWXRRen","timestamp":"2026-02-14T11:59:09.538Z","uuid":"2e31eef9-8b29-4a11-ad35-ba822ae96f38"}
{"parentUuid":"2e31eef9-8b29-4a11-ad35-ba822ae96f38","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01HZVktV2jb3pJD8peWXRRen","toolUseID":"toolu_01HZVktV2jb3pJD8peWXRRen","timestamp":"2026-02-14T11:59:09.538Z","uuid":"6e99cb23-5af7-4c4d-91bb-8556e601ea1c"}
{"parentUuid":"a91487d1-dd6e-484f-973b-a545db73e8ad","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HZVktV2jb3pJD8peWXRRen","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"053f4d1e-2b90-4d12-9b15-d14ff05407ea","timestamp":"2026-02-14T11:59:09.537Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"private async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}","newString":"private async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n\n  // Step 1: Run the stage prompt\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(task.status)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":1027,"oldLines":13,"newStart":1027,"newLines":15,"lines":[" "," private async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {","   const sandbox = await this.createSandbox(task);","+  const originalStatus = task.status;  // capture before mutation"," ","-  // Step 1: Run the stage prompt","+  // Step 1: Transition to In Progress, then run the stage prompt","+  await this.updateTaskStatus(task, this.inProgressStatus(task.status));","   const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);"," ","   // Step 2: Test-writer (same sandbox, only for code-producing stages)","   let testResult: TestResult | undefined;","-  if (this.codeProducingStages.has(task.status)) {","+  if (this.codeProducingStages.has(originalStatus)) {","     const isTerminal = await this.isTerminal(task);","     const testPrompt = this.buildTestWriterPrompt(task, isTerminal);","     testResult = await this.runTestWriterAgent(sandbox, testPrompt);"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"a91487d1-dd6e-484f-973b-a545db73e8ad"}
{"parentUuid":"053f4d1e-2b90-4d12-9b15-d14ff05407ea","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_016NfViJqmMD7bnyYQ56ZNAb","type":"message","role":"assistant","content":[{"type":"text","text":"Issue #1 fixed in both places. Moving on.\n\n---\n\n**Issue #2: `writeResults` vs `updateTaskStatus` — double status write**\n\nIn `processQueue()`, both are called sequentially:\n```typescript\nawait this.writeResults(task, result);      // writes MD body + frontmatter?\nawait this.updateTaskStatus(task, result.nextStatus);  // writes status to frontmatter\n```\n\nBut the `writeResults` example shows `status: Done` already in the frontmatter, implying it also writes the status."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":633,"cache_read_input_tokens":50017,"cache_creation":{"ephemeral_5m_input_tokens":633,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vVBoBrnb6MBFpJUtnP","type":"assistant","uuid":"179d170d-6e8c-4de9-a0e8-1ce12931e04f","timestamp":"2026-02-14T11:59:14.512Z"}
{"parentUuid":"179d170d-6e8c-4de9-a0e8-1ce12931e04f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_016NfViJqmMD7bnyYQ56ZNAb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VGPbYeLZbPBeHBx5AGc1hJ","name":"AskUserQuestion","input":{"questions":[{"question":"Should writeResults touch the status field in frontmatter, or should status updates be exclusively handled by updateTaskStatus?","header":"Status write","options":[{"label":"writeResults skips status (Recommended)","description":"writeResults only appends the Results section to the MD body (summary, artifacts, tests). updateTaskStatus is the sole method that touches the frontmatter status field. Clean separation of concerns."},{"label":"Merge into one method","description":"Combine writeResults + updateTaskStatus into a single writeStageCompletion(task, result) that does both the body append and status update atomically."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":633,"cache_read_input_tokens":50017,"cache_creation":{"ephemeral_5m_input_tokens":633,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vVBoBrnb6MBFpJUtnP","type":"assistant","uuid":"56c9c324-736b-4c9e-a8cf-b2ded92b1b13","timestamp":"2026-02-14T11:59:18.122Z"}
{"parentUuid":"56c9c324-736b-4c9e-a8cf-b2ded92b1b13","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01VGPbYeLZbPBeHBx5AGc1hJ","parentToolUseID":"toolu_01VGPbYeLZbPBeHBx5AGc1hJ","uuid":"adb473d5-4f3a-4f3f-b799-17a787a998f2","timestamp":"2026-02-14T11:59:18.125Z"}
{"parentUuid":"adb473d5-4f3a-4f3f-b799-17a787a998f2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01VGPbYeLZbPBeHBx5AGc1hJ","toolUseID":"toolu_01VGPbYeLZbPBeHBx5AGc1hJ","timestamp":"2026-02-14T11:59:38.232Z","uuid":"9f462810-f10b-4472-b1c3-b34d18ac41a7"}
{"parentUuid":"56c9c324-736b-4c9e-a8cf-b2ded92b1b13","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Should writeResults touch the status field in frontmatter, or should status updates be exclusively handled by updateTaskStatus?\"=\"writeResults skips status (Recommended)\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01VGPbYeLZbPBeHBx5AGc1hJ"}]},"uuid":"1ed43b73-6388-4c5f-a3ed-dae785797c6d","timestamp":"2026-02-14T11:59:38.230Z","toolUseResult":{"questions":[{"question":"Should writeResults touch the status field in frontmatter, or should status updates be exclusively handled by updateTaskStatus?","header":"Status write","options":[{"label":"writeResults skips status (Recommended)","description":"writeResults only appends the Results section to the MD body (summary, artifacts, tests). updateTaskStatus is the sole method that touches the frontmatter status field. Clean separation of concerns."},{"label":"Merge into one method","description":"Combine writeResults + updateTaskStatus into a single writeStageCompletion(task, result) that does both the body append and status update atomically."}],"multiSelect":false}],"answers":{"Should writeResults touch the status field in frontmatter, or should status updates be exclusively handled by updateTaskStatus?":"writeResults skips status (Recommended)"}},"sourceToolAssistantUUID":"56c9c324-736b-4c9e-a8cf-b2ded92b1b13"}
{"parentUuid":"1ed43b73-6388-4c5f-a3ed-dae785797c6d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_015GkxsSQHEmDRJYN2AHLu9a","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01G294aYf5VyamEf3SP3M5Ko","name":"Read","input":{"file_path":"REDACTED.md","offset":553,"limit":25},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":401,"cache_read_input_tokens":50650,"cache_creation":{"ephemeral_5m_input_tokens":401,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vXJa3CdHpUzQQcn3FF","type":"assistant","uuid":"7e2e1b21-a6c9-462e-8c66-6d5a4161a3ed","timestamp":"2026-02-14T11:59:41.050Z"}
{"parentUuid":"7e2e1b21-a6c9-462e-8c66-6d5a4161a3ed","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01G294aYf5VyamEf3SP3M5Ko","parentToolUseID":"toolu_01G294aYf5VyamEf3SP3M5Ko","uuid":"d489c73d-08a9-41a6-a924-bca9467c11b9","timestamp":"2026-02-14T11:59:41.056Z"}
{"parentUuid":"d489c73d-08a9-41a6-a924-bca9467c11b9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01G294aYf5VyamEf3SP3M5Ko","toolUseID":"toolu_01G294aYf5VyamEf3SP3M5Ko","timestamp":"2026-02-14T11:59:41.118Z","uuid":"1e79f111-4d43-4371-ac89-2d59fb2c16db"}
{"parentUuid":"1e79f111-4d43-4371-ac89-2d59fb2c16db","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01G294aYf5VyamEf3SP3M5Ko","toolUseID":"toolu_01G294aYf5VyamEf3SP3M5Ko","timestamp":"2026-02-14T11:59:41.118Z","uuid":"453bb8b1-2475-409b-8e0b-76030944348f"}
{"parentUuid":"7e2e1b21-a6c9-462e-8c66-6d5a4161a3ed","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01G294aYf5VyamEf3SP3M5Ko","type":"tool_result","content":"   553→\n   554→Parses WORK_RESULT from agent output, writes structured summary to MD body:\n   555→\n   556→```markdown\n   557→---\n   558→id: AGI-8\n   559→title: Add auth middleware\n   560→status: Done\n   561→group: dashboard-v2\n   562→...\n   563→---\n   564→\n   565→## Results\n   566→\n   567→**Completed**: 2026-02-14T12:00:00Z\n   568→**Branch**: feat/dashboard-v2\n   569→\n   570→### Summary\n   571→{parsed from WORK_RESULT}\n   572→\n   573→### Artifacts\n   574→- Commit: abc1234\n   575→- PR: https://github.com/user/repo/pull/43  (only if terminal)\n   576→```\n   577→"}]},"uuid":"1f2e59a1-bf81-4dd9-94f3-caa755640b36","timestamp":"2026-02-14T11:59:41.117Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n","numLines":25,"startLine":553,"totalLines":1079}},"sourceToolAssistantUUID":"7e2e1b21-a6c9-462e-8c66-6d5a4161a3ed"}
{"parentUuid":"1f2e59a1-bf81-4dd9-94f3-caa755640b36","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01E7hW6VG3HMxof69vaGpB6z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01G1xbUzrMBNhF1jySwJ9Nkg","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"Parses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results","new_string":"Parses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":341,"cache_read_input_tokens":51051,"output_tokens":240,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":341},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7vXWsi7PPxKSJ9ftygw","type":"assistant","uuid":"fb65cdb3-3d11-417a-9449-cbd9a39abf39","timestamp":"2026-02-14T11:59:45.381Z"}
{"parentUuid":"fb65cdb3-3d11-417a-9449-cbd9a39abf39","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01G1xbUzrMBNhF1jySwJ9Nkg","parentToolUseID":"toolu_01G1xbUzrMBNhF1jySwJ9Nkg","uuid":"52684fc0-c22c-47a4-8a57-cfecd6f32c21","timestamp":"2026-02-14T11:59:45.384Z"}
{"parentUuid":"52684fc0-c22c-47a4-8a57-cfecd6f32c21","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01G1xbUzrMBNhF1jySwJ9Nkg","toolUseID":"toolu_01G1xbUzrMBNhF1jySwJ9Nkg","timestamp":"2026-02-14T11:59:45.443Z","uuid":"0b69ee57-7d27-415f-80ac-7b4a03fca38c"}
{"parentUuid":"0b69ee57-7d27-415f-80ac-7b4a03fca38c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01G1xbUzrMBNhF1jySwJ9Nkg","toolUseID":"toolu_01G1xbUzrMBNhF1jySwJ9Nkg","timestamp":"2026-02-14T11:59:45.443Z","uuid":"ab1f0c26-7267-48db-b5d2-b1cdeded1884"}
{"parentUuid":"fb65cdb3-3d11-417a-9449-cbd9a39abf39","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01G1xbUzrMBNhF1jySwJ9Nkg","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"fd823b43-f922-47ed-a8cf-506c92d2f95a","timestamp":"2026-02-14T11:59:45.442Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"Parses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results","newString":"Parses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, writes structured summary to MD body:\n\n```markdown\n---\nid: AGI-8\ntitle: Add auth middleware\nstatus: Done\ngroup: dashboard-v2\n...\n---\n\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":551,"oldLines":17,"newStart":551,"newLines":9,"lines":[" "," ### `writeResults(task, result)` — Update MD File"," ","-Parses WORK_RESULT from agent output, writes structured summary to MD body:","+Parses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`."," "," ```markdown","----","-id: AGI-8","-title: Add auth middleware","-status: Done","-group: dashboard-v2","-...","----","-"," ## Results"," "," **Completed**: 2026-02-14T12:00:00Z"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"fb65cdb3-3d11-417a-9449-cbd9a39abf39"}
{"parentUuid":"fd823b43-f922-47ed-a8cf-506c92d2f95a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01FAFn6YT2JmEXSPZht8vn8v","type":"message","role":"assistant","content":[{"type":"text","text":"Issue #2 fixed. Moving on.\n\n---\n\n**Issue #3: `number_of_sandboxes` — possibly vestigial**\n\nThe `TaskRequest` interface has `numberOfSandboxes: number` and the ticket YAML example includes `number_of_sandboxes: 1`. But in the stage-aware model, the orchestrator creates one sandbox per stage invocation — the ticket doesn't control this."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":285,"cache_read_input_tokens":51392,"cache_creation":{"ephemeral_5m_input_tokens":285,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vXqJya7u2hTJpYGGL4","type":"assistant","uuid":"78fc2568-4ca7-46a6-8f4b-daf756362072","timestamp":"2026-02-14T11:59:49.788Z"}
{"parentUuid":"78fc2568-4ca7-46a6-8f4b-daf756362072","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01FAFn6YT2JmEXSPZht8vn8v","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019JFubTNbX4S5CR4umXZznd","name":"AskUserQuestion","input":{"questions":[{"question":"Is number_of_sandboxes still needed? In the stage-aware model, each stage dispatch creates exactly one sandbox.","header":"Sandbox count","options":[{"label":"Remove it (Recommended)","description":"It's vestigial from the old batch model. Each stage = one sandbox, controlled by the orchestrator, not the ticket."},{"label":"Keep it","description":"I have a use case for tickets requesting multiple parallel sandboxes for the same stage (e.g., parallel implementation attempts)."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":285,"cache_read_input_tokens":51392,"output_tokens":279,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":285},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7vXqJya7u2hTJpYGGL4","type":"assistant","uuid":"b12a8dd0-6902-4f52-9382-8dce19d66aa7","timestamp":"2026-02-14T11:59:52.346Z"}
{"parentUuid":"b12a8dd0-6902-4f52-9382-8dce19d66aa7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_019JFubTNbX4S5CR4umXZznd","parentToolUseID":"toolu_019JFubTNbX4S5CR4umXZznd","uuid":"a53a2788-f5d7-4743-b8aa-73f744388776","timestamp":"2026-02-14T11:59:52.349Z"}
{"parentUuid":"a53a2788-f5d7-4743-b8aa-73f744388776","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_019JFubTNbX4S5CR4umXZznd","toolUseID":"toolu_019JFubTNbX4S5CR4umXZznd","timestamp":"2026-02-14T12:00:21.837Z","uuid":"13cfbdc6-1723-444a-bf32-abb7d7427909"}
{"parentUuid":"b12a8dd0-6902-4f52-9382-8dce19d66aa7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Is number_of_sandboxes still needed? In the stage-aware model, each stage dispatch creates exactly one sandbox.\"=\"Remove it (Recommended)\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_019JFubTNbX4S5CR4umXZznd"}]},"uuid":"2ff06ebe-535e-4b81-a5b4-e749b11ea913","timestamp":"2026-02-14T12:00:21.833Z","toolUseResult":{"questions":[{"question":"Is number_of_sandboxes still needed? In the stage-aware model, each stage dispatch creates exactly one sandbox.","header":"Sandbox count","options":[{"label":"Remove it (Recommended)","description":"It's vestigial from the old batch model. Each stage = one sandbox, controlled by the orchestrator, not the ticket."},{"label":"Keep it","description":"I have a use case for tickets requesting multiple parallel sandboxes for the same stage (e.g., parallel implementation attempts)."}],"multiSelect":false}],"answers":{"Is number_of_sandboxes still needed? In the stage-aware model, each stage dispatch creates exactly one sandbox.":"Remove it (Recommended)"}},"sourceToolAssistantUUID":"b12a8dd0-6902-4f52-9382-8dce19d66aa7"}
{"parentUuid":"2ff06ebe-535e-4b81-a5b4-e749b11ea913","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01KAua1xHgMXQG1in85zXKkG","type":"message","role":"assistant","content":[{"type":"text","text":"I need to remove it from three places: the `TaskRequest` interface, the ticket YAML example, and make sure there are no other references."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":454,"cache_read_input_tokens":51677,"cache_creation":{"ephemeral_5m_input_tokens":454,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vaX2ibWNmM8VgksCqo","type":"assistant","uuid":"1852d63d-3cf8-44e5-becc-f59b23fdadb7","timestamp":"2026-02-14T12:00:25.105Z"}
{"parentUuid":"1852d63d-3cf8-44e5-becc-f59b23fdadb7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01KAua1xHgMXQG1in85zXKkG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013nQLCQNgrPZ1f3W5YCGn3K","name":"Grep","input":{"pattern":"number_of_sandboxes|numberOfSandboxes","path":"REDACTED.md","output_mode":"content"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":454,"cache_read_input_tokens":51677,"cache_creation":{"ephemeral_5m_input_tokens":454,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vaX2ibWNmM8VgksCqo","type":"assistant","uuid":"041dc990-99b8-404c-8e6c-03faa768ef4e","timestamp":"2026-02-14T12:00:25.999Z"}
{"parentUuid":"041dc990-99b8-404c-8e6c-03faa768ef4e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_013nQLCQNgrPZ1f3W5YCGn3K","parentToolUseID":"toolu_013nQLCQNgrPZ1f3W5YCGn3K","uuid":"920ea70b-9276-4952-b52f-de5768ee4bca","timestamp":"2026-02-14T12:00:26.004Z"}
{"parentUuid":"920ea70b-9276-4952-b52f-de5768ee4bca","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_013nQLCQNgrPZ1f3W5YCGn3K","toolUseID":"toolu_013nQLCQNgrPZ1f3W5YCGn3K","timestamp":"2026-02-14T12:00:26.347Z","uuid":"9802cf5c-57e0-48b9-918b-a3dce42638cf"}
{"parentUuid":"9802cf5c-57e0-48b9-918b-a3dce42638cf","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"callback"},"parentToolUseID":"toolu_013nQLCQNgrPZ1f3W5YCGn3K","toolUseID":"toolu_013nQLCQNgrPZ1f3W5YCGn3K","timestamp":"2026-02-14T12:00:26.348Z","uuid":"69dc0274-b29e-4aca-9d3f-7860179f7a65"}
{"parentUuid":"041dc990-99b8-404c-8e6c-03faa768ef4e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013nQLCQNgrPZ1f3W5YCGn3K","type":"tool_result","content":"338:number_of_sandboxes: 1\n631:  numberOfSandboxes: number;"}]},"uuid":"bc0defcb-027e-44d8-bcd7-7aabe1d7d2cc","timestamp":"2026-02-14T12:00:26.345Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"338:number_of_sandboxes: 1\n631:  numberOfSandboxes: number;","numLines":2},"sourceToolAssistantUUID":"041dc990-99b8-404c-8e6c-03faa768ef4e"}
{"parentUuid":"bc0defcb-027e-44d8-bcd7-7aabe1d7d2cc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01MS6FTsSK26KG6oNKMCnGPJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UzzSJFnxD9y9P3BxrfaFod","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"number_of_sandboxes: 1\nstatus: Needs Plan","new_string":"status: Needs Plan"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":193,"cache_read_input_tokens":52131,"cache_creation":{"ephemeral_5m_input_tokens":193,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7varFrum4WyeoniEgPF","type":"assistant","uuid":"90abdb82-827b-4d30-9186-516c34163850","timestamp":"2026-02-14T12:00:29.634Z"}
{"parentUuid":"90abdb82-827b-4d30-9186-516c34163850","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01UzzSJFnxD9y9P3BxrfaFod","parentToolUseID":"toolu_01UzzSJFnxD9y9P3BxrfaFod","uuid":"3ddae78c-19c7-4bf2-acff-6b164b854c75","timestamp":"2026-02-14T12:00:29.637Z"}
{"parentUuid":"3ddae78c-19c7-4bf2-acff-6b164b854c75","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01UzzSJFnxD9y9P3BxrfaFod","toolUseID":"toolu_01UzzSJFnxD9y9P3BxrfaFod","timestamp":"2026-02-14T12:00:29.701Z","uuid":"23ad3a31-0c42-4b48-9c1a-c48ecdb3d2ac"}
{"parentUuid":"23ad3a31-0c42-4b48-9c1a-c48ecdb3d2ac","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01UzzSJFnxD9y9P3BxrfaFod","toolUseID":"toolu_01UzzSJFnxD9y9P3BxrfaFod","timestamp":"2026-02-14T12:00:29.701Z","uuid":"96490682-5b12-44ca-9710-dbe1ecb64018"}
{"parentUuid":"90abdb82-827b-4d30-9186-516c34163850","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UzzSJFnxD9y9P3BxrfaFod","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"65262e59-d3bc-4e73-bd18-c329b78d1f68","timestamp":"2026-02-14T12:00:29.700Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"number_of_sandboxes: 1\nstatus: Needs Plan","newString":"status: Needs Plan","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nnumber_of_sandboxes: 1\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":335,"oldLines":7,"newStart":335,"newLines":6,"lines":[" group: dashboard-v2"," variant_hint: >-","   Use a data-dense table layout. Prioritize information density over whitespace.","-number_of_sandboxes: 1"," status: Needs Plan"," ---"," ```"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"90abdb82-827b-4d30-9186-516c34163850"}
{"parentUuid":"65262e59-d3bc-4e73-bd18-c329b78d1f68","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_019WqvPCgtMT5gSQCidhBcFA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Czdz9dm5AWEwvNF3rDxq2a","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"  numberOfSandboxes: number;\n  dependsOn: string[];","new_string":"  dependsOn: string[];"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":200,"cache_read_input_tokens":52324,"cache_creation":{"ephemeral_5m_input_tokens":200,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vb6X7LW59YzP9LsmuP","type":"assistant","uuid":"d90a4ef0-6562-4438-a84d-db1f81a8b9f2","timestamp":"2026-02-14T12:00:32.814Z"}
{"parentUuid":"d90a4ef0-6562-4438-a84d-db1f81a8b9f2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01Czdz9dm5AWEwvNF3rDxq2a","parentToolUseID":"toolu_01Czdz9dm5AWEwvNF3rDxq2a","uuid":"75222b6c-77a1-43c4-8608-8a4b6f14ec92","timestamp":"2026-02-14T12:00:32.817Z"}
{"parentUuid":"75222b6c-77a1-43c4-8608-8a4b6f14ec92","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01Czdz9dm5AWEwvNF3rDxq2a","toolUseID":"toolu_01Czdz9dm5AWEwvNF3rDxq2a","timestamp":"2026-02-14T12:00:32.875Z","uuid":"0f822883-9558-474d-822e-34f42f67340a"}
{"parentUuid":"0f822883-9558-474d-822e-34f42f67340a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01Czdz9dm5AWEwvNF3rDxq2a","toolUseID":"toolu_01Czdz9dm5AWEwvNF3rDxq2a","timestamp":"2026-02-14T12:00:32.875Z","uuid":"306ec753-2c98-4f50-9bda-168466880950"}
{"parentUuid":"d90a4ef0-6562-4438-a84d-db1f81a8b9f2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Czdz9dm5AWEwvNF3rDxq2a","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"c3052485-045c-46f1-afe9-cfdd9e25171e","timestamp":"2026-02-14T12:00:32.874Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"  numberOfSandboxes: number;\n  dependsOn: string[];","newString":"  dependsOn: string[];","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  numberOfSandboxes: number;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":627,"oldLines":7,"newStart":627,"newLines":6,"lines":["   title: string;","   description: string;","   repo: string;","-  numberOfSandboxes: number;","   dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]","   group?: string;            // \"dashboard-v1\" — shared branch for variant chain","   variantHint?: string;      // design direction for this variant"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"d90a4ef0-6562-4438-a84d-db1f81a8b9f2"}
{"parentUuid":"c3052485-045c-46f1-afe9-cfdd9e25171e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01VeJwjfq7GybfqDV5XVZueh","type":"message","role":"assistant","content":[{"type":"text","text":"Issue #3 fixed. Moving on.\n\n---\n\n**Issue #4: `Backlog` status — never entered**\n\nThe `TaskStatus` enum defines `Backlog` and the transition diagram shows `Backlog → Needs Research`, but no code path ever sets a ticket to `Backlog`. The Spec Agent sets `start_status` directly to one of the `Needs *` statuses, and `isActionable()` only matches `\"Needs \"` prefixed statuses."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":203,"cache_read_input_tokens":52524,"cache_creation":{"ephemeral_5m_input_tokens":203,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vbL6BZ9P6GwxdSme3A","type":"assistant","uuid":"b2803382-e6af-467b-b72f-35661da09f56","timestamp":"2026-02-14T12:00:37.972Z"}
{"parentUuid":"b2803382-e6af-467b-b72f-35661da09f56","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01VeJwjfq7GybfqDV5XVZueh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KW1iELpLEEz2uFBr6Mi5ZM","name":"AskUserQuestion","input":{"questions":[{"question":"Is the Backlog status needed? No code path currently creates tickets in Backlog state.","header":"Backlog status","options":[{"label":"Remove it (Recommended)","description":"The Spec Agent always sets a specific start_status (Needs Research/Specification/Plan/Implement). Backlog is dead code."},{"label":"Keep for manual use","description":"I want Backlog as a 'parking lot' for tickets I create manually that aren't ready for the pipeline yet. I'd manually edit the status to a Needs* state when ready."},{"label":"Make it the default","description":"Spec Agent should write all tickets as Backlog, and a separate triage step (or manual action) moves them to their start_status."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":203,"cache_read_input_tokens":52524,"output_tokens":357,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":203},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7vbL6BZ9P6GwxdSme3A","type":"assistant","uuid":"51006f91-d8b9-48e1-99ad-d8ddf7967168","timestamp":"2026-02-14T12:00:42.315Z"}
{"parentUuid":"51006f91-d8b9-48e1-99ad-d8ddf7967168","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01KW1iELpLEEz2uFBr6Mi5ZM","parentToolUseID":"toolu_01KW1iELpLEEz2uFBr6Mi5ZM","uuid":"313a2954-1ae6-40bf-a163-e01b8274e915","timestamp":"2026-02-14T12:00:42.321Z"}
{"parentUuid":"313a2954-1ae6-40bf-a163-e01b8274e915","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01KW1iELpLEEz2uFBr6Mi5ZM","toolUseID":"toolu_01KW1iELpLEEz2uFBr6Mi5ZM","timestamp":"2026-02-14T12:00:48.050Z","uuid":"4b88f4ed-92d0-4597-8525-4e7798151938"}
{"parentUuid":"51006f91-d8b9-48e1-99ad-d8ddf7967168","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Is the Backlog status needed? No code path currently creates tickets in Backlog state.\"=\"Remove it (Recommended)\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01KW1iELpLEEz2uFBr6Mi5ZM"}]},"uuid":"65f8fbde-2b27-47b2-a5a6-279da2fe689d","timestamp":"2026-02-14T12:00:48.047Z","toolUseResult":{"questions":[{"question":"Is the Backlog status needed? No code path currently creates tickets in Backlog state.","header":"Backlog status","options":[{"label":"Remove it (Recommended)","description":"The Spec Agent always sets a specific start_status (Needs Research/Specification/Plan/Implement). Backlog is dead code."},{"label":"Keep for manual use","description":"I want Backlog as a 'parking lot' for tickets I create manually that aren't ready for the pipeline yet. I'd manually edit the status to a Needs* state when ready."},{"label":"Make it the default","description":"Spec Agent should write all tickets as Backlog, and a separate triage step (or manual action) moves them to their start_status."}],"multiSelect":false}],"answers":{"Is the Backlog status needed? No code path currently creates tickets in Backlog state.":"Remove it (Recommended)"}},"sourceToolAssistantUUID":"51006f91-d8b9-48e1-99ad-d8ddf7967168"}
{"parentUuid":"65f8fbde-2b27-47b2-a5a6-279da2fe689d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_016mFgMZQDzrAuTfx5eJ65FY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BhvmwuCFrrfaGu1VwDo6hJ","name":"Read","input":{"file_path":"REDACTED.md","offset":647,"limit":10},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":415,"cache_read_input_tokens":52727,"cache_creation":{"ephemeral_5m_input_tokens":415,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vcT7P3nWMmHdpeXtQ4","type":"assistant","uuid":"6d8e981c-ec19-432e-8521-44c531d97f21","timestamp":"2026-02-14T12:00:51.436Z"}
{"parentUuid":"6d8e981c-ec19-432e-8521-44c531d97f21","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01BhvmwuCFrrfaGu1VwDo6hJ","parentToolUseID":"toolu_01BhvmwuCFrrfaGu1VwDo6hJ","uuid":"d7744606-c0ea-4032-9985-406c72f646fd","timestamp":"2026-02-14T12:00:51.439Z"}
{"parentUuid":"d7744606-c0ea-4032-9985-406c72f646fd","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01BhvmwuCFrrfaGu1VwDo6hJ","toolUseID":"toolu_01BhvmwuCFrrfaGu1VwDo6hJ","timestamp":"2026-02-14T12:00:51.508Z","uuid":"4287aab2-6541-4c97-9089-74d1efecfb93"}
{"parentUuid":"4287aab2-6541-4c97-9089-74d1efecfb93","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01BhvmwuCFrrfaGu1VwDo6hJ","toolUseID":"toolu_01BhvmwuCFrrfaGu1VwDo6hJ","timestamp":"2026-02-14T12:00:51.508Z","uuid":"f56e9f31-55f2-4766-9a5c-bc227155644c"}
{"parentUuid":"6d8e981c-ec19-432e-8521-44c531d97f21","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BhvmwuCFrrfaGu1VwDo6hJ","type":"tool_result","content":"   647→  // Entry\n   648→  Backlog              = \"Backlog\",\n   649→\n   650→  // Stage: Research\n   651→  NeedsResearch        = \"Needs Research\",\n   652→  ResearchInProgress   = \"Research In Progress\",\n   653→\n   654→  // Stage: Specification (optional — research decides if needed)\n   655→  NeedsSpecification   = \"Needs Specification\",\n   656→  SpecificationInProgress = \"Specification In Progress\","}]},"uuid":"901f7d3e-f77e-4a88-802c-475563e820ad","timestamp":"2026-02-14T12:00:51.506Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",","numLines":10,"startLine":647,"totalLines":1069}},"sourceToolAssistantUUID":"6d8e981c-ec19-432e-8521-44c531d97f21"}
{"parentUuid":"901f7d3e-f77e-4a88-802c-475563e820ad","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01D4JmUJ6vbcYXS1HcuMihNs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BN6xMLZ1uD2BNJV9o3RK6X","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research","new_string":"  // Stage: Research"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":249,"cache_read_input_tokens":53142,"cache_creation":{"ephemeral_5m_input_tokens":249,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vchoBLbt2VzSirNDkL","type":"assistant","uuid":"4fd62d26-09bf-42d8-991e-27c5c735a2b9","timestamp":"2026-02-14T12:00:54.929Z"}
{"parentUuid":"4fd62d26-09bf-42d8-991e-27c5c735a2b9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01BN6xMLZ1uD2BNJV9o3RK6X","parentToolUseID":"toolu_01BN6xMLZ1uD2BNJV9o3RK6X","uuid":"0484b815-4b92-408c-9fa2-e34ad1a29047","timestamp":"2026-02-14T12:00:54.933Z"}
{"parentUuid":"0484b815-4b92-408c-9fa2-e34ad1a29047","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01BN6xMLZ1uD2BNJV9o3RK6X","toolUseID":"toolu_01BN6xMLZ1uD2BNJV9o3RK6X","timestamp":"2026-02-14T12:00:54.988Z","uuid":"5816e5ee-417a-4fdc-a36b-246912add6e8"}
{"parentUuid":"5816e5ee-417a-4fdc-a36b-246912add6e8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01BN6xMLZ1uD2BNJV9o3RK6X","toolUseID":"toolu_01BN6xMLZ1uD2BNJV9o3RK6X","timestamp":"2026-02-14T12:00:54.988Z","uuid":"7e929cce-e7aa-4f5e-9a34-43ae5648ed47"}
{"parentUuid":"4fd62d26-09bf-42d8-991e-27c5c735a2b9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BN6xMLZ1uD2BNJV9o3RK6X","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"73087cde-f9ae-48e2-8bdd-112613944414","timestamp":"2026-02-14T12:00:54.987Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research","newString":"  // Stage: Research","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Entry\n  Backlog              = \"Backlog\",\n\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":644,"oldLines":9,"newStart":644,"newLines":6,"lines":[" "," ```typescript"," enum TaskStatus {","-  // Entry","-  Backlog              = \"Backlog\",","-","   // Stage: Research","   NeedsResearch        = \"Needs Research\",","   ResearchInProgress   = \"Research In Progress\","]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"4fd62d26-09bf-42d8-991e-27c5c735a2b9"}
{"parentUuid":"73087cde-f9ae-48e2-8bdd-112613944414","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01G2SChApAXAiZxWJnAVA8Hn","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the transition diagram to remove Backlog."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":205,"cache_read_input_tokens":53391,"cache_creation":{"ephemeral_5m_input_tokens":205,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vcxdem1xfut5wgpxaW","type":"assistant","uuid":"fcad06e5-b368-421d-a965-b6bb059102d6","timestamp":"2026-02-14T12:00:57.463Z"}
{"parentUuid":"fcad06e5-b368-421d-a965-b6bb059102d6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01G2SChApAXAiZxWJnAVA8Hn","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VpHnUgYramMgnk63ffWj6q","name":"Read","input":{"file_path":"REDACTED.md","offset":685,"limit":30},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":205,"cache_read_input_tokens":53391,"output_tokens":125,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":205},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7vcxdem1xfut5wgpxaW","type":"assistant","uuid":"71ceaae7-ca7f-4703-b488-00ecf6335ed7","timestamp":"2026-02-14T12:00:58.182Z"}
{"parentUuid":"71ceaae7-ca7f-4703-b488-00ecf6335ed7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01VpHnUgYramMgnk63ffWj6q","parentToolUseID":"toolu_01VpHnUgYramMgnk63ffWj6q","uuid":"9767b438-e28c-4eb4-a98e-68c8cca6252b","timestamp":"2026-02-14T12:00:58.185Z"}
{"parentUuid":"9767b438-e28c-4eb4-a98e-68c8cca6252b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01VpHnUgYramMgnk63ffWj6q","toolUseID":"toolu_01VpHnUgYramMgnk63ffWj6q","timestamp":"2026-02-14T12:00:58.245Z","uuid":"01ac24b0-8b4e-4d87-8978-e5256bd200ef"}
{"parentUuid":"01ac24b0-8b4e-4d87-8978-e5256bd200ef","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01VpHnUgYramMgnk63ffWj6q","toolUseID":"toolu_01VpHnUgYramMgnk63ffWj6q","timestamp":"2026-02-14T12:00:58.245Z","uuid":"7cd73386-9560-468c-820d-97d2cbd3d48f"}
{"parentUuid":"71ceaae7-ca7f-4703-b488-00ecf6335ed7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VpHnUgYramMgnk63ffWj6q","type":"tool_result","content":"   685→Backlog\n   686→  │\n   687→  ▼\n   688→Needs Research ──→ Research In Progress\n   689→  │\n   690→  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n   691→  │\n   692→  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n   693→               │\n   694→               └──→ Needs Plan (skip spec if pure backend / no UX)\n   695→                      │\n   696→                      ▼\n   697→                    Plan In Progress ──→ Needs Implement\n   698→                      │\n   699→                      ▼\n   700→                    Implement In Progress ──→ Needs Validate\n   701→                      │\n   702→                      ▼\n   703→                    Validate In Progress ──→ Done / Awaiting Merge\n   704→\n   705→ANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n   706→```\n   707→\n   708→### How the Orchestrator Uses Statuses\n   709→\n   710→The orchestrator dispatches workers based on the current status:\n   711→\n   712→```typescript\n   713→private stagePromptMap: Record<string, string> = {\n   714→  \"Needs Research\":        \"agent2-worker-research.md\","}]},"uuid":"ac0ebbda-3175-47c2-ae2e-579f6184c6eb","timestamp":"2026-02-14T12:00:58.244Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"Backlog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",","numLines":30,"startLine":685,"totalLines":1066}},"sourceToolAssistantUUID":"71ceaae7-ca7f-4703-b488-00ecf6335ed7"}
{"parentUuid":"ac0ebbda-3175-47c2-ae2e-579f6184c6eb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01Lx7xEY9fzZfPHvxKwnRnb5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01T1hrQWSA9vsTiwaAn1aq8x","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"Backlog\n  │\n  ▼\nNeeds Research ──→ Research In Progress","new_string":"Needs Research ──→ Research In Progress"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":621,"cache_read_input_tokens":53596,"output_tokens":166,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":621},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7vdCb34y5mbXsGZvJH3","type":"assistant","uuid":"b193103c-3082-4ab0-8d30-83b465a5653a","timestamp":"2026-02-14T12:01:01.345Z"}
{"parentUuid":"b193103c-3082-4ab0-8d30-83b465a5653a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01T1hrQWSA9vsTiwaAn1aq8x","parentToolUseID":"toolu_01T1hrQWSA9vsTiwaAn1aq8x","uuid":"3530b96a-6ff8-4c75-96c1-a9cb84123a8f","timestamp":"2026-02-14T12:01:01.348Z"}
{"parentUuid":"3530b96a-6ff8-4c75-96c1-a9cb84123a8f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01T1hrQWSA9vsTiwaAn1aq8x","toolUseID":"toolu_01T1hrQWSA9vsTiwaAn1aq8x","timestamp":"2026-02-14T12:01:01.412Z","uuid":"19f25789-d6c0-4d12-8714-581207136f6e"}
{"parentUuid":"19f25789-d6c0-4d12-8714-581207136f6e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01T1hrQWSA9vsTiwaAn1aq8x","toolUseID":"toolu_01T1hrQWSA9vsTiwaAn1aq8x","timestamp":"2026-02-14T12:01:01.412Z","uuid":"04a53914-1ea5-4a3d-99b6-942d21f6b249"}
{"parentUuid":"b193103c-3082-4ab0-8d30-83b465a5653a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01T1hrQWSA9vsTiwaAn1aq8x","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"dbaf973d-4e8b-4177-99b0-75c7de8a2647","timestamp":"2026-02-14T12:01:01.411Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"Backlog\n  │\n  ▼\nNeeds Research ──→ Research In Progress","newString":"Needs Research ──→ Research In Progress","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nBacklog\n  │\n  ▼\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":682,"oldLines":9,"newStart":682,"newLines":6,"lines":[" ### Stage Transition Diagram"," "," ```","-Backlog","-  │","-  ▼"," Needs Research ──→ Research In Progress","   │","   ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"b193103c-3082-4ab0-8d30-83b465a5653a"}
{"parentUuid":"dbaf973d-4e8b-4177-99b0-75c7de8a2647","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01WY9FsrmgGorBXi2YHmZjvC","type":"message","role":"assistant","content":[{"type":"text","text":"Issue #4 fixed. Moving on.\n\n---\n\n**Issue #5: Where does merge happen?**\n\n`tryMerge()` runs `git fetch/checkout/rebase/merge` commands. Since workers run in Daytona sandboxes but the orchestrator runs on your local machine, this merge would happen locally."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":211,"cache_read_input_tokens":54217,"cache_creation":{"ephemeral_5m_input_tokens":211,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vdS8dBggGhYMXUKuPD","type":"assistant","uuid":"204c1014-d56c-444a-9795-30f3d1cac1e8","timestamp":"2026-02-14T12:01:05.359Z"}
{"parentUuid":"204c1014-d56c-444a-9795-30f3d1cac1e8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01WY9FsrmgGorBXi2YHmZjvC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015y3GVN2UNHw1KNdZravNZo","name":"AskUserQuestion","input":{"questions":[{"question":"tryMerge() runs git commands — should this happen on your local machine (where the orchestrator runs), or should it be delegated to a sandbox?","header":"Merge location","options":[{"label":"Local machine (Recommended)","description":"The orchestrator has a local clone with push access. Merge happens locally after the sandbox worker pushes to the remote. Simple, no extra sandbox needed."},{"label":"Dedicated merge sandbox","description":"Spin up a sandbox specifically for the merge operation. More isolated but adds complexity and latency."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":211,"cache_read_input_tokens":54217,"cache_creation":{"ephemeral_5m_input_tokens":211,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vdS8dBggGhYMXUKuPD","type":"assistant","uuid":"64cb1c44-f801-4622-82eb-bf83892f75b1","timestamp":"2026-02-14T12:01:08.632Z"}
{"parentUuid":"64cb1c44-f801-4622-82eb-bf83892f75b1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_015y3GVN2UNHw1KNdZravNZo","parentToolUseID":"toolu_015y3GVN2UNHw1KNdZravNZo","uuid":"837ab3b4-aed9-456d-a5a6-71cdc779f244","timestamp":"2026-02-14T12:01:08.636Z"}
{"parentUuid":"64cb1c44-f801-4622-82eb-bf83892f75b1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). To tell you how to proceed, the user said:\nThe user wants to clarify these questions.\n    This means they may have additional information, context or questions for you.\n    Take their response into account and then reformulate the questions if appropriate.\n    Start by asking them what they would like to clarify.\n\n    Questions asked:\n- \"tryMerge() runs git commands — should this happen on your local machine (where the orchestrator runs), or should it be delegated to a sandbox?\"\n  (No answer provided)","is_error":true,"tool_use_id":"toolu_015y3GVN2UNHw1KNdZravNZo"}]},"uuid":"1d3eaabb-71bf-4974-99d6-227beeba06d8","timestamp":"2026-02-14T12:01:36.580Z","toolUseResult":"Error: The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). To tell you how to proceed, the user said:\nThe user wants to clarify these questions.\n    This means they may have additional information, context or questions for you.\n    Take their response into account and then reformulate the questions if appropriate.\n    Start by asking them what they would like to clarify.\n\n    Questions asked:\n- \"tryMerge() runs git commands — should this happen on your local machine (where the orchestrator runs), or should it be delegated to a sandbox?\"\n  (No answer provided)","sourceToolAssistantUUID":"64cb1c44-f801-4622-82eb-bf83892f75b1"}
{"parentUuid":"1d3eaabb-71bf-4974-99d6-227beeba06d8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01S9KcW5hbfPGrfDwoVXAka8","type":"message","role":"assistant","content":[{"type":"text","text":"What would you like to clarify about the merge location?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":442,"cache_read_input_tokens":54428,"cache_creation":{"ephemeral_5m_input_tokens":442,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vg2Phdg2t4iJDj5B9L","type":"assistant","uuid":"aefa6df6-4527-44bf-9fa1-dd0771c8502c","timestamp":"2026-02-14T12:01:39.456Z"}
{"parentUuid":"aefa6df6-4527-44bf-9fa1-dd0771c8502c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"0e9f4e0e-7fe5-419c-b2e9-0ece90c23632","toolUseID":"0e9f4e0e-7fe5-419c-b2e9-0ece90c23632","timestamp":"2026-02-14T12:01:39.530Z","uuid":"ea830c74-6325-41b0-a27d-79191a249585"}
{"parentUuid":"ea830c74-6325-41b0-a27d-79191a249585","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"0e9f4e0e-7fe5-419c-b2e9-0ece90c23632","toolUseID":"0e9f4e0e-7fe5-419c-b2e9-0ece90c23632","timestamp":"2026-02-14T12:01:39.530Z","uuid":"e0b12579-59e6-43ee-9f79-ce7066ac487f"}
{"parentUuid":"e0b12579-59e6-43ee-9f79-ce7066ac487f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T12:01:39.947Z","uuid":"a30d6094-03e3-4312-bd2b-206b13338914","toolUseID":"0e9f4e0e-7fe5-419c-b2e9-0ece90c23632"}
{"parentUuid":"a30d6094-03e3-4312-bd2b-206b13338914","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"system","subtype":"turn_duration","durationMs":136853,"timestamp":"2026-02-14T12:01:39.947Z","uuid":"e159f224-9263-4a9c-9c4e-4ba9af380024","isMeta":false}
{"type":"file-history-snapshot","messageId":"8d3597da-0140-4edc-9c55-770133abc8cb","snapshot":{"messageId":"8d3597da-0140-4edc-9c55-770133abc8cb","trackedFileBackups":{"IMPLEMENTATION_PLAN.md":{"backupFileName":"7cb5415938e35d8f@v2","version":2,"backupTime":"2026-02-14T12:02:34.866Z"}},"timestamp":"2026-02-14T12:02:34.866Z"},"isSnapshotUpdate":false}
{"parentUuid":"e159f224-9263-4a9c-9c4e-4ba9af380024","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":"How does merging currently happen? My intention was merges to be similar to Horizon Agent, where it can be auto, pr or merge."},"uuid":"8d3597da-0140-4edc-9c55-770133abc8cb","timestamp":"2026-02-14T12:02:34.521Z","thinkingMetadata":{"maxThinkingTokens":31999},"permissionMode":"acceptEdits"}
{"parentUuid":"8d3597da-0140-4edc-9c55-770133abc8cb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01RLwpkm1sFmgYyUuiVnZBcH","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":54,"cache_read_input_tokens":54883,"cache_creation":{"ephemeral_5m_input_tokens":54,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vkKpJtj81yQYss3WXW","type":"assistant","uuid":"297864d1-0472-4745-a340-bc51512e70b5","timestamp":"2026-02-14T12:02:37.761Z"}
{"parentUuid":"297864d1-0472-4745-a340-bc51512e70b5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01RLwpkm1sFmgYyUuiVnZBcH","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Let me look at the current codebase to understand how merging works today, and also check the Horizon agent's merge approach since the user references it.","signature":"EsMCCkYICxgCKkDfWw9KbVfvwmkVB5PvIuCPmZdMx+Z4DJqcMqR+gDLu7AvKdd+DHk3/soRc2XNrRjLVvhuMxDF7+8LoRh7c9nFzEgwT2oKeLa6m9NDSoKIaDGb01ghgbs/2BtXHuSIwXHmrj+gP+JwvvTrNPDS2sCF0udh+ZqVuoxjqHNtdWSeOkG+vdH0tccBbpUcB2BMWKqoBeKWR9J9vSWbaItxYEW/r2ZEWOp5ME650utd4Hs7R/QRj/KJVMn7yKviuSe8XmV/x3POacvhFAU7T1+cfnB6/HPePRAQGLJBj7rHOsaUVuemg/gYDKsU3lj9H1ZLeO4AL4gZKU1nBEH4+pq+T2mb0Gty/L67LgS/7RsfGvsAWZVnYm5fqSDHxhQWc+AqSeL9tZeHBQIEOvdqjFCwwOE4JGXaje/yGPVSgk28YAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":54,"cache_read_input_tokens":54883,"cache_creation":{"ephemeral_5m_input_tokens":54,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vkKpJtj81yQYss3WXW","type":"assistant","uuid":"5dad4f86-9896-4f0d-a814-1aefdea0ffcb","timestamp":"2026-02-14T12:02:38.413Z"}
{"parentUuid":"5dad4f86-9896-4f0d-a814-1aefdea0ffcb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01RLwpkm1sFmgYyUuiVnZBcH","type":"message","role":"assistant","content":[{"type":"text","text":"Let me check both the current napoli-matcha implementation and the Horizon reference."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":54,"cache_read_input_tokens":54883,"cache_creation":{"ephemeral_5m_input_tokens":54,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vkKpJtj81yQYss3WXW","type":"assistant","uuid":"8d6d96bf-9066-4659-8135-d9974c45fa5c","timestamp":"2026-02-14T12:02:38.991Z"}
{"parentUuid":"8d6d96bf-9066-4659-8135-d9974c45fa5c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01RLwpkm1sFmgYyUuiVnZBcH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01C7LZvrsqD3xnvAByR58v6R","name":"Task","input":{"description":"Find merge logic in codebase","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","subagent_type":"Explore"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":54,"cache_read_input_tokens":54883,"output_tokens":360,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":54},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7vkKpJtj81yQYss3WXW","type":"assistant","uuid":"1e74da03-08de-4e3c-822e-2daffe24cafb","timestamp":"2026-02-14T12:02:44.902Z"}
{"parentUuid":"1e74da03-08de-4e3c-822e-2daffe24cafb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Task","command":"entire hooks claude-code pre-task"},"toolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"6c39077e-199b-4b7a-8b69-2fb9a52d7214","timestamp":"2026-02-14T12:02:44.907Z"}
{"parentUuid":"6c39077e-199b-4b7a-8b69-2fb9a52d7214","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Task","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"68275e40-0d80-4599-8cd5-4919bcb49a28","timestamp":"2026-02-14T12:02:44.907Z"}
{"parentUuid":"68275e40-0d80-4599-8cd5-4919bcb49a28","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"type":"text","text":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision."}]},"uuid":"52c067c8-a0bc-40a8-9825-7dcfdbee36c8","timestamp":"2026-02-14T12:02:45.157Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"c1bfb4eb-2a62-40a2-a6e8-d09532312a20","timestamp":"2026-02-14T12:02:45.157Z"}
{"parentUuid":"c1bfb4eb-2a62-40a2-a6e8-d09532312a20","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:02:46.617Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0184Zvi16aMU4DUy7U2WCqxs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017FuNwadQ7VBgYs62ZQVTR2","name":"Bash","input":{"command":"ls -la /Users/ob1/projects/opus-hackathon/napoli-matcha/ | head -20","description":"List napoli-matcha directory structure"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":13808,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":13808,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vm5WcUU5HDqoY3bWrC","uuid":"caa31ab2-c72d-4dd7-b5ce-5e3416309fee"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"be0a2d72-b6ab-43f6-9611-d60f586b4606","timestamp":"2026-02-14T12:02:46.620Z"}
{"parentUuid":"be0a2d72-b6ab-43f6-9611-d60f586b4606","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:02:46.898Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0184Zvi16aMU4DUy7U2WCqxs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MxdQ5BZwNJ56AkFTv2P9U4","name":"Bash","input":{"command":"ls -la /Users/ob1/projects/startup/horizon-cli-agent/ | head -20","description":"List horizon-cli-agent directory structure"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":13808,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":13808,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vm5WcUU5HDqoY3bWrC","uuid":"00218a34-153f-46ee-8315-1e4cc8e80e44"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"6236c306-07e5-4078-b247-90ca9e5121b3","timestamp":"2026-02-14T12:02:46.898Z"}
{"parentUuid":"6236c306-07e5-4078-b247-90ca9e5121b3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MxdQ5BZwNJ56AkFTv2P9U4","type":"tool_result","content":"total 272\ndrwxr-xr-x@ 28 ob1  staff    896 13 Feb 15:16 .\ndrwxr-xr-x@ 12 ob1  staff    384 12 Feb 15:35 ..\ndrwxr-xr-x@  3 ob1  staff     96 11 Feb 21:17 .agents\ndrwxr-xr-x@  5 ob1  staff    160 13 Feb 15:32 .claude\ndrwxr-xr-x@  4 ob1  staff    128 12 Feb 23:08 .firecrawl\ndrwxr-xr-x@ 15 ob1  staff    480 14 Feb 07:40 .git\ndrwxr-xr-x@  3 ob1  staff     96  7 Feb 21:19 .github\n-rw-r--r--@  1 ob1  staff    566 12 Feb 22:33 .gitignore\ndrwxr-xr-x@  7 ob1  staff    224  9 Feb 11:31 .horizon\n-rw-r--r--@  1 ob1  staff   5019 12 Feb 14:31 AGENTS.md\ndrwxr-xr-x@  6 ob1  staff    192  7 Feb 21:19 archive\n-rw-r--r--@  1 ob1  staff   8530 13 Feb 15:16 CLAUDE.md\n-rw-r--r--@  1 ob1  staff   2294 12 Feb 13:18 CONTRIBUTING.md\ndrwxr-xr-x@ 19 ob1  staff    608 12 Feb 16:03 dist\ndrwxr-xr-x@  4 ob1  staff    128 12 Feb 22:33 docs\ndrwxr-xr-x@ 11 ob1  staff    352 12 Feb 14:50 horizon-docs\n-rw-r--r--@  1 ob1  staff   1068  7 Feb 22:23 LICENSE\ndrwxr-xr-x@ 91 ob1  staff   2912  8 Feb 20:34 node_modules\n-rwxr-xr-x@  1 ob1  staff   3007 12 Feb 14:56 npm_publish.sh","is_error":false}]},"uuid":"6865830c-ee86-48fa-aa03-b74b7f8deb0b","timestamp":"2026-02-14T12:02:47.167Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"5a56d97c-3d67-4124-9b7c-0caf9bdd65c3","timestamp":"2026-02-14T12:02:47.203Z"}
{"parentUuid":"5a56d97c-3d67-4124-9b7c-0caf9bdd65c3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017FuNwadQ7VBgYs62ZQVTR2","type":"tool_result","content":"total 488\ndrwxr-xr-x@  25 ob1  staff     800 14 Feb 20:01 .\ndrwxr-xr-x@   5 ob1  staff     160 14 Feb 06:46 ..\ndrwxr-xr-x@   6 ob1  staff     192 14 Feb 06:58 .claude\n-rw-r--r--@   1 ob1  staff    8196 14 Feb 06:47 .DS_Store\ndrwxr-xr-x@   7 ob1  staff     224 11 Feb 20:55 .entire\n-rw-r--r--@   1 ob1  staff     318 11 Feb 22:34 .env\ndrwxr-xr-x@  15 ob1  staff     480 14 Feb 20:02 .git\n-rw-r--r--@   1 ob1  staff     213 12 Feb 19:19 .gitignore\ndrwxr-xr-x@   4 ob1  staff     128 14 Feb 17:16 .horizon\n-rw-r--r--@   1 ob1  staff    5835 12 Feb 19:45 CLAUDE.md\ndrwxr-xr-x@   5 ob1  staff     160 12 Feb 11:46 dist\ndrwxr-xr-x@   4 ob1  staff     128 12 Feb 22:19 docs\ndrwxr-xr-x@   3 ob1  staff      96 12 Feb 18:21 horizon-docs\n-rw-r--r--@   1 ob1  staff   48086 14 Feb 20:01 IMPLEMENTATION_PLAN.md\ndrwxr-xr-x@   3 ob1  staff      96 12 Feb 19:34 logs\ndrwxr-xr-x@ 122 ob1  staff    3904 12 Feb 11:33 node_modules\n-rw-r--r--@   1 ob1  staff  152619 12 Feb 11:28 package-lock.json\n-rw-r--r--@   1 ob1  staff     446 12 Feb 11:32 package.json\ndrwxr-xr-x@  12 ob1  staff     384 14 Feb 06:47 prompts","is_error":false}]},"uuid":"c8b125ab-cb45-4dd3-9b7c-1dc60b69a224","timestamp":"2026-02-14T12:02:47.171Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"7f305154-3109-4ee9-85d2-95c80d0e5886","timestamp":"2026-02-14T12:02:47.217Z"}
{"parentUuid":"7f305154-3109-4ee9-85d2-95c80d0e5886","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:02:49.122Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01A4fbgcLzeUMtvHrFsmhUUb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01U1rUbxrVD8AVZwfGsywyT5","name":"Glob","input":{"pattern":"**/merge*.md","path":"/Users/ob1/projects/opus-hackathon/napoli-matcha"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":634,"cache_creation_input_tokens":882,"cache_read_input_tokens":13808,"cache_creation":{"ephemeral_5m_input_tokens":882,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vmEQA6etARhauheCRG","uuid":"4987839b-a879-4757-8576-b98f9e1bc0e4"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"fc12a47a-087f-4209-a638-14f4ec33e73a","timestamp":"2026-02-14T12:02:49.122Z"}
{"parentUuid":"fc12a47a-087f-4209-a638-14f4ec33e73a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:02:49.494Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01A4fbgcLzeUMtvHrFsmhUUb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011QM32j7pEzHFcEZG4MSPTT","name":"Glob","input":{"pattern":"**/merge*.md","path":"/Users/ob1/projects/startup/horizon-cli-agent"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":634,"cache_creation_input_tokens":882,"cache_read_input_tokens":13808,"cache_creation":{"ephemeral_5m_input_tokens":882,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vmEQA6etARhauheCRG","uuid":"9ffccd55-99d2-4bf7-bac4-482edb30d916"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"4c6642c7-2967-4a2f-b613-01380da8f884","timestamp":"2026-02-14T12:02:49.494Z"}
{"parentUuid":"4c6642c7-2967-4a2f-b613-01380da8f884","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01U1rUbxrVD8AVZwfGsywyT5","type":"tool_result","content":"/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-auto.md\n/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-direct.md\n/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-pr.md"}]},"uuid":"6c3f7b21-7ddc-41dd-a96d-4fcb5ee55dda","timestamp":"2026-02-14T12:02:49.504Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"011f8936-7dd5-4756-a337-a89e70534f62","timestamp":"2026-02-14T12:02:49.596Z"}
{"parentUuid":"011f8936-7dd5-4756-a337-a89e70534f62","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:02:49.779Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01A4fbgcLzeUMtvHrFsmhUUb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PtQ4NRjKTrvA6qoAVrWaVd","name":"Glob","input":{"pattern":"**/merge*.ts","path":"/Users/ob1/projects/opus-hackathon/napoli-matcha"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":634,"cache_creation_input_tokens":882,"cache_read_input_tokens":13808,"cache_creation":{"ephemeral_5m_input_tokens":882,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vmEQA6etARhauheCRG","uuid":"444d433d-6ae2-4785-935c-0af46d0b5872"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"cfb7d5da-8350-4d9a-9264-9ed5bc1cdc41","timestamp":"2026-02-14T12:02:49.780Z"}
{"parentUuid":"cfb7d5da-8350-4d9a-9264-9ed5bc1cdc41","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:02:50.001Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01A4fbgcLzeUMtvHrFsmhUUb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VXC642ahLu1ttXLfVmjz17","name":"Glob","input":{"pattern":"**/merge*.ts","path":"/Users/ob1/projects/startup/horizon-cli-agent"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":634,"cache_creation_input_tokens":882,"cache_read_input_tokens":13808,"cache_creation":{"ephemeral_5m_input_tokens":882,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vmEQA6etARhauheCRG","uuid":"514d44a4-5877-48d8-8915-53e8052debba"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"ede1f8a9-b5e4-4bf3-a0eb-e6fc15833260","timestamp":"2026-02-14T12:02:50.001Z"}
{"parentUuid":"ede1f8a9-b5e4-4bf3-a0eb-e6fc15833260","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PtQ4NRjKTrvA6qoAVrWaVd","type":"tool_result","content":"/Users/ob1/projects/opus-hackathon/napoli-matcha/node_modules/@smithy/shared-ini-file-loader/dist-types/mergeConfigFiles.d.ts\n/Users/ob1/projects/opus-hackathon/napoli-matcha/node_modules/@smithy/shared-ini-file-loader/dist-types/ts3.4/mergeConfigFiles.d.ts"}]},"uuid":"01f03513-bf17-47a1-86cc-d5817568a595","timestamp":"2026-02-14T12:02:50.122Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"dc342adc-aa95-417d-9a51-cf33419edf55","timestamp":"2026-02-14T12:02:50.151Z"}
{"parentUuid":"dc342adc-aa95-417d-9a51-cf33419edf55","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011QM32j7pEzHFcEZG4MSPTT","type":"tool_result","content":"/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-auto.md\n/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-direct.md\n/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-pr.md"}]},"uuid":"479c8d5b-2620-4be4-ad6f-a3354a0ff158","timestamp":"2026-02-14T12:02:52.896Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"b8449747-2902-43fb-b15a-967a2e7595ee","timestamp":"2026-02-14T12:02:52.927Z"}
{"parentUuid":"b8449747-2902-43fb-b15a-967a2e7595ee","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VXC642ahLu1ttXLfVmjz17","type":"tool_result","content":"No files found"}]},"uuid":"b56e8854-c82d-4e4c-aae9-4093a0e59ad5","timestamp":"2026-02-14T12:02:52.980Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"9bf91fe3-9151-451a-bec4-e89ac06cc05e","timestamp":"2026-02-14T12:02:53.009Z"}
{"parentUuid":"9bf91fe3-9151-451a-bec4-e89ac06cc05e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:02:55.064Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FHns5VHQVqUYMjKvZ81RPX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019AbsZYVLee4Hir2mwAcAtm","name":"Grep","input":{"pattern":"tryMerge|mergeBranch|createPullRequest|merge.*Strategy","path":"/Users/ob1/projects/opus-hackathon/napoli-matcha/src","output_mode":"files_with_matches"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1364,"cache_read_input_tokens":14690,"cache_creation":{"ephemeral_5m_input_tokens":1364,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vmf7TCJFP8khn7XkMK","uuid":"fba4a71b-60c5-42fc-a312-b9dc5588e69d"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"b9b3d492-7bc2-43fc-859b-5e97902431a7","timestamp":"2026-02-14T12:02:55.064Z"}
{"parentUuid":"b9b3d492-7bc2-43fc-859b-5e97902431a7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:02:55.330Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01FHns5VHQVqUYMjKvZ81RPX","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JacjGepXpTCd6hJ9ht5ymr","name":"Grep","input":{"pattern":"tryMerge|mergeBranch|createPullRequest|merge.*Strategy","path":"/Users/ob1/projects/startup/horizon-cli-agent/src","output_mode":"files_with_matches"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1364,"cache_read_input_tokens":14690,"cache_creation":{"ephemeral_5m_input_tokens":1364,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vmf7TCJFP8khn7XkMK","uuid":"41b2b098-52f4-43d5-bb0d-3d2caa62cef4"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"3196be2d-d833-442b-bff7-7fb6515949ae","timestamp":"2026-02-14T12:02:55.330Z"}
{"parentUuid":"3196be2d-d833-442b-bff7-7fb6515949ae","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019AbsZYVLee4Hir2mwAcAtm","type":"tool_result","content":"No files found"}]},"uuid":"6fcfe0a3-c3c5-4ffc-b884-fcdcea3c105e","timestamp":"2026-02-14T12:02:55.371Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"071c8d1f-6c33-404c-b0dd-9c2c09ebd5d1","timestamp":"2026-02-14T12:02:55.406Z"}
{"parentUuid":"071c8d1f-6c33-404c-b0dd-9c2c09ebd5d1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JacjGepXpTCd6hJ9ht5ymr","type":"tool_result","content":"No files found"}]},"uuid":"3defe8de-b57e-4282-9d8b-39a63f1819e1","timestamp":"2026-02-14T12:02:55.578Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"a25cc8fc-f598-4d6b-88b9-67b7c4e5d1cf","timestamp":"2026-02-14T12:02:55.618Z"}
{"parentUuid":"a25cc8fc-f598-4d6b-88b9-67b7c4e5d1cf","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:02:57.175Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013V3FXAGopiqrJZLGRKqQYZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Cw5ECqQvyeY1w6uiDXyaQu","name":"Grep","input":{"pattern":"merge","path":"/Users/ob1/projects/opus-hackathon/napoli-matcha/src","output_mode":"files_with_matches"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":467,"cache_read_input_tokens":16054,"cache_creation":{"ephemeral_5m_input_tokens":467,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vmrFBBXxFK4Y2izRdu","uuid":"4e1924d7-8bbe-49f2-a3a4-b9360556a581"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"60084b8e-7d6b-47a3-a1ef-0a426000fa5a","timestamp":"2026-02-14T12:02:57.175Z"}
{"parentUuid":"60084b8e-7d6b-47a3-a1ef-0a426000fa5a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:02:57.466Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013V3FXAGopiqrJZLGRKqQYZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015sUBjAiS6HKRPCk7DAjBXs","name":"Grep","input":{"pattern":"merge","path":"/Users/ob1/projects/startup/horizon-cli-agent/src","output_mode":"files_with_matches"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":467,"cache_read_input_tokens":16054,"cache_creation":{"ephemeral_5m_input_tokens":467,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vmrFBBXxFK4Y2izRdu","uuid":"32a47ae6-5b81-49c6-a9dd-e47dc7d1462b"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"e8a0a067-06c7-4507-b221-592f17d7eb92","timestamp":"2026-02-14T12:02:57.466Z"}
{"parentUuid":"e8a0a067-06c7-4507-b221-592f17d7eb92","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Cw5ECqQvyeY1w6uiDXyaQu","type":"tool_result","content":"No files found"}]},"uuid":"a7516319-4b9c-4409-af4c-480cf4de50f5","timestamp":"2026-02-14T12:02:57.472Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"fc5b4416-d30e-448d-bad1-371acffdc31e","timestamp":"2026-02-14T12:02:57.515Z"}
{"parentUuid":"fc5b4416-d30e-448d-bad1-371acffdc31e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015sUBjAiS6HKRPCk7DAjBXs","type":"tool_result","content":"Found 9 files\n/Users/ob1/projects/startup/horizon-cli-agent/src/types.ts\n/Users/ob1/projects/startup/horizon-cli-agent/src/index.ts\n/Users/ob1/projects/startup/horizon-cli-agent/src/config.ts\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/setup.ts\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/prompts.ts\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/init-project.ts\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/linear-api.ts\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/prompts.test.ts"}]},"uuid":"a97aa92f-aab2-4878-897b-d1403a839394","timestamp":"2026-02-14T12:02:57.723Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"dd990f96-d6a4-418c-ae52-da806bdfe318","timestamp":"2026-02-14T12:02:57.765Z"}
{"parentUuid":"dd990f96-d6a4-418c-ae52-da806bdfe318","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:02:59.613Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01UTRDmhZ1zG4LCyocsrTPKt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0161neHDr6boaJePrgA4VCgb","name":"Read","input":{"file_path":"/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-auto.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":545,"cache_read_input_tokens":16521,"cache_creation":{"ephemeral_5m_input_tokens":545,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vn1W3NBtTKK9zrJFeL","uuid":"98fb2694-e6c6-41ad-b87f-28a6c0227b2c"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"77647aa6-f908-4bb5-b2ba-59e43c9b4b10","timestamp":"2026-02-14T12:02:59.614Z"}
{"parentUuid":"77647aa6-f908-4bb5-b2ba-59e43c9b4b10","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0161neHDr6boaJePrgA4VCgb","type":"tool_result","content":"     1→## Merge Mode: `auto` (choose the safest path)\n     2→\n     3→You must choose **exactly one** of the following options:\n     4→\n     5→- **Option A: Merge directly to `main`**\n     6→- **Option B: Create a PR for review**\n     7→\n     8→### Decision Rubric (read first)\n     9→\n    10→Prefer **Option B (PR)** when:\n    11→- The changes include **significant business logic updates**\n    12→- You are **unsure** about correctness, scope, or product intent\n    13→- You had to make assumptions, or you want review for safety\n    14→- There are potential edge cases, migrations, or higher-risk changes\n    15→\n    16→Prefer **Option A (direct merge)** only when:\n    17→- The changes are **small, clearly safe**, and well-understood\n    18→- All checks pass and there are no open questions\n    19→\n    20→---\n    21→\n    22→# Option A: Merge directly to `main`\n    23→\n    24→## A1: Get Repository URL\n    25→\n    26→Before merging, get the repository URL for Agent 3:\n    27→\n    28→```bash\n    29→git remote get-url origin\n    30→```\n    31→\n    32→Include this as `repo_url` in WORK_RESULT.\n    33→\n    34→## A2: Merge to Main\n    35→\n    36→After all checks pass, merge the feature branch to main:\n    37→\n    38→```bash\n    39→# Switch to main and update\n    40→git checkout main\n    41→git pull origin main\n    42→\n    43→# Attempt merge with no-ff to preserve branch history\n    44→git merge horizon/{identifier} --no-ff -m \"Merge horizon/{identifier}: {issue_title}\"\n    45→```\n    46→\n    47→**Handle the merge result:**\n    48→\n    49→1. **Clean merge (no conflicts)**: Push to main, delete feature branch\n    50→   ```bash\n    51→   git push origin main\n    52→   git branch -d horizon/{identifier}\n    53→   git push origin --delete horizon/{identifier}\n    54→   ```\n    55→   Set `merge_status: success` in WORK_RESULT.\n    56→\n    57→2. **Simple conflicts** (imports, whitespace, non-overlapping): Resolve them if obvious\n    58→   - Conflicts are purely mechanical (imports, formatting)\n    59→   - Changes don't overlap in business logic\n    60→   - Resolution is obvious and doesn't require product decisions\n    61→\n    62→   After resolving:\n    63→   ```bash\n    64→   git add .\n    65→   git commit -m \"Merge horizon/{identifier}: {issue_title}\"\n    66→   git push origin main\n    67→   git branch -d horizon/{identifier}\n    68→   git push origin --delete horizon/{identifier}\n    69→   ```\n    70→   Set `merge_status: success` in WORK_RESULT.\n    71→\n    72→3. **Complex conflicts** (business logic, requires judgment): Abort and mark blocked\n    73→   - Conflicts touch core business logic\n    74→   - Multiple approaches are possible\n    75→   - Resolution requires broader context\n    76→\n    77→   ```bash\n    78→   git merge --abort\n    79→   git checkout horizon/{identifier}\n    80→   ```\n    81→   Set `merge_status: blocked` and `merge_conflict_files: [list of files]` in WORK_RESULT.\n    82→\n    83→### WORK_RESULT (Option A)\n    84→\n    85→Use this output format when you chose **Option A (direct merge)**.\n    86→\n    87→After completing your work and merge succeeds:\n    88→\n    89→```\n    90→WORK_RESULT:\n    91→  success: true\n    92→  stage_completed: {{STAGE}}\n    93→  workflow: {{WORKFLOW}}\n    94→  branch_name: horizon/{identifier}\n    95→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n    96→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n    97→  commit_hash: {merge commit hash on main}\n    98→  merge_status: success\n    99→  next_status: \"∞ Done\"\n   100→  summary: |\n   101→    {Brief description of what was done}\n   102→    Files changed: {list}\n   103→    All checks pass. Merged to main.\n   104→```\n   105→\n   106→If work completes but merge is blocked:\n   107→\n   108→```\n   109→WORK_RESULT:\n   110→  success: true\n   111→  stage_completed: {{STAGE}}\n   112→  workflow: {{WORKFLOW}}\n   113→  branch_name: horizon/{identifier}\n   114→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   115→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n   116→  commit_hash: {short hash on feature branch}\n   117→  merge_status: blocked\n   118→  merge_conflict_files: [file1.ts, file2.ts]\n   119→  next_status: \"∞ Blocked\"\n   120→  summary: |\n   121→    {Brief description of what was done}\n   122→    Merge conflicts require human resolution.\n   123→    Conflicts in: {list of files}\n   124→```\n   125→\n   126→If you encounter an error:\n   127→\n   128→```\n   129→WORK_RESULT:\n   130→  success: false\n   131→  stage_completed: {{STAGE}}\n   132→  workflow: {{WORKFLOW}}\n   133→  branch_name: horizon/{identifier}\n   134→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   135→  error: |\n   136→    {What went wrong and why it couldn't be fixed}\n   137→```\n   138→\n   139→---\n   140→\n   141→# Option B: Create PR for review\n   142→\n   143→## B1: Get Repository URL\n   144→\n   145→Before creating the PR, get the repository URL:\n   146→\n   147→```bash\n   148→git remote get-url origin\n   149→```\n   150→\n   151→Include this as `repo_url` in WORK_RESULT.\n   152→\n   153→## B2: Create PR Description Document\n   154→\n   155→Before creating the PR, write a comprehensive PR description document to `horizon-docs/prs/{identifier}.md`:\n   156→\n   157→```markdown\n   158→# PR: {issue_identifier} - {issue_title}\n   159→\n   160→**Branch**: `horizon/{identifier}`\n   161→**Linear Issue**: {issue_identifier}\n   162→**Date**: {YYYY-MM-DD}\n   163→\n   164→## Summary\n   165→\n   166→{2-3 sentence description of what this PR accomplishes and why}\n   167→\n   168→## Problem\n   169→\n   170→{What problem does this solve? What was the user pain point or technical need?}\n   171→\n   172→## Solution\n   173→\n   174→{How does this PR solve the problem? Describe the approach taken.}\n   175→\n   176→## Changes\n   177→\n   178→{List the key changes made, organized by category if helpful}\n   179→\n   180→### Files Changed\n   181→- `path/to/file.ts` - {brief description of change}\n   182→- `path/to/other.ts` - {brief description of change}\n   183→\n   184→## Testing\n   185→\n   186→{How were the changes verified?}\n   187→\n   188→### Automated\n   189→- [ ] Tests pass (`npm test`)\n   190→- [ ] TypeScript compiles (`npm run typecheck`)\n   191→- [ ] Lint passes (`npm run lint`)\n   192→\n   193→### Manual Verification\n   194→{Any manual testing performed or recommended}\n   195→\n   196→## Breaking Changes\n   197→\n   198→{List any breaking changes, or \"None\" if backward compatible}\n   199→\n   200→## Migration Notes\n   201→\n   202→{Any steps needed for users upgrading, or \"None\" if not applicable}\n   203→\n   204→## Screenshots\n   205→\n   206→{If UI changes, include before/after screenshots, or \"N/A\" for non-UI changes}\n   207→\n   208→---\n   209→🤖 Created by [Horizon](https://github.com/ob1-sg/horizon) with {{PROVIDER_LINK}}\n   210→```\n   211→\n   212→Commit and push this document:\n   213→```bash\n   214→git add horizon-docs/prs/\n   215→git commit -m \"docs({identifier}): add PR description\"\n   216→git push origin horizon/{identifier}\n   217→```\n   218→\n   219→## B3: Create Pull Request\n   220→\n   221→Create the pull request using the description document:\n   222→\n   223→```bash\n   224→# Create the pull request with the description file\n   225→gh pr create \\\n   226→  --title \"{issue_identifier}: {issue_title}\" \\\n   227→  --body-file horizon-docs/prs/{identifier}.md \\\n   228→  --base main \\\n   229→  --head horizon/{identifier}\n   230→```\n   231→\n   232→Replace the placeholders:\n   233→- `{issue_identifier}`: The issue ID (e.g., RSK-123)\n   234→- `{issue_title}`: The issue title\n   235→- `{identifier}`: The issue identifier for branch naming\n   236→\n   237→**Handle the PR creation result:**\n   238→\n   239→1. **PR created successfully**: Capture the PR URL from the output\n   240→   Set `merge_status: pr_created` and `pr_url: {URL}` in WORK_RESULT.\n   241→\n   242→2. **PR creation failed**: Include the error\n   243→   Set `merge_status: pr_failed` and include error details in WORK_RESULT.\n   244→\n   245→### WORK_RESULT (Option B)\n   246→\n   247→Use this output format when you chose **Option B (PR)**.\n   248→\n   249→After completing your work and PR is created:\n   250→\n   251→```\n   252→WORK_RESULT:\n   253→  success: true\n   254→  stage_completed: {{STAGE}}\n   255→  workflow: {{WORKFLOW}}\n   256→  branch_name: horizon/{identifier}\n   257→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   258→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n   259→  pr_description_path: horizon-docs/prs/{identifier}.md\n   260→  commit_hash: {short hash on feature branch}\n   261→  merge_status: pr_created\n   262→  pr_url: {GitHub PR URL}\n   263→  next_status: \"∞ Awaiting Merge\"\n   264→  summary: |\n   265→    {Brief description of what was done}\n   266→    Files changed: {list}\n   267→    All checks pass. PR created for review.\n   268→    PR: {pr_url}\n   269→```\n   270→\n   271→If PR creation fails:\n   272→\n   273→```\n   274→WORK_RESULT:\n   275→  success: true\n   276→  stage_completed: {{STAGE}}\n   277→  workflow: {{WORKFLOW}}\n   278→  branch_name: horizon/{identifier}\n   279→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   280→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n   281→  commit_hash: {short hash on feature branch}\n   282→  merge_status: pr_failed\n   283→  next_status: \"∞ Blocked\"\n   284→  summary: |\n   285→    {Brief description of what was done}\n   286→    PR creation failed: {error message}\n   287→```\n   288→\n   289→If you encounter an error during implementation:\n   290→\n   291→```\n   292→WORK_RESULT:\n   293→  success: false\n   294→  stage_completed: {{STAGE}}\n   295→  workflow: {{WORKFLOW}}\n   296→  branch_name: horizon/{identifier}\n   297→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   298→  error: |\n   299→    {What went wrong and why it couldn't be fixed}\n   300→```\n   301→"}]},"uuid":"45861d98-81cd-4ff3-8df1-59cb7f9969c5","timestamp":"2026-02-14T12:02:59.682Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"b5a44de0-edc3-4b12-847c-96a3466db5e5","timestamp":"2026-02-14T12:02:59.918Z"}
{"parentUuid":"b5a44de0-edc3-4b12-847c-96a3466db5e5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:02:59.919Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01UTRDmhZ1zG4LCyocsrTPKt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AjyZtXMurP3zMcMq4HSRbH","name":"Read","input":{"file_path":"/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-direct.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":545,"cache_read_input_tokens":16521,"cache_creation":{"ephemeral_5m_input_tokens":545,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vn1W3NBtTKK9zrJFeL","uuid":"471b0a69-84a0-4eb1-8832-e168d03700c0"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"a9cd12c1-2ed7-42a9-b7a8-fbb3164808ad","timestamp":"2026-02-14T12:02:59.919Z"}
{"parentUuid":"a9cd12c1-2ed7-42a9-b7a8-fbb3164808ad","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01AjyZtXMurP3zMcMq4HSRbH","type":"tool_result","content":"     1→### Step 7: Get Repository URL\n     2→\n     3→Before merging, get the repository URL for Agent 3:\n     4→\n     5→```bash\n     6→git remote get-url origin\n     7→```\n     8→\n     9→Include this as `repo_url` in WORK_RESULT.\n    10→\n    11→### Step 8: Merge to Main\n    12→\n    13→After all checks pass, merge the feature branch to main:\n    14→\n    15→```bash\n    16→# Switch to main and update\n    17→git checkout main\n    18→git pull origin main\n    19→\n    20→# Attempt merge with no-ff to preserve branch history\n    21→git merge horizon/{identifier} --no-ff -m \"Merge horizon/{identifier}: {issue_title}\"\n    22→```\n    23→\n    24→**Handle the merge result:**\n    25→\n    26→1. **Clean merge (no conflicts)**: Push to main, delete feature branch\n    27→   ```bash\n    28→   git push origin main\n    29→   git branch -d horizon/{identifier}\n    30→   git push origin --delete horizon/{identifier}\n    31→   ```\n    32→   Set `merge_status: success` in WORK_RESULT.\n    33→\n    34→2. **Simple conflicts** (imports, whitespace, non-overlapping): Resolve them if obvious\n    35→   - Conflicts are purely mechanical (imports, formatting)\n    36→   - Changes don't overlap in business logic\n    37→   - Resolution is obvious and doesn't require product decisions\n    38→\n    39→   After resolving:\n    40→   ```bash\n    41→   git add .\n    42→   git commit -m \"Merge horizon/{identifier}: {issue_title}\"\n    43→   git push origin main\n    44→   git branch -d horizon/{identifier}\n    45→   git push origin --delete horizon/{identifier}\n    46→   ```\n    47→   Set `merge_status: success` in WORK_RESULT.\n    48→\n    49→3. **Complex conflicts** (business logic, requires judgment): Abort and mark blocked\n    50→   - Conflicts touch core business logic\n    51→   - Multiple approaches are possible\n    52→   - Resolution requires broader context\n    53→\n    54→   ```bash\n    55→   git merge --abort\n    56→   git checkout horizon/{identifier}\n    57→   ```\n    58→   Set `merge_status: blocked` and `merge_conflict_files: [list of files]` in WORK_RESULT.\n    59→\n    60→## Output Format\n    61→\n    62→After completing your work and merge succeeds:\n    63→\n    64→```\n    65→WORK_RESULT:\n    66→  success: true\n    67→  stage_completed: {{STAGE}}\n    68→  workflow: {{WORKFLOW}}\n    69→  branch_name: horizon/{identifier}\n    70→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n    71→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n    72→  commit_hash: {merge commit hash on main}\n    73→  merge_status: success\n    74→  next_status: \"∞ Done\"\n    75→  summary: |\n    76→    {Brief description of what was done}\n    77→    Files changed: {list}\n    78→    All checks pass. Merged to main.\n    79→```\n    80→\n    81→If work completes but merge is blocked:\n    82→\n    83→```\n    84→WORK_RESULT:\n    85→  success: true\n    86→  stage_completed: {{STAGE}}\n    87→  workflow: {{WORKFLOW}}\n    88→  branch_name: horizon/{identifier}\n    89→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n    90→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n    91→  commit_hash: {short hash on feature branch}\n    92→  merge_status: blocked\n    93→  merge_conflict_files: [file1.ts, file2.ts]\n    94→  next_status: \"∞ Blocked\"\n    95→  summary: |\n    96→    {Brief description of what was done}\n    97→    Merge conflicts require human resolution.\n    98→    Conflicts in: {list of files}\n    99→```\n   100→\n   101→If you encounter an error:\n   102→\n   103→```\n   104→WORK_RESULT:\n   105→  success: false\n   106→  stage_completed: {{STAGE}}\n   107→  workflow: {{WORKFLOW}}\n   108→  branch_name: horizon/{identifier}\n   109→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   110→  error: |\n   111→    {What went wrong and why it couldn't be fixed}\n   112→```\n   113→"}]},"uuid":"93f29fa3-414a-4657-9b7e-d033252e94d2","timestamp":"2026-02-14T12:02:59.976Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"12693b5f-a058-46ed-bb5a-8dcfa0636cd0","timestamp":"2026-02-14T12:03:00.030Z"}
{"parentUuid":"12693b5f-a058-46ed-bb5a-8dcfa0636cd0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:03:00.031Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01UTRDmhZ1zG4LCyocsrTPKt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BWz8Pr8gycuULy76kTpwQ5","name":"Read","input":{"file_path":"/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-pr.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":545,"cache_read_input_tokens":16521,"cache_creation":{"ephemeral_5m_input_tokens":545,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vn1W3NBtTKK9zrJFeL","uuid":"9d2c2047-a3e5-487b-b2cb-3d95d5c2fe3d"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"593d746c-e289-438d-8563-30a9364cb19c","timestamp":"2026-02-14T12:03:00.031Z"}
{"parentUuid":"593d746c-e289-438d-8563-30a9364cb19c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BWz8Pr8gycuULy76kTpwQ5","type":"tool_result","content":"     1→### Step 7: Get Repository URL\n     2→\n     3→Before creating the PR, get the repository URL:\n     4→\n     5→```bash\n     6→git remote get-url origin\n     7→```\n     8→\n     9→Include this as `repo_url` in WORK_RESULT.\n    10→\n    11→### Step 8: Create PR Description Document\n    12→\n    13→Before creating the PR, write a comprehensive PR description document to `horizon-docs/prs/{identifier}.md`:\n    14→\n    15→```markdown\n    16→# PR: {issue_identifier} - {issue_title}\n    17→\n    18→**Branch**: `horizon/{identifier}`\n    19→**Linear Issue**: {issue_identifier}\n    20→**Date**: {YYYY-MM-DD}\n    21→\n    22→## Summary\n    23→\n    24→{2-3 sentence description of what this PR accomplishes and why}\n    25→\n    26→## Problem\n    27→\n    28→{What problem does this solve? What was the user pain point or technical need?}\n    29→\n    30→## Solution\n    31→\n    32→{How does this PR solve the problem? Describe the approach taken.}\n    33→\n    34→## Changes\n    35→\n    36→{List the key changes made, organized by category if helpful}\n    37→\n    38→### Files Changed\n    39→- `path/to/file.ts` - {brief description of change}\n    40→- `path/to/other.ts` - {brief description of change}\n    41→\n    42→## Testing\n    43→\n    44→{How were the changes verified?}\n    45→\n    46→### Automated\n    47→- [ ] Tests pass (`npm test`)\n    48→- [ ] TypeScript compiles (`npm run typecheck`)\n    49→- [ ] Lint passes (`npm run lint`)\n    50→\n    51→### Manual Verification\n    52→{Any manual testing performed or recommended}\n    53→\n    54→## Breaking Changes\n    55→\n    56→{List any breaking changes, or \"None\" if backward compatible}\n    57→\n    58→## Migration Notes\n    59→\n    60→{Any steps needed for users upgrading, or \"None\" if not applicable}\n    61→\n    62→## Screenshots\n    63→\n    64→{If UI changes, include before/after screenshots, or \"N/A\" for non-UI changes}\n    65→\n    66→---\n    67→🤖 Created by [Horizon](https://github.com/ob1-sg/horizon) with {{PROVIDER_LINK}}\n    68→```\n    69→\n    70→Commit and push this document:\n    71→```bash\n    72→git add horizon-docs/prs/\n    73→git commit -m \"docs({identifier}): add PR description\"\n    74→git push origin horizon/{identifier}\n    75→```\n    76→\n    77→### Step 9: Create Pull Request\n    78→\n    79→Create the pull request using the description document:\n    80→\n    81→```bash\n    82→# Create the pull request with the description file\n    83→gh pr create \\\n    84→  --title \"{issue_identifier}: {issue_title}\" \\\n    85→  --body-file horizon-docs/prs/{identifier}.md \\\n    86→  --base main \\\n    87→  --head horizon/{identifier}\n    88→```\n    89→\n    90→Replace the placeholders:\n    91→- `{issue_identifier}`: The issue ID (e.g., RSK-123)\n    92→- `{issue_title}`: The issue title\n    93→- `{identifier}`: The issue identifier for branch naming\n    94→\n    95→**Handle the PR creation result:**\n    96→\n    97→1. **PR created successfully**: Capture the PR URL from the output\n    98→   Set `merge_status: pr_created` and `pr_url: {URL}` in WORK_RESULT.\n    99→\n   100→2. **PR creation failed**: Include the error\n   101→   Set `merge_status: pr_failed` and include error details in WORK_RESULT.\n   102→\n   103→## Output Format\n   104→\n   105→After completing your work and PR is created:\n   106→\n   107→```\n   108→WORK_RESULT:\n   109→  success: true\n   110→  stage_completed: {{STAGE}}\n   111→  workflow: {{WORKFLOW}}\n   112→  branch_name: horizon/{identifier}\n   113→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   114→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n   115→  pr_description_path: horizon-docs/prs/{identifier}.md\n   116→  commit_hash: {short hash on feature branch}\n   117→  merge_status: pr_created\n   118→  pr_url: {GitHub PR URL}\n   119→  next_status: \"∞ Awaiting Merge\"\n   120→  summary: |\n   121→    {Brief description of what was done}\n   122→    Files changed: {list}\n   123→    All checks pass. PR created for review.\n   124→    PR: {pr_url}\n   125→```\n   126→\n   127→If PR creation fails:\n   128→\n   129→```\n   130→WORK_RESULT:\n   131→  success: true\n   132→  stage_completed: {{STAGE}}\n   133→  workflow: {{WORKFLOW}}\n   134→  branch_name: horizon/{identifier}\n   135→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   136→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n   137→  commit_hash: {short hash on feature branch}\n   138→  merge_status: pr_failed\n   139→  next_status: \"∞ Blocked\"\n   140→  summary: |\n   141→    {Brief description of what was done}\n   142→    PR creation failed: {error message}\n   143→```\n   144→\n   145→If you encounter an error during implementation:\n   146→\n   147→```\n   148→WORK_RESULT:\n   149→  success: false\n   150→  stage_completed: {{STAGE}}\n   151→  workflow: {{WORKFLOW}}\n   152→  branch_name: horizon/{identifier}\n   153→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   154→  error: |\n   155→    {What went wrong and why it couldn't be fixed}\n   156→```\n   157→"}]},"uuid":"e93f41b5-062e-41c0-a2a6-cd56193c89e5","timestamp":"2026-02-14T12:03:00.068Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"2942f46c-a7da-4f3e-ab0e-4d8b1cf2b441","timestamp":"2026-02-14T12:03:00.108Z"}
{"parentUuid":"2942f46c-a7da-4f3e-ab0e-4d8b1cf2b441","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:03:00.294Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01UTRDmhZ1zG4LCyocsrTPKt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013UZpZsVfMquwiH2Ay5A1Wu","name":"Read","input":{"file_path":"/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-auto.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":545,"cache_read_input_tokens":16521,"cache_creation":{"ephemeral_5m_input_tokens":545,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vn1W3NBtTKK9zrJFeL","uuid":"56f3e79d-c2aa-4faf-817c-3b701a47e5ff"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"a976059f-3d21-432f-bc58-3a25661a5bb8","timestamp":"2026-02-14T12:03:00.294Z"}
{"parentUuid":"a976059f-3d21-432f-bc58-3a25661a5bb8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:03:00.298Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01UTRDmhZ1zG4LCyocsrTPKt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Y3vbYk7DuEH8UGmmyeNscm","name":"Read","input":{"file_path":"/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-direct.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":545,"cache_read_input_tokens":16521,"cache_creation":{"ephemeral_5m_input_tokens":545,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vn1W3NBtTKK9zrJFeL","uuid":"9d35e869-775c-4904-8a78-6ccf2a3f8523"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"f8fec299-910a-4587-b251-cdff278dbbb2","timestamp":"2026-02-14T12:03:00.298Z"}
{"parentUuid":"f8fec299-910a-4587-b251-cdff278dbbb2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013UZpZsVfMquwiH2Ay5A1Wu","type":"tool_result","content":"     1→## Merge Mode: `auto` (choose the safest path)\n     2→\n     3→You must choose **exactly one** of the following options:\n     4→\n     5→- **Option A: Merge directly to `main`**\n     6→- **Option B: Create a PR for review**\n     7→\n     8→### Decision Rubric (read first)\n     9→\n    10→Prefer **Option B (PR)** when:\n    11→- The changes include **significant business logic updates**\n    12→- You are **unsure** about correctness, scope, or product intent\n    13→- You had to make assumptions, or you want review for safety\n    14→- There are potential edge cases, migrations, or higher-risk changes\n    15→\n    16→Prefer **Option A (direct merge)** only when:\n    17→- The changes are **small, clearly safe**, and well-understood\n    18→- All checks pass and there are no open questions\n    19→\n    20→---\n    21→\n    22→# Option A: Merge directly to `main`\n    23→\n    24→## A1: Get Repository URL\n    25→\n    26→Before merging, get the repository URL for Agent 3:\n    27→\n    28→```bash\n    29→git remote get-url origin\n    30→```\n    31→\n    32→Include this as `repo_url` in WORK_RESULT.\n    33→\n    34→## A2: Merge to Main\n    35→\n    36→After all checks pass, merge the feature branch to main:\n    37→\n    38→```bash\n    39→# Switch to main and update\n    40→git checkout main\n    41→git pull origin main\n    42→\n    43→# Attempt merge with no-ff to preserve branch history\n    44→git merge horizon/{identifier} --no-ff -m \"Merge horizon/{identifier}: {issue_title}\"\n    45→```\n    46→\n    47→**Handle the merge result:**\n    48→\n    49→1. **Clean merge (no conflicts)**: Push to main, delete feature branch\n    50→   ```bash\n    51→   git push origin main\n    52→   git branch -d horizon/{identifier}\n    53→   git push origin --delete horizon/{identifier}\n    54→   ```\n    55→   Set `merge_status: success` in WORK_RESULT.\n    56→\n    57→2. **Simple conflicts** (imports, whitespace, non-overlapping): Resolve them if obvious\n    58→   - Conflicts are purely mechanical (imports, formatting)\n    59→   - Changes don't overlap in business logic\n    60→   - Resolution is obvious and doesn't require product decisions\n    61→\n    62→   After resolving:\n    63→   ```bash\n    64→   git add .\n    65→   git commit -m \"Merge horizon/{identifier}: {issue_title}\"\n    66→   git push origin main\n    67→   git branch -d horizon/{identifier}\n    68→   git push origin --delete horizon/{identifier}\n    69→   ```\n    70→   Set `merge_status: success` in WORK_RESULT.\n    71→\n    72→3. **Complex conflicts** (business logic, requires judgment): Abort and mark blocked\n    73→   - Conflicts touch core business logic\n    74→   - Multiple approaches are possible\n    75→   - Resolution requires broader context\n    76→\n    77→   ```bash\n    78→   git merge --abort\n    79→   git checkout horizon/{identifier}\n    80→   ```\n    81→   Set `merge_status: blocked` and `merge_conflict_files: [list of files]` in WORK_RESULT.\n    82→\n    83→### WORK_RESULT (Option A)\n    84→\n    85→Use this output format when you chose **Option A (direct merge)**.\n    86→\n    87→After completing your work and merge succeeds:\n    88→\n    89→```\n    90→WORK_RESULT:\n    91→  success: true\n    92→  stage_completed: {{STAGE}}\n    93→  workflow: {{WORKFLOW}}\n    94→  branch_name: horizon/{identifier}\n    95→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n    96→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n    97→  commit_hash: {merge commit hash on main}\n    98→  merge_status: success\n    99→  next_status: \"∞ Done\"\n   100→  summary: |\n   101→    {Brief description of what was done}\n   102→    Files changed: {list}\n   103→    All checks pass. Merged to main.\n   104→```\n   105→\n   106→If work completes but merge is blocked:\n   107→\n   108→```\n   109→WORK_RESULT:\n   110→  success: true\n   111→  stage_completed: {{STAGE}}\n   112→  workflow: {{WORKFLOW}}\n   113→  branch_name: horizon/{identifier}\n   114→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   115→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n   116→  commit_hash: {short hash on feature branch}\n   117→  merge_status: blocked\n   118→  merge_conflict_files: [file1.ts, file2.ts]\n   119→  next_status: \"∞ Blocked\"\n   120→  summary: |\n   121→    {Brief description of what was done}\n   122→    Merge conflicts require human resolution.\n   123→    Conflicts in: {list of files}\n   124→```\n   125→\n   126→If you encounter an error:\n   127→\n   128→```\n   129→WORK_RESULT:\n   130→  success: false\n   131→  stage_completed: {{STAGE}}\n   132→  workflow: {{WORKFLOW}}\n   133→  branch_name: horizon/{identifier}\n   134→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   135→  error: |\n   136→    {What went wrong and why it couldn't be fixed}\n   137→```\n   138→\n   139→---\n   140→\n   141→# Option B: Create PR for review\n   142→\n   143→## B1: Get Repository URL\n   144→\n   145→Before creating the PR, get the repository URL:\n   146→\n   147→```bash\n   148→git remote get-url origin\n   149→```\n   150→\n   151→Include this as `repo_url` in WORK_RESULT.\n   152→\n   153→## B2: Create PR Description Document\n   154→\n   155→Before creating the PR, write a comprehensive PR description document to `horizon-docs/prs/{identifier}.md`:\n   156→\n   157→```markdown\n   158→# PR: {issue_identifier} - {issue_title}\n   159→\n   160→**Branch**: `horizon/{identifier}`\n   161→**Linear Issue**: {issue_identifier}\n   162→**Date**: {YYYY-MM-DD}\n   163→\n   164→## Summary\n   165→\n   166→{2-3 sentence description of what this PR accomplishes and why}\n   167→\n   168→## Problem\n   169→\n   170→{What problem does this solve? What was the user pain point or technical need?}\n   171→\n   172→## Solution\n   173→\n   174→{How does this PR solve the problem? Describe the approach taken.}\n   175→\n   176→## Changes\n   177→\n   178→{List the key changes made, organized by category if helpful}\n   179→\n   180→### Files Changed\n   181→- `path/to/file.ts` - {brief description of change}\n   182→- `path/to/other.ts` - {brief description of change}\n   183→\n   184→## Testing\n   185→\n   186→{How were the changes verified?}\n   187→\n   188→### Automated\n   189→- [ ] Tests pass (`npm test`)\n   190→- [ ] TypeScript compiles (`npm run typecheck`)\n   191→- [ ] Lint passes (`npm run lint`)\n   192→\n   193→### Manual Verification\n   194→{Any manual testing performed or recommended}\n   195→\n   196→## Breaking Changes\n   197→\n   198→{List any breaking changes, or \"None\" if backward compatible}\n   199→\n   200→## Migration Notes\n   201→\n   202→{Any steps needed for users upgrading, or \"None\" if not applicable}\n   203→\n   204→## Screenshots\n   205→\n   206→{If UI changes, include before/after screenshots, or \"N/A\" for non-UI changes}\n   207→\n   208→---\n   209→🤖 Created by [Horizon](https://github.com/ob1-sg/horizon) with {{PROVIDER_LINK}}\n   210→```\n   211→\n   212→Commit and push this document:\n   213→```bash\n   214→git add horizon-docs/prs/\n   215→git commit -m \"docs({identifier}): add PR description\"\n   216→git push origin horizon/{identifier}\n   217→```\n   218→\n   219→## B3: Create Pull Request\n   220→\n   221→Create the pull request using the description document:\n   222→\n   223→```bash\n   224→# Create the pull request with the description file\n   225→gh pr create \\\n   226→  --title \"{issue_identifier}: {issue_title}\" \\\n   227→  --body-file horizon-docs/prs/{identifier}.md \\\n   228→  --base main \\\n   229→  --head horizon/{identifier}\n   230→```\n   231→\n   232→Replace the placeholders:\n   233→- `{issue_identifier}`: The issue ID (e.g., RSK-123)\n   234→- `{issue_title}`: The issue title\n   235→- `{identifier}`: The issue identifier for branch naming\n   236→\n   237→**Handle the PR creation result:**\n   238→\n   239→1. **PR created successfully**: Capture the PR URL from the output\n   240→   Set `merge_status: pr_created` and `pr_url: {URL}` in WORK_RESULT.\n   241→\n   242→2. **PR creation failed**: Include the error\n   243→   Set `merge_status: pr_failed` and include error details in WORK_RESULT.\n   244→\n   245→### WORK_RESULT (Option B)\n   246→\n   247→Use this output format when you chose **Option B (PR)**.\n   248→\n   249→After completing your work and PR is created:\n   250→\n   251→```\n   252→WORK_RESULT:\n   253→  success: true\n   254→  stage_completed: {{STAGE}}\n   255→  workflow: {{WORKFLOW}}\n   256→  branch_name: horizon/{identifier}\n   257→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   258→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n   259→  pr_description_path: horizon-docs/prs/{identifier}.md\n   260→  commit_hash: {short hash on feature branch}\n   261→  merge_status: pr_created\n   262→  pr_url: {GitHub PR URL}\n   263→  next_status: \"∞ Awaiting Merge\"\n   264→  summary: |\n   265→    {Brief description of what was done}\n   266→    Files changed: {list}\n   267→    All checks pass. PR created for review.\n   268→    PR: {pr_url}\n   269→```\n   270→\n   271→If PR creation fails:\n   272→\n   273→```\n   274→WORK_RESULT:\n   275→  success: true\n   276→  stage_completed: {{STAGE}}\n   277→  workflow: {{WORKFLOW}}\n   278→  branch_name: horizon/{identifier}\n   279→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   280→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n   281→  commit_hash: {short hash on feature branch}\n   282→  merge_status: pr_failed\n   283→  next_status: \"∞ Blocked\"\n   284→  summary: |\n   285→    {Brief description of what was done}\n   286→    PR creation failed: {error message}\n   287→```\n   288→\n   289→If you encounter an error during implementation:\n   290→\n   291→```\n   292→WORK_RESULT:\n   293→  success: false\n   294→  stage_completed: {{STAGE}}\n   295→  workflow: {{WORKFLOW}}\n   296→  branch_name: horizon/{identifier}\n   297→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   298→  error: |\n   299→    {What went wrong and why it couldn't be fixed}\n   300→```\n   301→"}]},"uuid":"d90ee2b4-2c6e-43b8-b9ca-ef88d8c3cfe0","timestamp":"2026-02-14T12:03:00.351Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"2d3826cf-cb93-4368-8aa4-0fd994760ce8","timestamp":"2026-02-14T12:03:00.413Z"}
{"parentUuid":"2d3826cf-cb93-4368-8aa4-0fd994760ce8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y3vbYk7DuEH8UGmmyeNscm","type":"tool_result","content":"     1→### Step 7: Get Repository URL\n     2→\n     3→Before merging, get the repository URL for Agent 3:\n     4→\n     5→```bash\n     6→git remote get-url origin\n     7→```\n     8→\n     9→Include this as `repo_url` in WORK_RESULT.\n    10→\n    11→### Step 8: Merge to Main\n    12→\n    13→After all checks pass, merge the feature branch to main:\n    14→\n    15→```bash\n    16→# Switch to main and update\n    17→git checkout main\n    18→git pull origin main\n    19→\n    20→# Attempt merge with no-ff to preserve branch history\n    21→git merge horizon/{identifier} --no-ff -m \"Merge horizon/{identifier}: {issue_title}\"\n    22→```\n    23→\n    24→**Handle the merge result:**\n    25→\n    26→1. **Clean merge (no conflicts)**: Push to main, delete feature branch\n    27→   ```bash\n    28→   git push origin main\n    29→   git branch -d horizon/{identifier}\n    30→   git push origin --delete horizon/{identifier}\n    31→   ```\n    32→   Set `merge_status: success` in WORK_RESULT.\n    33→\n    34→2. **Simple conflicts** (imports, whitespace, non-overlapping): Resolve them if obvious\n    35→   - Conflicts are purely mechanical (imports, formatting)\n    36→   - Changes don't overlap in business logic\n    37→   - Resolution is obvious and doesn't require product decisions\n    38→\n    39→   After resolving:\n    40→   ```bash\n    41→   git add .\n    42→   git commit -m \"Merge horizon/{identifier}: {issue_title}\"\n    43→   git push origin main\n    44→   git branch -d horizon/{identifier}\n    45→   git push origin --delete horizon/{identifier}\n    46→   ```\n    47→   Set `merge_status: success` in WORK_RESULT.\n    48→\n    49→3. **Complex conflicts** (business logic, requires judgment): Abort and mark blocked\n    50→   - Conflicts touch core business logic\n    51→   - Multiple approaches are possible\n    52→   - Resolution requires broader context\n    53→\n    54→   ```bash\n    55→   git merge --abort\n    56→   git checkout horizon/{identifier}\n    57→   ```\n    58→   Set `merge_status: blocked` and `merge_conflict_files: [list of files]` in WORK_RESULT.\n    59→\n    60→## Output Format\n    61→\n    62→After completing your work and merge succeeds:\n    63→\n    64→```\n    65→WORK_RESULT:\n    66→  success: true\n    67→  stage_completed: {{STAGE}}\n    68→  workflow: {{WORKFLOW}}\n    69→  branch_name: horizon/{identifier}\n    70→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n    71→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n    72→  commit_hash: {merge commit hash on main}\n    73→  merge_status: success\n    74→  next_status: \"∞ Done\"\n    75→  summary: |\n    76→    {Brief description of what was done}\n    77→    Files changed: {list}\n    78→    All checks pass. Merged to main.\n    79→```\n    80→\n    81→If work completes but merge is blocked:\n    82→\n    83→```\n    84→WORK_RESULT:\n    85→  success: true\n    86→  stage_completed: {{STAGE}}\n    87→  workflow: {{WORKFLOW}}\n    88→  branch_name: horizon/{identifier}\n    89→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n    90→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n    91→  commit_hash: {short hash on feature branch}\n    92→  merge_status: blocked\n    93→  merge_conflict_files: [file1.ts, file2.ts]\n    94→  next_status: \"∞ Blocked\"\n    95→  summary: |\n    96→    {Brief description of what was done}\n    97→    Merge conflicts require human resolution.\n    98→    Conflicts in: {list of files}\n    99→```\n   100→\n   101→If you encounter an error:\n   102→\n   103→```\n   104→WORK_RESULT:\n   105→  success: false\n   106→  stage_completed: {{STAGE}}\n   107→  workflow: {{WORKFLOW}}\n   108→  branch_name: horizon/{identifier}\n   109→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   110→  error: |\n   111→    {What went wrong and why it couldn't be fixed}\n   112→```\n   113→"}]},"uuid":"f377d2bc-5890-4ff9-8a97-6307a91aa9a8","timestamp":"2026-02-14T12:03:00.354Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"b3ea93a5-2b08-4fa3-8a3d-18d3636ca125","timestamp":"2026-02-14T12:03:00.413Z"}
{"parentUuid":"b3ea93a5-2b08-4fa3-8a3d-18d3636ca125","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:03:00.704Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01UTRDmhZ1zG4LCyocsrTPKt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01U18tEWJKC42sFB9qh8ubyR","name":"Read","input":{"file_path":"/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-pr.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":545,"cache_read_input_tokens":16521,"cache_creation":{"ephemeral_5m_input_tokens":545,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vn1W3NBtTKK9zrJFeL","uuid":"1c9429ef-7edc-494c-aef2-0a712ba8727b"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"536f5c28-686c-4a9c-9282-a4604f89e2a2","timestamp":"2026-02-14T12:03:00.704Z"}
{"parentUuid":"536f5c28-686c-4a9c-9282-a4604f89e2a2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01U18tEWJKC42sFB9qh8ubyR","type":"tool_result","content":"     1→### Step 7: Get Repository URL\n     2→\n     3→Before creating the PR, get the repository URL:\n     4→\n     5→```bash\n     6→git remote get-url origin\n     7→```\n     8→\n     9→Include this as `repo_url` in WORK_RESULT.\n    10→\n    11→### Step 8: Create PR Description Document\n    12→\n    13→Before creating the PR, write a comprehensive PR description document to `horizon-docs/prs/{identifier}.md`:\n    14→\n    15→```markdown\n    16→# PR: {issue_identifier} - {issue_title}\n    17→\n    18→**Branch**: `horizon/{identifier}`\n    19→**Linear Issue**: {issue_identifier}\n    20→**Date**: {YYYY-MM-DD}\n    21→\n    22→## Summary\n    23→\n    24→{2-3 sentence description of what this PR accomplishes and why}\n    25→\n    26→## Problem\n    27→\n    28→{What problem does this solve? What was the user pain point or technical need?}\n    29→\n    30→## Solution\n    31→\n    32→{How does this PR solve the problem? Describe the approach taken.}\n    33→\n    34→## Changes\n    35→\n    36→{List the key changes made, organized by category if helpful}\n    37→\n    38→### Files Changed\n    39→- `path/to/file.ts` - {brief description of change}\n    40→- `path/to/other.ts` - {brief description of change}\n    41→\n    42→## Testing\n    43→\n    44→{How were the changes verified?}\n    45→\n    46→### Automated\n    47→- [ ] Tests pass (`npm test`)\n    48→- [ ] TypeScript compiles (`npm run typecheck`)\n    49→- [ ] Lint passes (`npm run lint`)\n    50→\n    51→### Manual Verification\n    52→{Any manual testing performed or recommended}\n    53→\n    54→## Breaking Changes\n    55→\n    56→{List any breaking changes, or \"None\" if backward compatible}\n    57→\n    58→## Migration Notes\n    59→\n    60→{Any steps needed for users upgrading, or \"None\" if not applicable}\n    61→\n    62→## Screenshots\n    63→\n    64→{If UI changes, include before/after screenshots, or \"N/A\" for non-UI changes}\n    65→\n    66→---\n    67→🤖 Created by [Horizon](https://github.com/ob1-sg/horizon) with {{PROVIDER_LINK}}\n    68→```\n    69→\n    70→Commit and push this document:\n    71→```bash\n    72→git add horizon-docs/prs/\n    73→git commit -m \"docs({identifier}): add PR description\"\n    74→git push origin horizon/{identifier}\n    75→```\n    76→\n    77→### Step 9: Create Pull Request\n    78→\n    79→Create the pull request using the description document:\n    80→\n    81→```bash\n    82→# Create the pull request with the description file\n    83→gh pr create \\\n    84→  --title \"{issue_identifier}: {issue_title}\" \\\n    85→  --body-file horizon-docs/prs/{identifier}.md \\\n    86→  --base main \\\n    87→  --head horizon/{identifier}\n    88→```\n    89→\n    90→Replace the placeholders:\n    91→- `{issue_identifier}`: The issue ID (e.g., RSK-123)\n    92→- `{issue_title}`: The issue title\n    93→- `{identifier}`: The issue identifier for branch naming\n    94→\n    95→**Handle the PR creation result:**\n    96→\n    97→1. **PR created successfully**: Capture the PR URL from the output\n    98→   Set `merge_status: pr_created` and `pr_url: {URL}` in WORK_RESULT.\n    99→\n   100→2. **PR creation failed**: Include the error\n   101→   Set `merge_status: pr_failed` and include error details in WORK_RESULT.\n   102→\n   103→## Output Format\n   104→\n   105→After completing your work and PR is created:\n   106→\n   107→```\n   108→WORK_RESULT:\n   109→  success: true\n   110→  stage_completed: {{STAGE}}\n   111→  workflow: {{WORKFLOW}}\n   112→  branch_name: horizon/{identifier}\n   113→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   114→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n   115→  pr_description_path: horizon-docs/prs/{identifier}.md\n   116→  commit_hash: {short hash on feature branch}\n   117→  merge_status: pr_created\n   118→  pr_url: {GitHub PR URL}\n   119→  next_status: \"∞ Awaiting Merge\"\n   120→  summary: |\n   121→    {Brief description of what was done}\n   122→    Files changed: {list}\n   123→    All checks pass. PR created for review.\n   124→    PR: {pr_url}\n   125→```\n   126→\n   127→If PR creation fails:\n   128→\n   129→```\n   130→WORK_RESULT:\n   131→  success: true\n   132→  stage_completed: {{STAGE}}\n   133→  workflow: {{WORKFLOW}}\n   134→  branch_name: horizon/{identifier}\n   135→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   136→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n   137→  commit_hash: {short hash on feature branch}\n   138→  merge_status: pr_failed\n   139→  next_status: \"∞ Blocked\"\n   140→  summary: |\n   141→    {Brief description of what was done}\n   142→    PR creation failed: {error message}\n   143→```\n   144→\n   145→If you encounter an error during implementation:\n   146→\n   147→```\n   148→WORK_RESULT:\n   149→  success: false\n   150→  stage_completed: {{STAGE}}\n   151→  workflow: {{WORKFLOW}}\n   152→  branch_name: horizon/{identifier}\n   153→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   154→  error: |\n   155→    {What went wrong and why it couldn't be fixed}\n   156→```\n   157→"}]},"uuid":"a4ba9d84-2da3-4b4f-a469-aef42e14c06b","timestamp":"2026-02-14T12:03:00.775Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"07f25844-cf75-455f-8363-22fcdfd0a3d9","timestamp":"2026-02-14T12:03:00.808Z"}
{"parentUuid":"07f25844-cf75-455f-8363-22fcdfd0a3d9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:03:02.595Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01QYvUvDfpRBeVPrjH6kX7R9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EocS7fmiWVMSArFiuQK2KM","name":"Read","input":{"file_path":"/Users/ob1/projects/startup/horizon-cli-agent/src/types.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":13302,"cache_read_input_tokens":17066,"cache_creation":{"ephemeral_5m_input_tokens":13302,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vnEXsSVJXwnfXXCUtr","uuid":"35155f5e-c41b-4bde-9ef3-88a32ec699f1"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"b508ea21-8eb3-41d2-ae5d-ab460fb0911c","timestamp":"2026-02-14T12:03:02.595Z"}
{"parentUuid":"b508ea21-8eb3-41d2-ae5d-ab460fb0911c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EocS7fmiWVMSArFiuQK2KM","type":"tool_result","content":"     1→// Provider types\n     2→\n     3→export type ProviderName = 'claude' | 'codex';\n     4→export type ClaudeModel = 'opus' | 'sonnet' | 'haiku';\n     5→export type CodexReasoningEffort = 'low' | 'medium' | 'high' | 'extra_high';\n     6→export type MergeMode = 'auto' | 'merge' | 'pr';\n     7→\n     8→// Claude CLI types\n     9→\n    10→export interface ClaudeOptions {\n    11→  prompt: string;\n    12→  model: 'sonnet' | 'opus' | 'haiku';\n    13→  allowedTools?: string[];\n    14→  workingDirectory?: string;\n    15→}\n    16→\n    17→export interface ClaudeResult {\n    18→  output: string;\n    19→  rateLimited: boolean;\n    20→  retryAfterMs?: number;\n    21→  cost: number;\n    22→  duration: number;\n    23→  exitCode: number;\n    24→}\n    25→\n    26→// Linear workflow state types\n    27→\n    28→export type LinearStateType = 'backlog' | 'unstarted' | 'started' | 'completed' | 'canceled';\n    29→\n    30→export interface WorkflowState {\n    31→  id: string;\n    32→  name: string;\n    33→  type: LinearStateType;\n    34→  position: number;\n    35→  color?: string;\n    36→}\n    37→\n    38→// Horizon status definition for creating workflow states\n    39→export interface HorizonStatusDefinition {\n    40→  name: string;\n    41→  type: LinearStateType;\n    42→}\n    43→\n    44→// Initialization result\n    45→export interface InitResult {\n    46→  success: boolean;\n    47→  created: string[];\n    48→  existing: string[];\n    49→  errors: string[];\n    50→}\n    51→\n    52→// Attachment types\n    53→\n    54→export interface AttachmentInfo {\n    55→  id: string;\n    56→  url: string;\n    57→  filename: string;\n    58→  source: 'attachment' | 'embedded';\n    59→}\n    60→\n    61→export interface DownloadResult {\n    62→  success: boolean;\n    63→  attachments: DownloadedAttachment[];\n    64→  errors: string[];\n    65→}\n    66→\n    67→export interface DownloadedAttachment {\n    68→  originalUrl: string;\n    69→  localPath: string;\n    70→  filename: string;\n    71→}\n    72→\n    73→// Per-agent reasoning effort configuration for Codex\n    74→export interface CodexAgentReasoningConfig {\n    75→  agent1: CodexReasoningEffort;\n    76→  agent2: CodexReasoningEffort;\n    77→  agent3: CodexReasoningEffort;\n    78→}\n    79→\n    80→// Config types\n    81→\n    82→export interface HorizonConfig {\n    83→  workingDirectory: string;\n    84→  linearApiKey?: string;\n    85→  linearTeamId?: string;\n    86→  gitBranch: string;\n    87→  staleTimeoutHours: number;\n    88→  noWorkSleepMinutes: number;\n    89→  errorSleepMinutes: number;\n    90→\n    91→  // Provider configuration\n    92→  provider: ProviderName;\n    93→  claudeModel: ClaudeModel;\n    94→  codexModel: string;\n    95→  codexReasoningEffort: CodexReasoningEffort;\n    96→  codexAgentReasoning: CodexAgentReasoningConfig;\n    97→  maxIterations: number;\n    98→\n    99→  // Rate limit configuration\n   100→  rateLimitMaxRetries: number;\n   101→\n   102→  // GCP configuration\n   103→  gcpAutoStop: boolean;\n   104→\n   105→  // Quick check configuration\n   106→  quickCheckIntervalMinutes: number;\n   107→  fullCheckIntervalMinutes: number;\n   108→\n   109→  // Merge mode configuration\n   110→  mergeMode: MergeMode;\n   111→}\n   112→\n   113→// Quick check result\n   114→export interface QuickCheckResult {\n   115→  hasWork: boolean;\n   116→  ticketCount: number;\n   117→  error?: string;\n   118→}\n   119→\n   120→// Pulse check result with status category breakdown\n   121→export interface StatusCategoryCounts {\n   122→  backlog: number;\n   123→  unstarted: number;\n   124→  started: number;\n   125→  completed: number;\n   126→  canceled: number;\n   127→}\n   128→\n   129→export interface PulseCheckResult extends QuickCheckResult {\n   130→  statusCounts: StatusCategoryCounts;\n   131→}\n   132→"}]},"uuid":"5a0da782-2e99-4adf-a608-6881be0b326a","timestamp":"2026-02-14T12:03:02.656Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"0bc88883-cf34-4676-afeb-ba77f8f6ba7e","timestamp":"2026-02-14T12:03:03.726Z"}
{"parentUuid":"0bc88883-cf34-4676-afeb-ba77f8f6ba7e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:03:03.727Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01QYvUvDfpRBeVPrjH6kX7R9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TFzcArEi2a2dtkfRc7VAkm","name":"Read","input":{"file_path":"/Users/ob1/projects/startup/horizon-cli-agent/src/lib/prompts.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":13302,"cache_read_input_tokens":17066,"cache_creation":{"ephemeral_5m_input_tokens":13302,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vnEXsSVJXwnfXXCUtr","uuid":"a2ebb76d-7c9d-4676-8f32-62f33da10740"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"f6ba0313-d64d-4ac5-baf7-d7f6cb575591","timestamp":"2026-02-14T12:03:03.727Z"}
{"parentUuid":"f6ba0313-d64d-4ac5-baf7-d7f6cb575591","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TFzcArEi2a2dtkfRc7VAkm","type":"tool_result","content":"     1→import { readFileSync, existsSync } from 'fs';\n     2→import { join, dirname } from 'path';\n     3→import { fileURLToPath } from 'url';\n     4→import { getRepoRoot } from '../config.js';\n     5→\n     6→// Get the package directory for fallback prompts\n     7→const __filename = fileURLToPath(import.meta.url);\n     8→const __dirname = dirname(__filename);\n     9→const PACKAGE_ROOT = join(__dirname, '../..');\n    10→\n    11→/**\n    12→ * Loads a prompt from .horizon/prompts/ (preferred) or package prompts/ (fallback).\n    13→ * Supports template variables in the format {{VARIABLE_NAME}}.\n    14→ *\n    15→ * @param name - Prompt name without .md extension\n    16→ * @param variables - Optional object of variable names to values for template substitution\n    17→ * @returns The prompt content with variables substituted\n    18→ */\n    19→export function loadPrompt(name: string, variables?: Record<string, string>): string {\n    20→  // Try .horizon/prompts/ first (project-local)\n    21→  const projectPromptPath = join(getRepoRoot(), '.horizon', 'prompts', `${name}.md`);\n    22→\n    23→  // Fallback to package prompts/\n    24→  const packagePromptPath = join(PACKAGE_ROOT, 'prompts', `${name}.md`);\n    25→\n    26→  let promptPath: string;\n    27→  if (existsSync(projectPromptPath)) {\n    28→    promptPath = projectPromptPath;\n    29→  } else if (existsSync(packagePromptPath)) {\n    30→    promptPath = packagePromptPath;\n    31→  } else {\n    32→    throw new Error(`Prompt not found: ${name}`);\n    33→  }\n    34→\n    35→  let content = readFileSync(promptPath, 'utf-8');\n    36→\n    37→  // Substitute template variables\n    38→  if (variables) {\n    39→    for (const [key, value] of Object.entries(variables)) {\n    40→      const placeholder = `{{${key}}}`;\n    41→      content = content.replace(new RegExp(placeholder.replace(/[{}]/g, '\\\\$&'), 'g'), value);\n    42→    }\n    43→  }\n    44→\n    45→  return content;\n    46→}\n    47→\n    48→/**\n    49→ * Loads a prompt fragment from the fragments/ subdirectory.\n    50→ *\n    51→ * @param name - Fragment name without .md extension (e.g., 'merge-direct')\n    52→ * @returns The fragment content\n    53→ */\n    54→export function loadPromptFragment(name: string): string {\n    55→  // Try .horizon/prompts/fragments/ first\n    56→  const projectFragmentPath = join(getRepoRoot(), '.horizon', 'prompts', 'fragments', `${name}.md`);\n    57→\n    58→  // Fallback to package prompts/fragments/\n    59→  const packageFragmentPath = join(PACKAGE_ROOT, 'prompts', 'fragments', `${name}.md`);\n    60→\n    61→  let fragmentPath: string;\n    62→  if (existsSync(projectFragmentPath)) {\n    63→    fragmentPath = projectFragmentPath;\n    64→  } else if (existsSync(packageFragmentPath)) {\n    65→    fragmentPath = packageFragmentPath;\n    66→  } else {\n    67→    throw new Error(`Prompt fragment not found: ${name}`);\n    68→  }\n    69→\n    70→  return readFileSync(fragmentPath, 'utf-8');\n    71→}\n    72→"}]},"uuid":"9170a985-83e3-43a3-95c0-a0fad09e1399","timestamp":"2026-02-14T12:03:03.790Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"53adf5d0-0b1e-420a-95dd-62bd26e2ab8d","timestamp":"2026-02-14T12:03:04.480Z"}
{"parentUuid":"53adf5d0-0b1e-420a-95dd-62bd26e2ab8d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:03:04.481Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01QYvUvDfpRBeVPrjH6kX7R9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HzRKQgT91x6EQJdjaxWH2u","name":"Bash","input":{"command":"find /Users/ob1/projects/opus-hackathon/napoli-matcha/src -name \"*.ts\" | head -20","description":"List TypeScript files in napoli-matcha src"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":13302,"cache_read_input_tokens":17066,"cache_creation":{"ephemeral_5m_input_tokens":13302,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vnEXsSVJXwnfXXCUtr","uuid":"d55406d3-bbc4-4317-8d37-aeb433ff7bba"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"45f7336b-0218-45c8-bd60-b2b7db8ebbed","timestamp":"2026-02-14T12:03:04.481Z"}
{"parentUuid":"45f7336b-0218-45c8-bd60-b2b7db8ebbed","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HzRKQgT91x6EQJdjaxWH2u","type":"tool_result","content":"/Users/ob1/projects/opus-hackathon/napoli-matcha/src/lib/SandboxQueueProcessor.ts\n/Users/ob1/projects/opus-hackathon/napoli-matcha/src/index.ts","is_error":false}]},"uuid":"1c5d38ba-3f79-4c14-a3c3-25d7016b9477","timestamp":"2026-02-14T12:03:04.573Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"56ed3dff-982b-4b62-bf09-bc5b52ddf37a","timestamp":"2026-02-14T12:03:04.604Z"}
{"parentUuid":"56ed3dff-982b-4b62-bf09-bc5b52ddf37a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:03:06.187Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01BbCpwL8xawUbEJdLQjFwcc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Q5JLcpQteVUbMPnwh4Gctd","name":"Read","input":{"file_path":"/Users/ob1/projects/opus-hackathon/napoli-matcha/src/index.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2717,"cache_read_input_tokens":30368,"cache_creation":{"ephemeral_5m_input_tokens":2717,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vnWihk7EUxF2AX74ef","uuid":"a073aa3a-f3cc-458b-a96c-35eae720444b"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"20af1372-144b-44c0-b077-7fa5ed4427f6","timestamp":"2026-02-14T12:03:06.187Z"}
{"parentUuid":"20af1372-144b-44c0-b077-7fa5ed4427f6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q5JLcpQteVUbMPnwh4Gctd","type":"tool_result","content":"     1→import dotenv from \"dotenv\";\n     2→import { SandboxQueueProcessor } from \"./lib/SandboxQueueProcessor.js\";\n     3→\n     4→dotenv.config();\n     5→\n     6→async function main() {\n     7→  const processor = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n     8→  await processor.processQueue();\n     9→}\n    10→\n    11→main().catch((error) => {\n    12→  console.error(\"Fatal error:\", error);\n    13→  process.exit(1);\n    14→});\n    15→"}]},"uuid":"46396d48-16ea-4c2e-ac11-ac5113325174","timestamp":"2026-02-14T12:03:06.241Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"fbcbdb1e-016d-41eb-9d42-04111dd84614","timestamp":"2026-02-14T12:03:06.493Z"}
{"parentUuid":"fbcbdb1e-016d-41eb-9d42-04111dd84614","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:03:06.494Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01BbCpwL8xawUbEJdLQjFwcc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GLzyEsrirEppJ3tgCrFUB5","name":"Read","input":{"file_path":"/Users/ob1/projects/opus-hackathon/napoli-matcha/src/lib/SandboxQueueProcessor.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2717,"cache_read_input_tokens":30368,"cache_creation":{"ephemeral_5m_input_tokens":2717,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vnWihk7EUxF2AX74ef","uuid":"af7017aa-b404-4585-8818-19b98cb374aa"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"b4145893-81ed-42b8-bb38-6748d0f3c876","timestamp":"2026-02-14T12:03:06.494Z"}
{"parentUuid":"b4145893-81ed-42b8-bb38-6748d0f3c876","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GLzyEsrirEppJ3tgCrFUB5","type":"tool_result","content":"     1→import { Daytona, Sandbox } from \"@daytonaio/sdk\";\n     2→import matter from \"gray-matter\";\n     3→import { appendFile, mkdir, readdir, readFile, writeFile } from \"fs/promises\";\n     4→import { join } from \"path\";\n     5→\n     6→interface TaskRequest {\n     7→  id: string;\n     8→  file: string;\n     9→  filePath: string;\n    10→  title: string;\n    11→  description: string;\n    12→  repo: string;\n    13→  numberOfSandboxes: number;\n    14→  status: string;\n    15→}\n    16→\n    17→export class SandboxQueueProcessor {\n    18→  private daytona: Daytona;\n    19→  private queueDir: string;\n    20→  private logsDir: string;\n    21→  private config: {\n    22→    anthropicApiKey: string;\n    23→    githubToken: string;\n    24→    claudeModel: string;\n    25→  };\n    26→\n    27→  constructor(daytonaApiKey: string) {\n    28→    this.daytona = new Daytona({ apiKey: daytonaApiKey });\n    29→    const root = join(import.meta.dirname, \"..\", \"..\");\n    30→    this.queueDir = join(root, \"request_queue\");\n    31→    this.logsDir = join(root, \"logs\");\n    32→    this.config = {\n    33→      anthropicApiKey: process.env.ANTHROPIC_API_KEY!,\n    34→      githubToken: process.env.GITHUB_TOKEN!,\n    35→      claudeModel: \"claude-sonnet-4-5-20250929\",\n    36→    };\n    37→  }\n    38→\n    39→  async processQueue(): Promise<void> {\n    40→    const tasks = await this.loadTasksFromQueue();\n    41→\n    42→    for (const task of tasks) {\n    43→      console.log(`Processing: ${task.title}`);\n    44→      await this.updateTaskStatus(task, \"In Progress\");\n    45→\n    46→      const sandboxTasks = Array.from(\n    47→        { length: task.numberOfSandboxes },\n    48→        (_, i) => this.runInSandbox(task, i + 1)\n    49→      );\n    50→      await Promise.all(sandboxTasks);\n    51→\n    52→      await this.updateTaskStatus(task, \"Done\");\n    53→      console.log(`Completed: ${task.title}`);\n    54→    }\n    55→  }\n    56→\n    57→  private async loadTasksFromQueue(): Promise<TaskRequest[]> {\n    58→    const files = (await readdir(this.queueDir)).filter((f) =>\n    59→      f.endsWith(\".md\")\n    60→    );\n    61→\n    62→    // Scan all queue files to find the highest existing AGI-{n} ID\n    63→    let maxId = 0;\n    64→    const allData: { file: string; filePath: string; data: Record<string, unknown>; raw: string }[] = [];\n    65→    for (const file of files) {\n    66→      const filePath = join(this.queueDir, file);\n    67→      const raw = await readFile(filePath, \"utf-8\");\n    68→      const { data } = matter(raw);\n    69→      allData.push({ file, filePath, data, raw });\n    70→      if (typeof data.id === \"string\") {\n    71→        const match = data.id.match(/^AGI-(\\d+)$/);\n    72→        if (match) maxId = Math.max(maxId, parseInt(match[1], 10));\n    73→      }\n    74→    }\n    75→\n    76→    // Assign IDs to Backlog tasks missing one, and collect runnable tasks\n    77→    const tasks: TaskRequest[] = [];\n    78→    for (const { file, filePath, data } of allData) {\n    79→      if (data.status === \"Backlog\" && !data.id) {\n    80→        maxId++;\n    81→        data.id = `AGI-${maxId}`;\n    82→        await writeFile(filePath, matter.stringify(\"\", data));\n    83→        console.log(`Assigned ${data.id} to ${file}`);\n    84→      }\n    85→      if (data.status === \"Backlog\") {\n    86→        tasks.push({\n    87→          id: data.id as string,\n    88→          file,\n    89→          filePath,\n    90→          title: data.title as string,\n    91→          description: data.description as string,\n    92→          repo: data.repo as string,\n    93→          numberOfSandboxes: data.number_of_sandboxes as number,\n    94→          status: data.status as string,\n    95→        });\n    96→      }\n    97→    }\n    98→\n    99→    return tasks;\n   100→  }\n   101→\n   102→  private async updateTaskStatus(\n   103→    task: TaskRequest,\n   104→    status: string\n   105→  ): Promise<void> {\n   106→    const raw = await readFile(task.filePath, \"utf-8\");\n   107→    const { data } = matter(raw);\n   108→    await writeFile(\n   109→      task.filePath,\n   110→      matter.stringify(\"\", { ...data, status })\n   111→    );\n   112→  }\n   113→\n   114→  private async runInSandbox(\n   115→    task: TaskRequest,\n   116→    sandboxIndex: number\n   117→  ): Promise<void> {\n   118→    const label = `${task.title}-${sandboxIndex}`;\n   119→    const logDir = join(this.logsDir, task.id);\n   120→    const logFile = join(logDir, `agent-${sandboxIndex}.log`);\n   121→\n   122→    await mkdir(logDir, { recursive: true });\n   123→    const header = [\n   124→      \"=== Agent Log ===\",\n   125→      `Ticket: ${task.id}`,\n   126→      `Title: ${task.title}`,\n   127→      `Queue File: request_queue/${task.file}`,\n   128→      `Sandbox: agent-${sandboxIndex}`,\n   129→      `Started: ${new Date().toISOString()}`,\n   130→      \"===\\n\\n\",\n   131→    ].join(\"\\n\");\n   132→    await writeFile(logFile, header);\n   133→\n   134→    const sandbox = await this.daytona.create({ language: \"typescript\" });\n   135→    console.log(`[${label}] Sandbox created`);\n   136→\n   137→    try {\n   138→      const repoDir = await this.setupSandboxEnvironment(sandbox, task.repo, label);\n   139→      await this.installClaudeCLI(sandbox, label);\n   140→      await this.installGitHubCLI(sandbox, label);\n   141→      await this.configureGit(sandbox, label);\n   142→      await this.executeClaudeCommand(sandbox, task, repoDir, label, logFile);\n   143→    } finally {\n   144→      await sandbox.delete();\n   145→      const footer = `\\n=== Finished: ${new Date().toISOString()} ===\\n`;\n   146→      await appendFile(logFile, footer);\n   147→      console.log(`[${label}] Deleted`);\n   148→    }\n   149→  }\n   150→\n   151→  private async setupSandboxEnvironment(\n   152→    sandbox: Sandbox,\n   153→    repo: string,\n   154→    label: string\n   155→  ): Promise<string> {\n   156→    const repoDir = \"/home/daytona/repo\";\n   157→    await sandbox.git.clone(repo, repoDir);\n   158→    console.log(`[${label}] Repo cloned`);\n   159→    return repoDir;\n   160→  }\n   161→\n   162→  private async installClaudeCLI(\n   163→    sandbox: Sandbox,\n   164→    label: string\n   165→  ): Promise<void> {\n   166→    console.log(`[${label}] Installing Claude CLI...`);\n   167→    const claudeInstall = await sandbox.process.executeCommand(\n   168→      \"mkdir -p ~/.npm-global && npm config set prefix '~/.npm-global' && npm install -g @anthropic-ai/claude-code\"\n   169→    );\n   170→    console.log(`[${label}] Claude CLI exit code: ${claudeInstall.exitCode}`);\n   171→\n   172→    if (claudeInstall.exitCode !== 0) {\n   173→      console.error(\n   174→        `[${label}] Failed to install Claude CLI: ${claudeInstall.result}`\n   175→      );\n   176→      throw new Error(\"Failed to install Claude CLI\");\n   177→    }\n   178→\n   179→    const claudeVerify = await sandbox.process.executeCommand(\n   180→      \"export PATH=~/.npm-global/bin:$PATH && which claude && claude --version\"\n   181→    );\n   182→    console.log(`[${label}] Claude CLI location and version: ${claudeVerify.result}`);\n   183→  }\n   184→\n   185→  private async installGitHubCLI(\n   186→    sandbox: Sandbox,\n   187→    label: string\n   188→  ): Promise<void> {\n   189→    console.log(`[${label}] Installing GitHub CLI from binary...`);\n   190→    const ghInstall = await sandbox.process.executeCommand(\n   191→      \"GH_VERSION=2.86.0 && mkdir -p ~/bin && curl -fsSL https://github.com/cli/cli/releases/download/v${GH_VERSION}/gh_${GH_VERSION}_linux_amd64.tar.gz -o /tmp/gh.tar.gz && tar -xzf /tmp/gh.tar.gz -C /tmp && cp /tmp/gh_${GH_VERSION}_linux_amd64/bin/gh ~/bin/gh && chmod +x ~/bin/gh && export PATH=~/bin:$PATH\"\n   192→    );\n   193→    console.log(`[${label}] GitHub CLI install exit code: ${ghInstall.exitCode}`);\n   194→\n   195→    if (ghInstall.exitCode !== 0) {\n   196→      console.error(\n   197→        `[${label}] Failed to install gh CLI: ${ghInstall.result}`\n   198→      );\n   199→      throw new Error(\"Failed to install gh CLI\");\n   200→    }\n   201→\n   202→    const ghVerify = await sandbox.process.executeCommand(\n   203→      \"export PATH=~/bin:$PATH && gh --version\"\n   204→    );\n   205→    console.log(`[${label}] GitHub CLI version: ${ghVerify.result}`);\n   206→  }\n   207→\n   208→  private async configureGit(sandbox: Sandbox, label: string): Promise<void> {\n   209→    console.log(`[${label}] Configuring git...`);\n   210→    await sandbox.process.executeCommand(\n   211→      'git config --global user.email \"claude@anthropic.com\"'\n   212→    );\n   213→    await sandbox.process.executeCommand(\n   214→      'git config --global user.name \"Claude Agent\"'\n   215→    );\n   216→    console.log(`[${label}] Git configured`);\n   217→  }\n   218→\n   219→  private async executeClaudeCommand(\n   220→    sandbox: Sandbox,\n   221→    task: TaskRequest,\n   222→    repoDir: string,\n   223→    label: string,\n   224→    logFile: string\n   225→  ): Promise<void> {\n   226→    const branchName = `feat/${task.id}`;\n   227→    const prTitle = `${task.id}: ${task.title}`;\n   228→    const fullPrompt = `You are working in a cloned git repo. Your task:\n   229→\n   230→1. Create a new branch named \"${branchName}\"\n   231→2. Implement the following feature: ${task.description}\n   232→3. Commit your changes with a clear commit message\n   233→4. Push the branch to origin\n   234→5. Create a pull request using \\`gh pr create\\` with title \"${prTitle}\" and a clear description\n   235→\n   236→IMPORTANT: Use \\`gh\\` CLI for creating the PR (GITHUB_TOKEN is already set in the environment). Do NOT use interactive flags.`;\n   237→\n   238→    const escaped = fullPrompt.replace(/'/g, \"'\\\\''\");\n   239→    const claudeCmd = `claude -p '${escaped}' --dangerously-skip-permissions --output-format=stream-json --model ${this.config.claudeModel} --verbose`;\n   240→\n   241→    console.log(`[${label}] Starting Claude via PTY...`);\n   242→\n   243→    const decoder = new TextDecoder();\n   244→    let buffer = \"\";\n   245→\n   246→    const pty = await sandbox.process.createPty({\n   247→      id: `claude-${label}-${Date.now()}`,\n   248→      cwd: repoDir,\n   249→      envs: {\n   250→        ANTHROPIC_API_KEY: this.config.anthropicApiKey,\n   251→        GITHUB_TOKEN: this.config.githubToken,\n   252→        PATH: \"/home/daytona/.npm-global/bin:/home/daytona/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n   253→      },\n   254→      onData: (data: Uint8Array) => {\n   255→        const text = decoder.decode(data, { stream: true });\n   256→        process.stdout.write(`[${label}] ${text}`);\n   257→\n   258→        buffer += text;\n   259→        const lines = buffer.split(\"\\n\");\n   260→        buffer = lines.pop()!;\n   261→\n   262→        for (const line of lines) {\n   263→          this.handleStreamLine(line, label, logFile);\n   264→        }\n   265→      },\n   266→    });\n   267→\n   268→    await pty.waitForConnection();\n   269→    pty.sendInput(`${claudeCmd}\\n`);\n   270→    pty.sendInput(\"exit\\n\");\n   271→\n   272→    const result = await pty.wait();\n   273→\n   274→    // Flush remaining buffer\n   275→    if (buffer.trim()) {\n   276→      this.handleStreamLine(buffer, label, logFile);\n   277→    }\n   278→\n   279→    console.log(`[${label}] PTY exited with code: ${result.exitCode}`);\n   280→    await appendFile(logFile, `\\nPTY exited with code: ${result.exitCode}\\n`);\n   281→  }\n   282→\n   283→  private handleStreamLine(line: string, label: string, logFile: string): void {\n   284→    const stripped = line.replace(/\\x1b\\[[0-9;]*[a-zA-Z]/g, \"\").trim();\n   285→    if (!stripped) return;\n   286→\n   287→    if (!stripped.startsWith(\"{\")) {\n   288→      appendFile(logFile, `[raw] ${stripped}\\n`);\n   289→      return;\n   290→    }\n   291→\n   292→    try {\n   293→      const event = JSON.parse(stripped);\n   294→      console.log(`[${label}:json] ${JSON.stringify(event)}`);\n   295→      appendFile(logFile, `[json] ${JSON.stringify(event)}\\n`);\n   296→\n   297→      if (event.type === \"assistant\" && event.message?.content) {\n   298→        for (const block of event.message.content) {\n   299→          if (block.type === \"text\") {\n   300→            console.log(`\\n[${label}:assistant] ${block.text}`);\n   301→          }\n   302→        }\n   303→      } else if (event.type === \"result\") {\n   304→        console.log(`\\n[${label}:result] ${event.result}`);\n   305→      }\n   306→    } catch {\n   307→      appendFile(logFile, `[raw] ${stripped}\\n`);\n   308→    }\n   309→  }\n   310→}\n   311→"}]},"uuid":"4fc50a5b-c586-4cdc-a5fd-7ea6e295e288","timestamp":"2026-02-14T12:03:06.557Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"608d4747-d567-4b79-84f2-66e55ec5251f","timestamp":"2026-02-14T12:03:06.591Z"}
{"parentUuid":"608d4747-d567-4b79-84f2-66e55ec5251f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:03:08.143Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01BoQ1CVGKR2iSScRc5f1GuP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HBj8iRZXRyqW7rFERMX2T6","name":"Read","input":{"file_path":"/Users/ob1/projects/startup/horizon-cli-agent/src/index.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4723,"cache_read_input_tokens":33085,"cache_creation":{"ephemeral_5m_input_tokens":4723,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vnfBCCmkUp1zxBGLb1","uuid":"e0829829-ecdd-4e2f-9040-3601ee9241f4"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"43422747-5088-4de1-8d33-9c0ed1de3bf5","timestamp":"2026-02-14T12:03:08.143Z"}
{"parentUuid":"43422747-5088-4de1-8d33-9c0ed1de3bf5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:03:08.353Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01BoQ1CVGKR2iSScRc5f1GuP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RgPpbQtaYcxnDRkVh4fuoL","name":"Read","input":{"file_path":"/Users/ob1/projects/startup/horizon-cli-agent/src/config.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":4723,"cache_read_input_tokens":33085,"cache_creation":{"ephemeral_5m_input_tokens":4723,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vnfBCCmkUp1zxBGLb1","uuid":"8a2a12b0-3dda-4028-9bdb-fb2a6965ae22"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"7d353930-0340-40a6-b69d-3f6242dc3a37","timestamp":"2026-02-14T12:03:08.353Z"}
{"parentUuid":"7d353930-0340-40a6-b69d-3f6242dc3a37","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RgPpbQtaYcxnDRkVh4fuoL","type":"tool_result","content":"     1→import { execSync } from 'child_process';\n     2→import { readFileSync, existsSync } from 'fs';\n     3→import { join } from 'path';\n     4→import { HorizonConfig, ProviderName, ClaudeModel, CodexReasoningEffort, CodexAgentReasoningConfig, MergeMode } from './types.js';\n     5→import { parseArgs } from 'util';\n     6→\n     7→// Get the git repo root directory\n     8→export function getRepoRoot(): string {\n     9→  try {\n    10→    return execSync('git rev-parse --show-toplevel', { encoding: 'utf-8' }).trim();\n    11→  } catch {\n    12→    // Fallback to current directory if not in a git repo\n    13→    return process.cwd();\n    14→  }\n    15→}\n    16→\n    17→// Check if current directory is inside a git repository\n    18→export function isGitRepository(): boolean {\n    19→  try {\n    20→    execSync('git rev-parse --is-inside-work-tree', { encoding: 'utf-8', stdio: 'pipe' });\n    21→    return true;\n    22→  } catch {\n    23→    return false;\n    24→  }\n    25→}\n    26→\n    27→// Load .horizon/env file if it exists\n    28→function loadHorizonEnv(): void {\n    29→  const skipEnvFile = process.env.HORIZON_SKIP_ENV_FILE?.toLowerCase();\n    30→  if (skipEnvFile === '1' || skipEnvFile === 'true') {\n    31→    return;\n    32→  }\n    33→\n    34→  const envPath = join(getRepoRoot(), '.horizon', 'env');\n    35→  if (!existsSync(envPath)) {\n    36→    return;\n    37→  }\n    38→\n    39→  try {\n    40→    const content = readFileSync(envPath, 'utf-8');\n    41→    for (const line of content.split('\\n')) {\n    42→      const trimmed = line.trim();\n    43→      // Skip empty lines and comments\n    44→      if (!trimmed || trimmed.startsWith('#')) {\n    45→        continue;\n    46→      }\n    47→      const eqIndex = trimmed.indexOf('=');\n    48→      if (eqIndex === -1) {\n    49→        continue;\n    50→      }\n    51→      const key = trimmed.slice(0, eqIndex);\n    52→      const value = trimmed.slice(eqIndex + 1);\n    53→      // Only set if not already in environment (env vars take precedence)\n    54→      if (!process.env[key]) {\n    55→        process.env[key] = value;\n    56→      }\n    57→    }\n    58→  } catch {\n    59→    // Ignore errors reading the file\n    60→  }\n    61→}\n    62→\n    63→// Load .horizon/env before reading config\n    64→loadHorizonEnv();\n    65→\n    66→// Parse CLI arguments\n    67→interface CLIArgs {\n    68→  provider?: ProviderName;\n    69→  gcpAutoStop?: boolean;\n    70→}\n    71→\n    72→function parseCLIArgs(): CLIArgs {\n    73→  try {\n    74→    const { values } = parseArgs({\n    75→      options: {\n    76→        provider: {\n    77→          type: 'string',\n    78→          short: 'p',\n    79→        },\n    80→        'gcp-auto-stop': {\n    81→          type: 'boolean',\n    82→        },\n    83→        help: {\n    84→          type: 'boolean',\n    85→          short: 'h',\n    86→        },\n    87→      },\n    88→      strict: false, // Allow unknown args\n    89→    });\n    90→\n    91→    // Show help if requested\n    92→    if (values.help) {\n    93→      console.log(`\n    94→Horizon - Linear-orchestrated autonomous agent system\n    95→\n    96→Usage:\n    97→  npm start [options]\n    98→\n    99→Options:\n   100→  -p, --provider <name>  Provider to use: claude (default) or codex\n   101→  --gcp-auto-stop        Auto-stop GCP VM when no work available\n   102→  -h, --help             Show this help message\n   103→\n   104→Environment Variables:\n   105→  HORIZON_PROVIDER             Provider: claude (default) or codex\n   106→  HORIZON_CLAUDE_MODEL         Claude model: opus (default), sonnet, or haiku\n   107→  HORIZON_MAX_ITERATIONS       Limit iterations (0 = unlimited)\n   108→  HORIZON_RATE_LIMIT_MAX_RETRIES  Max retries on rate limit (default: 3)\n   109→  HORIZON_GCP_AUTO_STOP        Auto-stop GCP VM when no work (true/false)\n   110→  CODEX_MODEL                Codex model name\n   111→  CODEX_REASONING_EFFORT     Global default: low, medium, high (default), extra_high\n   112→  CODEX_AGENT1_REASONING     Agent 1 reasoning: low, medium, high (default), extra_high\n   113→  CODEX_AGENT2_REASONING     Agent 2 reasoning: low, medium, high (default), extra_high\n   114→  CODEX_AGENT3_REASONING     Agent 3 reasoning: low, medium (default), high, extra_high\n   115→  HORIZON_QUICK_CHECK_INTERVAL_MINUTES   Quick check interval (default: 5)\n   116→  HORIZON_FULL_CHECK_INTERVAL_MINUTES    Full check fallback interval (default: 120)\n   117→  HORIZON_MERGE_MODE                     Merge mode: auto (default), merge, or pr\n   118→\n   119→Examples:\n   120→  npm start                      # Run with Claude (default)\n   121→  npm start -- --provider codex  # Run with Codex\n   122→  npm start -- -p codex          # Short form\n   123→  npm start -- --gcp-auto-stop   # Auto-stop VM when no work available\n   124→`);\n   125→      process.exit(0);\n   126→    }\n   127→\n   128→    const result: CLIArgs = {};\n   129→\n   130→    if (values.provider) {\n   131→      const provider = (values.provider as string).toLowerCase();\n   132→      if (provider === 'codex' || provider === 'claude') {\n   133→        result.provider = provider as ProviderName;\n   134→      } else {\n   135→        console.error(`Invalid provider: ${values.provider}. Must be 'claude' or 'codex'.`);\n   136→        process.exit(1);\n   137→      }\n   138→    }\n   139→\n   140→    if (values['gcp-auto-stop']) {\n   141→      result.gcpAutoStop = true;\n   142→    }\n   143→\n   144→    return result;\n   145→  } catch {\n   146→    return {};\n   147→  }\n   148→}\n   149→\n   150→// Parse CLI args once at module load\n   151→const cliArgs = parseCLIArgs();\n   152→\n   153→// Parse provider from CLI args or environment variable\n   154→function getProvider(): ProviderName {\n   155→  // CLI args take precedence over env vars\n   156→  if (cliArgs.provider) return cliArgs.provider;\n   157→  const envProvider = process.env.HORIZON_PROVIDER?.toLowerCase();\n   158→  if (envProvider === 'codex') return 'codex';\n   159→  return 'claude'; // Default\n   160→}\n   161→\n   162→// Parse Claude model from environment variable\n   163→function getClaudeModel(): ClaudeModel {\n   164→  const envModel = process.env.HORIZON_CLAUDE_MODEL?.toLowerCase();\n   165→  if (envModel === 'sonnet') return 'sonnet';\n   166→  if (envModel === 'haiku') return 'haiku';\n   167→  return 'opus'; // Default\n   168→}\n   169→\n   170→// Parse Codex reasoning effort from environment variable\n   171→function getCodexReasoningEffort(): CodexReasoningEffort {\n   172→  const envEffort = process.env.CODEX_REASONING_EFFORT?.toLowerCase();\n   173→  if (envEffort === 'low') return 'low';\n   174→  if (envEffort === 'medium') return 'medium';\n   175→  if (envEffort === 'extra_high') return 'extra_high';\n   176→  return 'high'; // Default\n   177→}\n   178→\n   179→// Parse max iterations from environment variable\n   180→function getMaxIterations(): number {\n   181→  const envMax = process.env.HORIZON_MAX_ITERATIONS;\n   182→  if (envMax) {\n   183→    const parsed = parseInt(envMax, 10);\n   184→    if (!isNaN(parsed) && parsed >= 0) {\n   185→      return parsed;\n   186→    }\n   187→  }\n   188→  return 0; // Default: unlimited (0 means no limit)\n   189→}\n   190→\n   191→// Parse rate limit max retries from environment variable\n   192→function getRateLimitMaxRetries(): number {\n   193→  const envMax = process.env.HORIZON_RATE_LIMIT_MAX_RETRIES;\n   194→  if (envMax) {\n   195→    const parsed = parseInt(envMax, 10);\n   196→    if (!isNaN(parsed) && parsed >= 0) {\n   197→      return parsed;\n   198→    }\n   199→  }\n   200→  return 3; // Default: 3 retries\n   201→}\n   202→\n   203→// Parse GCP auto-stop from CLI args or environment variable\n   204→function getGcpAutoStop(): boolean {\n   205→  // CLI args take precedence over env vars\n   206→  if (cliArgs.gcpAutoStop) return true;\n   207→  const envVal = process.env.HORIZON_GCP_AUTO_STOP?.toLowerCase();\n   208→  return envVal === 'true' || envVal === '1';\n   209→}\n   210→\n   211→// Parse quick check interval (default: 5 minutes)\n   212→function getQuickCheckInterval(): number {\n   213→  const envVal = process.env.HORIZON_QUICK_CHECK_INTERVAL_MINUTES;\n   214→  if (envVal) {\n   215→    const parsed = parseInt(envVal, 10);\n   216→    if (!isNaN(parsed) && parsed >= 1) {\n   217→      return parsed;\n   218→    }\n   219→  }\n   220→  return 5; // Default: 5 minutes\n   221→}\n   222→\n   223→// Parse full check interval (default: 120 minutes = 2 hours)\n   224→function getFullCheckInterval(): number {\n   225→  const envVal = process.env.HORIZON_FULL_CHECK_INTERVAL_MINUTES;\n   226→  if (envVal) {\n   227→    const parsed = parseInt(envVal, 10);\n   228→    if (!isNaN(parsed) && parsed >= 1) {\n   229→      return parsed;\n   230→    }\n   231→  }\n   232→  return 120; // Default: 120 minutes (2 hours)\n   233→}\n   234→\n   235→// Parse merge mode (default: auto)\n   236→function getMergeMode(): MergeMode {\n   237→  const envMode = process.env.HORIZON_MERGE_MODE?.toLowerCase();\n   238→  if (envMode === 'auto') return 'auto';\n   239→  if (envMode === 'merge') return 'merge';\n   240→  if (envMode === 'pr') return 'pr';\n   241→  return 'auto'; // Default: agent decides safest path\n   242→}\n   243→\n   244→// Parse per-agent reasoning effort from environment variables\n   245→// Agent 1 and 2 default to 'high', Agent 3 defaults to 'medium' (as specified in ticket RSK-40)\n   246→function getCodexAgentReasoning(): CodexAgentReasoningConfig {\n   247→  const globalDefault = getCodexReasoningEffort();\n   248→\n   249→  function parseAgentEffort(envVar: string, defaultValue: CodexReasoningEffort): CodexReasoningEffort {\n   250→    const effort = process.env[envVar]?.toLowerCase();\n   251→    if (effort === 'low') return 'low';\n   252→    if (effort === 'medium') return 'medium';\n   253→    if (effort === 'high') return 'high';\n   254→    if (effort === 'extra_high') return 'extra_high';\n   255→    return defaultValue;\n   256→  }\n   257→\n   258→  return {\n   259→    agent1: parseAgentEffort('CODEX_AGENT1_REASONING', globalDefault),\n   260→    agent2: parseAgentEffort('CODEX_AGENT2_REASONING', globalDefault),\n   261→    // Agent 3 defaults to 'medium' for cost efficiency\n   262→    agent3: parseAgentEffort('CODEX_AGENT3_REASONING', 'medium'),\n   263→  };\n   264→}\n   265→\n   266→// Build config from current environment\n   267→function buildConfig(): HorizonConfig {\n   268→  return {\n   269→    workingDirectory: getRepoRoot(),\n   270→    linearApiKey: process.env.LINEAR_API_KEY,\n   271→    linearTeamId: process.env.LINEAR_TEAM_KEY,\n   272→    gitBranch: 'main',\n   273→    staleTimeoutHours: 4,\n   274→    noWorkSleepMinutes: 60,\n   275→    errorSleepMinutes: 1,\n   276→\n   277→    // Provider configuration\n   278→    provider: getProvider(),\n   279→    claudeModel: getClaudeModel(),\n   280→    codexModel: process.env.CODEX_MODEL || 'gpt-5.2-codex',\n   281→    codexReasoningEffort: getCodexReasoningEffort(),\n   282→    codexAgentReasoning: getCodexAgentReasoning(),\n   283→    maxIterations: getMaxIterations(),\n   284→\n   285→    // Rate limit configuration\n   286→    rateLimitMaxRetries: getRateLimitMaxRetries(),\n   287→\n   288→    // GCP configuration\n   289→    gcpAutoStop: getGcpAutoStop(),\n   290→\n   291→    // Quick check configuration\n   292→    quickCheckIntervalMinutes: getQuickCheckInterval(),\n   293→    fullCheckIntervalMinutes: getFullCheckInterval(),\n   294→\n   295→    // Merge mode\n   296→    mergeMode: getMergeMode(),\n   297→  };\n   298→}\n   299→\n   300→// Initial config loaded at startup\n   301→export let config: HorizonConfig = buildConfig();\n   302→\n   303→/**\n   304→ * Gets the current config.\n   305→ * If reload is true, rebuilds config from process.env (useful after env changes).\n   306→ */\n   307→export function getConfig(reload = false): HorizonConfig {\n   308→  if (reload) {\n   309→    config = buildConfig();\n   310→  }\n   311→  return config;\n   312→}\n   313→"}]},"uuid":"9aaeefea-ac79-43c3-82ab-6b0f9b13e0e5","timestamp":"2026-02-14T12:03:08.410Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"c9fa88b2-e227-4ee1-ac7e-6d0d7d3e3fd3","timestamp":"2026-02-14T12:03:08.442Z"}
{"parentUuid":"c9fa88b2-e227-4ee1-ac7e-6d0d7d3e3fd3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HBj8iRZXRyqW7rFERMX2T6","type":"tool_result","content":"     1→import { existsSync, cpSync, mkdirSync } from 'fs';\n     2→import { join } from 'path';\n     3→import { execSync } from 'child_process';\n     4→import { getConfig, isGitRepository, getRepoRoot } from './config.js';\n     5→import { sleep, executeWithRateLimitRetry, RateLimitRetryConfig } from './lib/rate-limit.js';\n     6→import { loadPrompt } from './lib/prompts.js';\n     7→import { getCurrentBranch, ensureWorktree, removeWorktree } from './lib/git.js';\n     8→import { generatePodName } from './lib/loop-instance-name.js';\n     9→import { initLoopLogger, getCurrentOutputDir } from './lib/output-logger.js';\n    10→import { initLoopStats, logAgentStats, finalizeLoopStats } from './lib/stats-logger.js';\n    11→import { createProvider, ProviderResult } from './lib/provider.js';\n    12→import { extractLinearUrls, downloadIssueAttachments } from './lib/attachment-downloader.js';\n    13→import { createLinearClientWithSignedUrls, getIssueDescription } from './lib/linear-api.js';\n    14→import { isRunningOnGcp, stopGcpInstance } from './lib/gcp.js';\n    15→import { checkForUncompletedTickets } from './lib/linear-quick-check.js';\n    16→import { getVersion } from './lib/version.js';\n    17→import { checkForUpdates, displayUpdateNotification } from './lib/update-checker.js';\n    18→import { box, BOLD, DIM, CYAN, YELLOW, RESET } from './lib/ui.js';\n    19→import {\n    20→  ensureHorizonDir,\n    21→  ensureHorizonDocsDir,\n    22→  ensureGitignore,\n    23→  loadExistingConfig,\n    24→  saveEnvConfig,\n    25→  saveMcpConfig,\n    26→  copyPromptsToProject,\n    27→  checkAndDisplayCliAvailability,\n    28→  autoSelectProvider,\n    29→  validateLinearKey,\n    30→  fetchLinearTeams,\n    31→  checkLinearStatuses,\n    32→  createLinearStatuses,\n    33→  checkCodexLinearMcp,\n    34→  createPromptInterface,\n    35→  promptSecret,\n    36→  promptSelect,\n    37→  maskApiKey,\n    38→  LoadedConfig,\n    39→  TeamInfo,\n    40→  CliAvailability,\n    41→  SelectOption,\n    42→  saveCodexMcpConfig,\n    43→} from './lib/setup.js';\n    44→import { MergeMode, ProviderName } from './types.js';\n    45→\n    46→// Import providers to register them\n    47→import './lib/claude.js';\n    48→import './lib/codex.js';\n    49→\n    50→/**\n    51→ * Extracts the issue identifier (e.g., RSK-39) from Agent 1's output.\n    52→ * Agent 1 outputs this in the format \"**Identifier**: RSK-39\" or similar.\n    53→ */\n    54→function extractIssueIdentifier(agent1Output: string): string | null {\n    55→  // Try various patterns Agent 1 might use\n    56→  const patterns = [\n    57→    /\\*\\*Identifier\\*\\*:\\s*([A-Z]+-\\d+)/i,\n    58→    /\\*\\*Issue Identifier\\*\\*:\\s*([A-Z]+-\\d+)/i,\n    59→    /Issue ID[^:]*:\\s*[^\\n]*\\n[^*]*\\*\\*Identifier\\*\\*:\\s*([A-Z]+-\\d+)/i,\n    60→    /Identifier:\\s*([A-Z]+-\\d+)/i,\n    61→    /Branch:\\s*horizon\\/([A-Z]+-\\d+)/i,\n    62→    /\\b([A-Z]+-\\d+)\\b/,  // Fallback: any ticket-like pattern\n    63→  ];\n    64→\n    65→  for (const pattern of patterns) {\n    66→    const match = agent1Output.match(pattern);\n    67→    if (match) {\n    68→      return match[1];\n    69→    }\n    70→  }\n    71→\n    72→  return null;\n    73→}\n    74→\n    75→async function runLoop(podName: string, iteration: number): Promise<void> {\n    76→  const config = getConfig();\n    77→\n    78→  // Initialize output logger for this loop iteration\n    79→  // Pod name persists across all loops in this Horizon session\n    80→  initLoopLogger(podName, iteration);\n    81→\n    82→  // Initialize stats tracking for this loop iteration\n    83→  initLoopStats(podName, iteration);\n    84→\n    85→  console.log('\\n' + box(\n    86→    [`  Log Directory: ${getCurrentOutputDir()}  `],\n    87→    { title: `Loop ${iteration}`, color: CYAN, width: 60 },\n    88→  ));\n    89→  const loopStart = Date.now();\n    90→\n    91→  // ═══════════════════════════════════════════════════════════════════════════\n    92→  // AGENT 1: Linear Reader (uses configured provider)\n    93→  // ═══════════════════════════════════════════════════════════════════════════\n    94→  console.log(`\\n${BOLD}▸ Agent 1: Linear Reader${RESET}`);\n    95→\n    96→  const agent1Provider = createProvider(config.provider);\n    97→  const agent1BasePrompt = await loadPrompt('agent1-linear-reader');\n    98→  const agent1Prompt = `## Agent Instance\n    99→\n   100→You are part of pod: **${podName}** / Loop ${iteration} / Agent 1 (Linear Reader)\n   101→\n   102→This identifier format is: Pod Name / Loop Number / Agent Number (Role).\n   103→- **Pod Name**: ${podName} - persists for this entire Horizon session\n   104→- **Loop Number**: ${iteration} - increments each time Horizon processes a new ticket\n   105→- **Agent**: Agent 1 (Linear Reader) - your role in this loop\n   106→\n   107→## Linear Team Configuration\n   108→\n   109→**Team Key**: ${config.linearTeamId}\n   110→\n   111→Use this team key for all Linear MCP tool calls (list_issues, list_issue_statuses, update_issue, create_comment, etc.). Do NOT use any other team key.\n   112→\n   113→---\n   114→\n   115→${agent1BasePrompt}`;\n   116→\n   117→  // Select model based on provider\n   118→  const agent1Model = config.provider === 'codex' ? config.codexModel : 'opus';\n   119→\n   120→  // Rate limit retry config - uses configured max retries\n   121→  const retryConfig: RateLimitRetryConfig = { maxRetries: config.rateLimitMaxRetries };\n   122→\n   123→  // Agent 1 with rate limit retry\n   124→  const agent1Result = await executeWithRateLimitRetry(\n   125→    () => agent1Provider.spawn({\n   126→      prompt: agent1Prompt,\n   127→      model: agent1Model,\n   128→      allowedTools: ['mcp__linear__*'],\n   129→      reasoningEffort: config.provider === 'codex' ? config.codexAgentReasoning.agent1 : undefined,\n   130→    }, 1),\n   131→    retryConfig,\n   132→    'Agent 1 (Linear Reader)'\n   133→  );\n   134→\n   135→  // If still rate limited after max retries, skip this iteration\n   136→  if (agent1Result.rateLimited) {\n   137→    console.log('Agent 1 still rate limited after max retries. Skipping iteration.');\n   138→    return;\n   139→  }\n   140→\n   141→  // Log Agent 1 stats\n   142→  await logAgentStats(1, config.provider, agent1Model, {\n   143→    tokenUsage: agent1Result.tokenUsage,\n   144→    cost: agent1Result.cost,\n   145→    costEstimated: agent1Result.costEstimated,\n   146→    duration: agent1Result.duration,\n   147→    exitCode: agent1Result.exitCode,\n   148→    rateLimited: agent1Result.rateLimited,\n   149→    output: agent1Result.output,\n   150→  });\n   151→\n   152→  // Extract the text output from agent 1\n   153→  const agent1Output = agent1Result.finalOutput;\n   154→\n   155→  // Check if there's no work (look for the signal in the output)\n   156→  if (agent1Output.includes('no_work: true') || agent1Output.includes('NO_WORK')) {\n   157→    // Extract reason from agent output (format: \"NO_WORK\\n\\nReason: ...\")\n   158→    const reasonMatch = agent1Output.match(/Reason:\\s*([\\s\\S]*)/i);\n   159→    const reason = reasonMatch?.[1]?.trim() || 'No actionable issues found.';\n   160→\n   161→    // Wrap reason text to fit box width, then display\n   162→    const boxWidth = 64;\n   163→    const innerWidth = boxWidth - 4; // borders + padding\n   164→    const words = reason.split(/\\s+/);\n   165→    const wrappedLines: string[] = [];\n   166→    let currentLine = '';\n   167→    for (const word of words) {\n   168→      if (currentLine && (currentLine.length + 1 + word.length) > innerWidth) {\n   169→        wrappedLines.push(`  ${currentLine}`);\n   170→        currentLine = word;\n   171→      } else {\n   172→        currentLine = currentLine ? `${currentLine} ${word}` : word;\n   173→      }\n   174→    }\n   175→    if (currentLine) wrappedLines.push(`  ${currentLine}`);\n   176→\n   177→    console.log('\\n' + box(\n   178→      [`  ${YELLOW}Create tickets in Linear to give Horizon work.${RESET}`, '', ...wrappedLines],\n   179→      { title: 'No Work', color: YELLOW, width: boxWidth },\n   180→    ));\n   181→\n   182→    // If GCP auto-stop is enabled, check if we're on GCP and stop the instance\n   183→    if (config.gcpAutoStop) {\n   184→      console.log('GCP auto-stop is enabled. Checking if running on GCP...');\n   185→      const onGcp = await isRunningOnGcp();\n   186→      if (onGcp) {\n   187→        console.log('Running on GCP VM. Initiating instance stop...');\n   188→        const stopped = await stopGcpInstance();\n   189→        if (stopped) {\n   190→          console.log('Instance stop command issued. VM will shut down shortly.');\n   191→          // Give the stop command time to take effect\n   192→          await sleep(10000);\n   193→          process.exit(0);\n   194→        } else {\n   195→          console.log('Failed to stop GCP instance. Falling back to quick check.');\n   196→        }\n   197→      } else {\n   198→        console.log('Not running on GCP VM. Falling back to pulse check.');\n   199→      }\n   200→    }\n   201→\n   202→    // Two-tier polling: pulse check loop with fallback\n   203→    const fullCheckIntervalMs = config.fullCheckIntervalMinutes * 60 * 1000;\n   204→    const pulseCheckIntervalMs = config.quickCheckIntervalMinutes * 60 * 1000;\n   205→    let lastFullCheck = Date.now(); // Agent 1 just ran\n   206→\n   207→    while (true) {\n   208→      console.log(`\\n[Pulse Check] Sleeping ${config.quickCheckIntervalMinutes} minutes...`);\n   209→      await sleep(pulseCheckIntervalMs);\n   210→\n   211→      // Check if fallback is due\n   212→      const timeSinceFullCheck = Date.now() - lastFullCheck;\n   213→      const fallbackDue = timeSinceFullCheck >= fullCheckIntervalMs;\n   214→\n   215→      if (fallbackDue) {\n   216→        console.log('[Pulse Check] Full check interval reached. Running full Agent 1 check.');\n   217→        return; // Exit to let main loop run Agent 1\n   218→      }\n   219→\n   220→      // Perform pulse check\n   221→      if (!config.linearApiKey || !config.linearTeamId) {\n   222→        console.log('[Pulse Check] Missing Linear credentials. Falling back to Agent 1.');\n   223→        return;\n   224→      }\n   225→\n   226→      console.log('[Pulse Check] Checking for ready-to-work tickets...');\n   227→      const result = await checkForUncompletedTickets(config.linearApiKey, config.linearTeamId);\n   228→\n   229→      if (result.error) {\n   230→        console.log(`[Pulse Check] Error: ${result.error}. Falling back to Agent 1.`);\n   231→        return; // Error - let Agent 1 handle it\n   232→      }\n   233→\n   234→      // Display status category stats\n   235→      const { statusCounts } = result;\n   236→      const statsLine = `[Pulse Check] Status: ${statusCounts.completed} done, ${statusCounts.started} in progress, ${statusCounts.unstarted} todo, ${statusCounts.backlog} backlog, ${statusCounts.canceled} canceled`;\n   237→      console.log(statsLine);\n   238→\n   239→      if (result.hasWork) {\n   240→        console.log(`[Pulse Check] Found ${result.ticketCount} ready-to-work ticket(s). Initiating next loop.`);\n   241→        return; // Work found - run Agent 1\n   242→      }\n   243→\n   244→      // No work found - continue pulse check loop\n   245→      const minutesUntilFallback = Math.round((fullCheckIntervalMs - timeSinceFullCheck) / 60000);\n   246→      console.log(`[Pulse Check] No ready-to-work tickets. Checking again in ${config.quickCheckIntervalMinutes} minutes (full check in ${minutesUntilFallback} minutes).`);\n   247→    }\n   248→  }\n   249→\n   250→  // ═══════════════════════════════════════════════════════════════════════════\n   251→  // ATTACHMENT DOWNLOAD: Download any attached images/files from the Linear issue\n   252→  // ═══════════════════════════════════════════════════════════════════════════\n   253→  let attachmentPaths: string[] = [];\n   254→  const issueIdentifier = extractIssueIdentifier(agent1Output);\n   255→\n   256→  if (issueIdentifier && config.linearApiKey) {\n   257→    console.log('\\nDownloading attachments from Linear...');\n   258→    try {\n   259→      // Fetch fresh description from Linear API with signed URLs\n   260→      // The public-file-urls-expire-in header makes Linear return pre-signed URLs (1 hour expiry)\n   261→      const linearClient = createLinearClientWithSignedUrls(config.linearApiKey, 3600);\n   262→      const freshDescription = await getIssueDescription(linearClient, issueIdentifier);\n   263→\n   264→      if (freshDescription) {\n   265→        // Extract URLs from the fresh description (has valid signatures)\n   266→        const attachments = extractLinearUrls(freshDescription);\n   267→        if (attachments.length > 0) {\n   268→          const result = await downloadIssueAttachments(config.linearApiKey, issueIdentifier, attachments);\n   269→          attachmentPaths = result.attachments.map(a => a.localPath);\n   270→        }\n   271→      }\n   272→\n   273→      if (attachmentPaths.length > 0) {\n   274→        console.log(`Downloaded ${attachmentPaths.length} attachment(s)`);\n   275→      } else {\n   276→        console.log('No attachments found in issue');\n   277→      }\n   278→    } catch (error) {\n   279→      console.log('Failed to download attachments (continuing without them):', error);\n   280→    }\n   281→  }\n   282→\n   283→  // ═══════════════════════════════════════════════════════════════════════════\n   284→  // WORKTREE SETUP: Create isolated working directory for Agent 2\n   285→  // ═══════════════════════════════════════════════════════════════════════════\n   286→  let worktreePath: string | null = null;\n   287→  if (issueIdentifier) {\n   288→    try {\n   289→      console.log(`\\nSetting up worktree for ${issueIdentifier}...`);\n   290→      worktreePath = ensureWorktree(issueIdentifier);\n   291→      console.log(`Worktree ready: ${worktreePath}`);\n   292→\n   293→      // Copy .horizon/prompts/ into worktree so agent can read stage-specific instructions\n   294→      const sourcePromptsDir = join(config.workingDirectory, '.horizon', 'prompts');\n   295→      if (existsSync(sourcePromptsDir)) {\n   296→        const destHorizonDir = join(worktreePath, '.horizon');\n   297→        mkdirSync(destHorizonDir, { recursive: true });\n   298→        cpSync(sourcePromptsDir, join(destHorizonDir, 'prompts'), { recursive: true });\n   299→        // Copy MCP config if it exists\n   300→        const mcpConfigPath = join(config.workingDirectory, '.horizon', 'mcp.json');\n   301→        if (existsSync(mcpConfigPath)) {\n   302→          cpSync(mcpConfigPath, join(destHorizonDir, 'mcp.json'));\n   303→        }\n   304→      }\n   305→\n   306→      // Install dependencies in worktree\n   307→      console.log('Installing dependencies in worktree...');\n   308→      execSync('npm install', { stdio: 'pipe', cwd: worktreePath });\n   309→      console.log('Dependencies installed.');\n   310→    } catch (error) {\n   311→      console.log('Failed to create worktree (falling back to repo root):', error);\n   312→      worktreePath = null;\n   313→    }\n   314→  }\n   315→\n   316→  // ═══════════════════════════════════════════════════════════════════════════\n   317→  // AGENT 2: Worker (uses configured provider - Claude or Codex)\n   318→  // ═══════════════════════════════════════════════════════════════════════════\n   319→  console.log(`\\n${BOLD}▸ Agent 2: Worker${RESET}`);\n   320→\n   321→  // Use configured provider for Agent 2\n   322→  const agent2Provider = createProvider(config.provider);\n   323→\n   324→  // Build attachment context section if we have downloaded files\n   325→  const attachmentSection = attachmentPaths.length > 0\n   326→    ? `\n   327→\n   328→## Downloaded Attachments\n   329→\n   330→The following files have been downloaded locally from the Linear issue. You can read/view these files using the Read tool:\n   331→\n   332→${attachmentPaths.map(p => `- ${p}`).join('\\n')}\n   333→\n   334→`\n   335→    : '';\n   336→\n   337→  // Build worktree context for the prompt\n   338→  const worktreeContext = worktreePath\n   339→    ? `\n   340→\n   341→## Worktree Context\n   342→\n   343→You are running in an isolated git worktree. Your current working directory is already on the correct branch.\n   344→\n   345→- **Working Directory**: \\`${worktreePath}\\`\n   346→- **Repo Root**: \\`${config.workingDirectory}\\`\n   347→- **Branch**: \\`horizon/${issueIdentifier}\\`\n   348→\n   349→**Important**: Do NOT run \\`git checkout main\\` in this worktree. All merges are handled via PR creation.\n   350→`\n   351→    : '';\n   352→\n   353→  // Build worker prompt by combining the base prompt with agent 1's output\n   354→  const workerBasePrompt = await loadPrompt('agent2-worker');\n   355→  const workerPrompt = `## Agent Instance\n   356→\n   357→You are part of pod: **${podName}** / Loop ${iteration} / Agent 2 (Worker)\n   358→\n   359→This identifier format is: Pod Name / Loop Number / Agent Number (Role).\n   360→- **Pod Name**: ${podName} - persists for this entire Horizon session\n   361→- **Loop Number**: ${iteration} - increments each time Horizon processes a new ticket\n   362→- **Agent**: Agent 2 (Worker) - your role in this loop\n   363→\n   364→## Linear Team Configuration\n   365→\n   366→**Team Key**: ${config.linearTeamId}\n   367→\n   368→This team key is used for all Linear MCP tool calls. While you don't make Linear calls directly, this context may be passed to other agents.\n   369→\n   370→---\n   371→\n   372→## Context from Linear (gathered by Agent 1)\n   373→\n   374→${agent1Output}\n   375→${attachmentSection}${worktreeContext}\n   376→---\n   377→\n   378→${workerBasePrompt}`;\n   379→\n   380→  // Agent 2 with rate limit retry\n   381→  let agent2Result: ProviderResult;\n   382→  if (config.provider === 'codex') {\n   383→    agent2Result = await executeWithRateLimitRetry(\n   384→      () => agent2Provider.spawn({\n   385→        prompt: workerPrompt,\n   386→        model: config.codexModel,\n   387→        reasoningEffort: config.codexReasoningEffort,\n   388→        workingDirectory: worktreePath || undefined,\n   389→      }, 2),\n   390→      retryConfig,\n   391→      'Agent 2 (Worker)'\n   392→    );\n   393→  } else {\n   394→    agent2Result = await executeWithRateLimitRetry(\n   395→      () => agent2Provider.spawn({\n   396→        prompt: workerPrompt,\n   397→        model: config.claudeModel,\n   398→        workingDirectory: worktreePath || undefined,\n   399→      }, 2),\n   400→      retryConfig,\n   401→      'Agent 2 (Worker)'\n   402→    );\n   403→  }\n   404→\n   405→  // Note: Agent 2 rate limits are logged but we continue to Agent 3 regardless\n   406→  if (agent2Result.rateLimited) {\n   407→    console.log('Agent 2 still rate limited after max retries. Continuing to Agent 3 to log status.');\n   408→  }\n   409→\n   410→  // Log Agent 2 stats\n   411→  const agent2Model = config.provider === 'codex' ? config.codexModel : config.claudeModel;\n   412→  await logAgentStats(2, config.provider, agent2Model, {\n   413→    tokenUsage: agent2Result.tokenUsage,\n   414→    cost: agent2Result.cost,\n   415→    costEstimated: agent2Result.costEstimated,\n   416→    duration: agent2Result.duration,\n   417→    exitCode: agent2Result.exitCode,\n   418→    rateLimited: agent2Result.rateLimited,\n   419→    output: agent2Result.output,\n   420→  });\n   421→\n   422→  const agent2Output = agent2Result.finalOutput;\n   423→\n   424→  // Clean up worktree after Agent 2 completes\n   425→  if (worktreePath) {\n   426→    try {\n   427→      console.log(`Cleaning up worktree: ${worktreePath}`);\n   428→      removeWorktree(worktreePath);\n   429→    } catch (error) {\n   430→      console.log('Warning: Failed to remove worktree:', error);\n   431→    }\n   432→  }\n   433→\n   434→  // ═══════════════════════════════════════════════════════════════════════════\n   435→  // AGENT 3: Linear Writer (uses configured provider)\n   436→  // ═══════════════════════════════════════════════════════════════════════════\n   437→  console.log(`\\n${BOLD}▸ Agent 3: Linear Writer${RESET}`);\n   438→\n   439→  const agent3Provider = createProvider(config.provider);\n   440→  const writerBasePrompt = await loadPrompt('agent3-linear-writer');\n   441→\n   442→  // Format cost strings with estimated marker for Codex\n   443→  const agent1CostStr = agent1Result.costEstimated\n   444→    ? `~$${agent1Result.cost.toFixed(4)} (estimated)`\n   445→    : `$${agent1Result.cost.toFixed(4)}`;\n   446→  const agent2CostStr = agent2Result.costEstimated\n   447→    ? `~$${agent2Result.cost.toFixed(4)} (estimated)`\n   448→    : `$${agent2Result.cost.toFixed(4)}`;\n   449→\n   450→  const writerPrompt = `## Agent Instance\n   451→\n   452→You are part of pod: **${podName}** / Loop ${iteration} / Agent 3 (Linear Writer)\n   453→\n   454→This identifier format is: Pod Name / Loop Number / Agent Number (Role).\n   455→- **Pod Name**: ${podName} - persists for this entire Horizon session\n   456→- **Loop Number**: ${iteration} - increments each time Horizon processes a new ticket\n   457→- **Agent**: Agent 3 (Linear Writer) - your role in this loop\n   458→\n   459→**IMPORTANT**: Include the pod name (${podName}) in all comments you post to Linear so that when multiple pods work in parallel, we can identify which one made which comment.\n   460→\n   461→## Linear Team Configuration\n   462→\n   463→**Team Key**: ${config.linearTeamId}\n   464→\n   465→Use this team key for all Linear MCP tool calls (update_issue, create_comment, create_issue for sub-issues, etc.). Do NOT use any other team key.\n   466→\n   467→---\n   468→\n   469→## Context from Agent 1 (Linear issue details)\n   470→\n   471→${agent1Output}\n   472→\n   473→---\n   474→\n   475→## Results from Agent 2 (Work performed)\n   476→\n   477→${agent2Output}\n   478→\n   479→---\n   480→\n   481→## Session Stats\n   482→\n   483→- Pod: ${podName}\n   484→- Loop: ${iteration}\n   485→\n   486→### Agent 1 (Linear Reader)\n   487→- Provider: ${config.provider}\n   488→- Model: ${agent1Model}\n   489→- Cost: ${agent1CostStr}\n   490→- Duration: ${Math.round(agent1Result.duration / 1000)}s\n   491→- Tokens: in=${agent1Result.tokenUsage.input.toLocaleString()} out=${agent1Result.tokenUsage.output.toLocaleString()} cached=${agent1Result.tokenUsage.cached.toLocaleString()}\n   492→\n   493→### Agent 2 (Worker)\n   494→- Provider: ${config.provider}\n   495→- Model: ${agent2Model}\n   496→- Cost: ${agent2CostStr}\n   497→- Duration: ${Math.round(agent2Result.duration / 1000)}s\n   498→- Tokens: in=${agent2Result.tokenUsage.input.toLocaleString()} out=${agent2Result.tokenUsage.output.toLocaleString()} cached=${agent2Result.tokenUsage.cached.toLocaleString()}\n   499→- Exit code: ${agent2Result.exitCode}\n   500→- Rate limited: ${agent2Result.rateLimited}\n   501→\n   502→### Loop Totals (Agent 1 + Agent 2)\n   503→- Total Cost: $${(agent1Result.cost + agent2Result.cost).toFixed(4)}${(agent1Result.costEstimated || agent2Result.costEstimated) ? ' (includes estimate)' : ''}\n   504→- Total Duration: ${Math.round((agent1Result.duration + agent2Result.duration) / 1000)}s\n   505→- Total Tokens: in=${(agent1Result.tokenUsage.input + agent2Result.tokenUsage.input).toLocaleString()} out=${(agent1Result.tokenUsage.output + agent2Result.tokenUsage.output).toLocaleString()} cached=${(agent1Result.tokenUsage.cached + agent2Result.tokenUsage.cached).toLocaleString()}\n   506→\n   507→---\n   508→\n   509→${writerBasePrompt}`;\n   510→\n   511→  // Agent 3 with rate limit retry\n   512→  const agent3Model = config.provider === 'codex' ? config.codexModel : 'sonnet';\n   513→  const agent3Result = await executeWithRateLimitRetry(\n   514→    () => agent3Provider.spawn({\n   515→      prompt: writerPrompt,\n   516→      model: agent3Model,\n   517→      allowedTools: ['mcp__linear__*'],\n   518→      reasoningEffort: config.provider === 'codex' ? config.codexAgentReasoning.agent3 : undefined,\n   519→    }, 3),\n   520→    retryConfig,\n   521→    'Agent 3 (Linear Writer)'\n   522→  );\n   523→\n   524→  if (agent3Result.rateLimited) {\n   525→    console.log('Agent 3 still rate limited after max retries.');\n   526→  }\n   527→\n   528→  // Log Agent 3 stats\n   529→  await logAgentStats(3, config.provider, agent3Model, {\n   530→    tokenUsage: agent3Result.tokenUsage,\n   531→    cost: agent3Result.cost,\n   532→    costEstimated: agent3Result.costEstimated,\n   533→    duration: agent3Result.duration,\n   534→    exitCode: agent3Result.exitCode,\n   535→    rateLimited: agent3Result.rateLimited,\n   536→    output: agent3Result.output,\n   537→  });\n   538→\n   539→  // Finalize loop stats\n   540→  await finalizeLoopStats();\n   541→\n   542→  // Loop stats\n   543→  const duration = Math.round((Date.now() - loopStart) / 1000);\n   544→  const minutes = Math.floor(duration / 60);\n   545→  const seconds = duration % 60;\n   546→  console.log(`\\nLoop ${iteration} complete in ${minutes}m ${seconds}s`);\n   547→}\n   548→\n   549→/**\n   550→ * Displays the Horizon startup banner with ASCII art.\n   551→ * Futuristic/sci-fi themed, ~10 lines.\n   552→ */\n   553→function displayBanner(): void {\n   554→  const version = getVersion();\n   555→  const banner = `\n   556→    ██╗  ██╗ ██████╗ ██████╗ ██╗███████╗ ██████╗ ███╗   ██╗\n   557→    ██║  ██║██╔═══██╗██╔══██╗██║╚══███╔╝██╔═══██╗████╗  ██║\n   558→    ███████║██║   ██║██████╔╝██║  ███╔╝ ██║   ██║██╔██╗ ██║\n   559→    ██╔══██║██║   ██║██╔══██╗██║ ███╔╝  ██║   ██║██║╚██╗██║\n   560→    ██║  ██║╚██████╔╝██║  ██║██║███████╗╚██████╔╝██║ ╚████║\n   561→    ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝╚═╝╚══════╝ ╚═════╝ ╚═╝  ╚═══╝\n   562→\n   563→    ⚡ Turn Linear Tickets into Pull Requests with Parallel Agents  ⚡  v${version}\n   564→════════════════════════════════════════════════════════════════`;\n   565→  console.log(banner);\n   566→}\n   567→\n   568→/**\n   569→ * Displays a safety warning about AI coding agents.\n   570→ */\n   571→function displaySafetyWarning(): void {\n   572→  console.log('\\n' + box([\n   573→    '  Horizon uses AI coding agents (Claude Code, Codex) that are  ',\n   574→    '  granted permissions to read, write, and execute code.        ',\n   575→    '                                                               ',\n   576→    '  * Coding agents may make mistakes                            ',\n   577→    '  * They may take actions that could be harmful to your system ',\n   578→    '  * Always review changes before merging to production         ',\n   579→  ], { title: 'Safety Warning', width: 65 }) + '\\n');\n   580→}\n   581→\n   582→/**\n   583→ * Runs minimal first-run setup if credentials are missing.\n   584→ * Prompts only for essentials (API key, team), uses defaults for everything else.\n   585→ * Returns true if setup completed successfully, false if user cancelled.\n   586→ */\n   587→async function runMinimalSetup(cliAvailability: CliAvailability): Promise<boolean> {\n   588→  console.log('\\n⚠️  Linear credentials not configured.\\n');\n   589→\n   590→  const rl = createPromptInterface();\n   591→\n   592→  try {\n   593→    // Load any existing config\n   594→    const existingConfig = loadExistingConfig();\n   595→\n   596→    // ─── API Key ───\n   597→    console.log('To get your API key:');\n   598→    console.log('  1. Go to: https://linear.app/settings/account/security/api-keys/new');\n   599→    console.log('  2. Enter a label (e.g., \"Horizon\")');\n   600→    console.log('  3. Click \"Create key\"');\n   601→    console.log('');\n   602→\n   603→    let apiKey = await promptSecret(rl, 'Enter your Linear API key');\n   604→    if (!apiKey) {\n   605→      console.log('\\nLinear API key is required.');\n   606→      return false;\n   607→    }\n   608→\n   609→    // Validate API key\n   610→    console.log('Validating...');\n   611→    const isValid = await validateLinearKey(apiKey);\n   612→    if (!isValid) {\n   613→      console.log('Invalid API key. Please check and try again.');\n   614→      return false;\n   615→    }\n   616→    console.log('✓ Valid\\n');\n   617→\n   618→    // ─── Team Selection ───\n   619→    console.log('Fetching teams...');\n   620→    const teams = await fetchLinearTeams(apiKey);\n   621→\n   622→    if (teams.length === 0) {\n   623→      console.log('No teams found in your Linear workspace.');\n   624→      return false;\n   625→    }\n   626→\n   627→    let teamKey: string;\n   628→    if (teams.length === 1) {\n   629→      teamKey = teams[0].key;\n   630→      console.log(`Found team: ${teams[0].name} (${teams[0].key})`);\n   631→      console.log('Auto-selecting as it\\'s the only team.\\n');\n   632→    } else {\n   633→      console.log('Select team:');\n   634→      const teamOptions: SelectOption<string>[] = teams.map((team) => ({\n   635→        value: team.key,\n   636→        label: `${team.name} (${team.key})`,\n   637→      }));\n   638→\n   639→      teamKey = await promptSelect(rl, teamOptions, 0);\n   640→      const selectedTeam = teams.find((t) => t.key === teamKey)!;\n   641→      console.log(`Selected: ${selectedTeam.name}\\n`);\n   642→    }\n   643→\n   644→    // ─── Provider ───\n   645→    let provider: ProviderName;\n   646→    if (cliAvailability.claude && cliAvailability.codex) {\n   647→      console.log('Select provider:');\n   648→      const providerOptions: SelectOption<ProviderName>[] = [\n   649→        { value: 'claude', label: 'claude', description: 'Claude Code CLI' },\n   650→        { value: 'codex', label: 'codex', description: 'OpenAI Codex CLI' },\n   651→      ];\n   652→      provider = await promptSelect(rl, providerOptions, 0);\n   653→    } else {\n   654→      provider = autoSelectProvider(cliAvailability);\n   655→      console.log(`Using provider: ${provider}\\n`);\n   656→    }\n   657→\n   658→    // ─── Merge Mode ───\n   659→    console.log('When work completes:');\n   660→    const mergeModeOptions: SelectOption<MergeMode>[] = [\n   661→      { value: 'auto', label: 'auto', description: 'Agent decides: merge directly or create PR (recommended)' },\n   662→      { value: 'merge', label: 'merge', description: 'Merge directly to main' },\n   663→      { value: 'pr', label: 'pr', description: 'Create PR for review' },\n   664→    ];\n   665→\n   666→    const mergeMode = await promptSelect(rl, mergeModeOptions, 0);\n   667→\n   668→    // Save configuration\n   669→    const newConfig: LoadedConfig = {\n   670→      linearApiKey: apiKey,\n   671→      linearTeamKey: teamKey,\n   672→      provider,\n   673→      claudeModel: existingConfig.claudeModel || 'opus',\n   674→      codexModel: existingConfig.codexModel || 'gpt-5.2',\n   675→      codexReasoningEffort: existingConfig.codexReasoningEffort || 'high',\n   676→      maxIterations: existingConfig.maxIterations ?? 0,\n   677→      mergeMode,\n   678→    };\n   679→\n   680→    saveEnvConfig(newConfig);\n   681→    saveMcpConfig(apiKey);\n   682→    if (provider === 'codex') {\n   683→      saveCodexMcpConfig();\n   684→    }\n   685→    ensureGitignore();\n   686→\n   687→    // Update process.env so config picks up new values\n   688→    process.env.LINEAR_API_KEY = apiKey;\n   689→    process.env.LINEAR_TEAM_KEY = teamKey;\n   690→    process.env.HORIZON_PROVIDER = provider;\n   691→    process.env.HORIZON_MERGE_MODE = mergeMode;\n   692→\n   693→    console.log('\\n✓ Configuration saved!');\n   694→    console.log('  Tip: Run `horizon config` to change provider, model, or other settings.\\n');\n   695→    return true;\n   696→  } finally {\n   697→    rl.close();\n   698→  }\n   699→}\n   700→\n   701→export async function main(): Promise<void> {\n   702→  displayBanner();\n   703→  displaySafetyWarning();\n   704→\n   705→  // Check for updates (non-blocking, cached for 24 hours)\n   706→  const updateResult = await checkForUpdates();\n   707→  displayUpdateNotification(updateResult);\n   708→\n   709→  // Check for git repository first - Horizon requires git\n   710→  if (!isGitRepository()) {\n   711→    console.log('\\n❌ Error: Not a git repository');\n   712→    console.log('');\n   713→    console.log('   Horizon requires a git repository to operate. It uses git for:');\n   714→    console.log('   - Creating feature branches');\n   715→    console.log('   - Committing changes');\n   716→    console.log('   - Creating pull requests');\n   717→    console.log('');\n   718→    console.log('   To initialize a git repository, run:');\n   719→    console.log('     git init');\n   720→    console.log('');\n   721→    process.exit(1);\n   722→  }\n   723→\n   724→  // Ensure directories exist (silent)\n   725→  ensureHorizonDir();\n   726→  ensureHorizonDocsDir();\n   727→  ensureGitignore();\n   728→\n   729→  // Check for coding CLI availability - at least one must be installed\n   730→  const cliAvailability = checkAndDisplayCliAvailability();\n   731→  if (!cliAvailability) {\n   732→    // Error message already displayed by checkAndDisplayCliAvailability\n   733→    process.exit(1);\n   734→  }\n   735→\n   736→  // Sync prompts from package to .horizon/prompts/ (ensures they're always up-to-date)\n   737→  const promptSync = copyPromptsToProject();\n   738→\n   739→  let config = getConfig();\n   740→\n   741→  // Check if Linear credentials are configured\n   742→  if (!config.linearApiKey || !config.linearTeamId) {\n   743→    const setupSuccess = await runMinimalSetup(cliAvailability);\n   744→    if (!setupSuccess) {\n   745→      console.log('\\nCannot start Horizon without Linear configuration.');\n   746→      console.log('Run `horizon config` for full configuration options.\\n');\n   747→      process.exit(1);\n   748→    }\n   749→\n   750→    // Reload config after setup (rebuild from updated process.env)\n   751→    config = getConfig(true);\n   752→  }\n   753→\n   754→  // Check if ∞ statuses exist in Linear, create if needed\n   755→  const statusesExist = await checkLinearStatuses(config.linearApiKey!, config.linearTeamId!);\n   756→  if (!statusesExist) {\n   757→    const result = await createLinearStatuses(config.linearApiKey!, config.linearTeamId!);\n   758→\n   759→    if (!result.success) {\n   760→      console.log('\\n❌ Failed to create ∞ statuses. Please check Linear permissions.');\n   761→      if (result.errors.length > 0) {\n   762→        result.errors.forEach((err) => console.log(`   - ${err}`));\n   763→      }\n   764→      process.exit(1);\n   765→    }\n   766→  }\n   767→\n   768→  // Check Codex Linear MCP if using Codex provider\n   769→  if (config.provider === 'codex') {\n   770→    const hasLinearMcp = checkCodexLinearMcp();\n   771→    if (!hasLinearMcp) {\n   772→      console.log('\\n⚠️  Linear MCP not configured for Codex.');\n   773→      console.log('   Run: horizon config');\n   774→      process.exit(1);\n   775→    }\n   776→  }\n   777→\n   778→  // Generate pod name once at startup - persists for entire Horizon session\n   779→  const podName = generatePodName();\n   780→\n   781→  // Build provider display string\n   782→  const providerDisplay = config.provider === 'codex'\n   783→    ? `Codex (${config.codexModel})`\n   784→    : `Claude (${config.claudeModel.charAt(0).toUpperCase() + config.claudeModel.slice(1)})`;\n   785→\n   786→  // Build CLI availability display\n   787→  const cliParts: string[] = [];\n   788→  if (cliAvailability.claude) cliParts.push('Claude ✓');\n   789→  if (cliAvailability.codex) cliParts.push('Codex ✓');\n   790→\n   791→  // Build init box lines\n   792→  const detectionLines = [\n   793→    `  CLIs Available    ${cliParts.join('  ')}  `,\n   794→    `  Agent Prompts     ${promptSync.copied} files synced  `,\n   795→  ];\n   796→\n   797→  const configLines = [\n   798→    `  Working Directory ${config.workingDirectory}  `,\n   799→    `  Agent Branch      ${getCurrentBranch()}  `,\n   800→    `  Provider          ${providerDisplay}  `,\n   801→    `  Merge Mode        ${promptSync.mergeMode}  `,\n   802→    `  Linear Team       ${config.linearTeamId} ∞ prefixed statuses  `,\n   803→    `  Current Pod       ${podName}  `,\n   804→  ];\n   805→\n   806→  if (config.maxIterations > 0) {\n   807→    configLines.push(`  Max Iterations    ${config.maxIterations}  `);\n   808→  }\n   809→  if (config.gcpAutoStop) {\n   810→    configLines.push(`  GCP Auto-Stop     enabled  `);\n   811→  }\n   812→\n   813→  console.log('\\n' + box(\n   814→    [...detectionLines, ...configLines],\n   815→    { title: 'Horizon', width: 60, dividerAfter: [detectionLines.length - 1] },\n   816→  ));\n   817→\n   818→  let iteration = 0;\n   819→\n   820→  while (config.maxIterations === 0 || iteration < config.maxIterations) {\n   821→    try {\n   822→      await runLoop(podName, iteration);\n   823→      iteration++;\n   824→    } catch (error) {\n   825→      console.error(`\\nLoop ${iteration} error:`, error);\n   826→      console.log(`Sleeping ${config.errorSleepMinutes} minute(s) before retry...`);\n   827→      await sleep(config.errorSleepMinutes * 60 * 1000);\n   828→    }\n   829→  }\n   830→\n   831→  if (config.maxIterations > 0) {\n   832→    console.log(`\\nReached max iterations: ${config.maxIterations}`);\n   833→  }\n   834→}\n   835→\n   836→// Run main when executed directly\n   837→// When used as CLI via cli.ts, main() is imported and called there\n   838→if (import.meta.url === `file://${process.argv[1]}`) {\n   839→  main().catch(console.error);\n   840→}\n   841→"}]},"uuid":"d4933aee-ae81-4384-9ecf-4bf54f89979a","timestamp":"2026-02-14T12:03:08.509Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"0432227a-6acb-48bc-948f-282057bffa27","timestamp":"2026-02-14T12:03:08.543Z"}
{"parentUuid":"0432227a-6acb-48bc-948f-282057bffa27","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:03:10.957Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_011pE12mf8ijDnaQmvmSbdos","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NGm25dZNobweWEn1FpqNqe","name":"Bash","input":{"command":"find /Users/ob1/projects/startup/horizon-cli-agent/prompts -name \"agent*\" -o -name \"*merge*\" | head -20","description":"Find agent and merge related prompt files"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4101,"cache_creation_input_tokens":12813,"cache_read_input_tokens":37808,"cache_creation":{"ephemeral_5m_input_tokens":12813,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vnoVkdyNWDD2BQQ8Xq","uuid":"6fd1303e-8386-43a9-86af-7858ee359996"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"09cad34b-e94a-4117-9104-3aa644c47044","timestamp":"2026-02-14T12:03:10.957Z"}
{"parentUuid":"09cad34b-e94a-4117-9104-3aa644c47044","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01NGm25dZNobweWEn1FpqNqe","type":"tool_result","content":"/Users/ob1/projects/startup/horizon-cli-agent/prompts/agent2-worker-oneshot.md\n/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-auto.md\n/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-pr.md\n/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-direct.md\n/Users/ob1/projects/startup/horizon-cli-agent/prompts/agent3-linear-writer.md\n/Users/ob1/projects/startup/horizon-cli-agent/prompts/agent2-worker-validate.md\n/Users/ob1/projects/startup/horizon-cli-agent/prompts/agent2-worker.md\n/Users/ob1/projects/startup/horizon-cli-agent/prompts/agent2-worker-specification.md\n/Users/ob1/projects/startup/horizon-cli-agent/prompts/agent1-linear-reader.md\n/Users/ob1/projects/startup/horizon-cli-agent/prompts/agent2-worker-plan.md\n/Users/ob1/projects/startup/horizon-cli-agent/prompts/agent2-worker-implement.md\n/Users/ob1/projects/startup/horizon-cli-agent/prompts/agent2-worker-research.md","is_error":false}]},"uuid":"065024f5-bad8-4789-9d4a-7b187006c70e","timestamp":"2026-02-14T12:03:11.053Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"bfe672cf-2abd-401c-932a-0727d464e829","timestamp":"2026-02-14T12:03:11.086Z"}
{"parentUuid":"bfe672cf-2abd-401c-932a-0727d464e829","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:03:12.573Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016wjUmpsCuumngCkigYBVkM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01J8yVfEW6VVrQxmrannQtin","name":"Read","input":{"file_path":"/Users/ob1/projects/startup/horizon-cli-agent/prompts/agent2-worker.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":4609,"cache_read_input_tokens":50621,"cache_creation":{"ephemeral_5m_input_tokens":4609,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vnzPLz1LCzxZGPN2u9","uuid":"ac54d861-8bbf-464a-87b4-f377e98f8465"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"1f45921a-76ea-4269-b08c-c8daf4288792","timestamp":"2026-02-14T12:03:12.573Z"}
{"parentUuid":"1f45921a-76ea-4269-b08c-c8daf4288792","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01J8yVfEW6VVrQxmrannQtin","type":"tool_result","content":"     1→# Agent 2: Worker\n     2→\n     3→You are the Worker agent. Agent 1 has already selected and claimed a Linear issue for you to work on. The issue context is provided above.\n     4→\n     5→## First Step: Load Stage-Specific Instructions\n     6→\n     7→Agent 1 has specified which stage to execute. **Read the detailed instructions for your stage before doing any work.**\n     8→\n     9→| Stage | Instructions File |\n    10→|-------|-------------------|\n    11→| oneshot | `.horizon/prompts/agent2-worker-oneshot.md` |\n    12→| research | `.horizon/prompts/agent2-worker-research.md` |\n    13→| specification | `.horizon/prompts/agent2-worker-specification.md` |\n    14→| plan | `.horizon/prompts/agent2-worker-plan.md` |\n    15→| implement | `.horizon/prompts/agent2-worker-implement.md` |\n    16→| validate | `.horizon/prompts/agent2-worker-validate.md` |\n    17→\n    18→**Read the file for your stage now, then follow those instructions exactly.**\n    19→\n    20→## Quick Reference (details in stage-specific file)\n    21→\n    22→### Branch Workflow\n    23→- You run in an isolated git worktree already on branch `horizon/{issue-identifier}`\n    24→- Never push directly to main; do NOT run `git checkout main`\n    25→- All merges happen via PR creation\n    26→\n    27→### Output Format\n    28→All stages output a `WORK_RESULT` block. See your stage-specific file for the exact format.\n    29→\n    30→## Important Notes\n    31→\n    32→- You do NOT have access to Linear - don't try to update it\n    33→- All Linear context you need is provided above from Agent 1\n    34→- If something is unclear, make reasonable assumptions and note them\n    35→- If you encounter errors you can't fix, document them clearly\n    36→\n    37→## Attachments\n    38→\n    39→If the Linear issue has attachments (images, documents, etc.), they are automatically downloaded to:\n    40→```\n    41→.horizon/attachments/{issue-identifier}/\n    42→```\n    43→\n    44→For example, attachments for issue F-69 would be in `.horizon/attachments/F-69/`. Check this folder if the issue description references attached files - you can read them directly from there instead of trying to fetch URLs.\n    45→"}]},"uuid":"68822a04-2c76-4c12-9c19-e25707974a7b","timestamp":"2026-02-14T12:03:12.638Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"97910732-b45f-4a9a-b632-52d24a1df4ff","timestamp":"2026-02-14T12:03:12.771Z"}
{"parentUuid":"97910732-b45f-4a9a-b632-52d24a1df4ff","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:03:12.837Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_016wjUmpsCuumngCkigYBVkM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Vw3MTqjuwvjKwgEHa73LFh","name":"Read","input":{"file_path":"/Users/ob1/projects/startup/horizon-cli-agent/prompts/agent3-linear-writer.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":4609,"cache_read_input_tokens":50621,"cache_creation":{"ephemeral_5m_input_tokens":4609,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vnzPLz1LCzxZGPN2u9","uuid":"a60c8190-3f8a-44dd-a105-d396c3ea83c8"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"b5307473-ff7a-4fda-830f-7da62d858439","timestamp":"2026-02-14T12:03:12.837Z"}
{"parentUuid":"b5307473-ff7a-4fda-830f-7da62d858439","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Vw3MTqjuwvjKwgEHa73LFh","type":"tool_result","content":"     1→# Agent 3: Linear Writer\n     2→\n     3→You are the Linear Writer agent. Your job is to update Linear with the results of Agent 2's work.\n     4→\n     5→The context above contains:\n     6→1. **Agent 1's output**: The issue that was worked on (ID, title, stage, etc.)\n     7→2. **Agent 2's output**: What work was performed, any commits made, results\n     8→3. **Session stats**: Cost, duration, etc.\n     9→\n    10→## Your Task\n    11→\n    12→1. **Find the issue ID** from Agent 1's output\n    13→2. **Extract key data** from Agent 2's WORK_RESULT:\n    14→   - `workflow`: The workflow type (`oneshot` or `staged`) - informational\n    15→   - `commit_hash`: The git commit hash\n    16→   - `branch_name`: The feature branch (e.g., `horizon/RSK-123`)\n    17→   - `repo_url`: The GitHub repository URL (if provided)\n    18→   - `merge_status`: `success`, `blocked`, or `pr_created` (if merge was attempted)\n    19→   - `merge_conflict_files`: List of files with conflicts (if merge was blocked)\n    20→   - `pr_url`: The pull request URL (if PR was created)\n    21→3. **Attach branch link** to the issue (if branch_name provided)\n    22→4. **Post a comment** summarizing Agent 2's work, including commit and branch info\n    23→5. **Update the status** based on what happened and merge_status\n    24→\n    25→## Branch Linking\n    26→\n    27→When Agent 2 provides `branch_name` in WORK_RESULT, attach a link to the Linear issue:\n    28→\n    29→1. **Construct the branch URL**:\n    30→   - If `repo_url` is provided: `{repo_url}/tree/{branch_name}`\n    31→   - If `repo_url` is not provided: Use the issue identifier to derive: `https://github.com/{owner}/{repo}/tree/{branch_name}`\n    32→   - Note: You may need to ask the human to configure the repo URL if not available\n    33→\n    34→2. **Attach link using `mcp__linear__update_issue`**:\n    35→   ```\n    36→   mcp__linear__update_issue({\n    37→     id: \"{issue_id}\",\n    38→     links: [{\n    39→       url: \"{branch_url}\",\n    40→       title: \"Branch: {branch_name}\"\n    41→     }]\n    42→   })\n    43→   ```\n    44→\n    45→3. **Attach PR link** (if `pr_url` provided in WORK_RESULT):\n    46→   ```\n    47→   mcp__linear__update_issue({\n    48→     id: \"{issue_id}\",\n    49→     links: [{\n    50→       url: \"{pr_url}\",\n    51→       title: \"PR: {issue_identifier}\"\n    52→     }]\n    53→   })\n    54→   ```\n    55→\n    56→**Important**: Only attach links once. Check if link already exists in issue before adding.\n    57→\n    58→## Comment Format\n    59→\n    60→Post a comment like this:\n    61→\n    62→```\n    63→**Stage Complete** | {loop instance name} | {current timestamp}\n    64→\n    65→**Stage**: {stage that was completed}\n    66→**Loop Instance**: {loop instance name from session stats}\n    67→**Duration**: {loop total duration from session stats}\n    68→**Branch**: {branch_name from Agent 2's output, e.g., `horizon/RSK-123`}\n    69→**Commit**: {commit hash from Agent 2's output, e.g., `abc1234`}\n    70→**Merge Status**: {success | blocked | n/a} (only for validate/oneshot stages)\n    71→\n    72→## Summary\n    73→{Summary of what Agent 2 accomplished}\n    74→\n    75→## Artifacts\n    76→{Any files created, commits made, etc.}\n    77→\n    78→## Next Steps\n    79→{What should happen next}\n    80→\n    81→## Cost Summary\n    82→| Agent | Model | Tokens (in/out/cached) | Cost |\n    83→|-------|-------|----------------------|------|\n    84→| Agent 1 | {model} | {in}/{out}/{cached} | ${cost} |\n    85→| Agent 2 | {model} | {in}/{out}/{cached} | ${cost} |\n    86→| **Total** | - | {totals} | **${total_cost}** |\n    87→```\n    88→\n    89→If Agent 2 failed or had errors:\n    90→\n    91→```\n    92→**Stage Failed** | {loop instance name} | {current timestamp}\n    93→\n    94→**Stage**: {stage attempted}\n    95→**Loop Instance**: {loop instance name from session stats}\n    96→**Duration**: {loop total duration from session stats}\n    97→\n    98→## Error\n    99→{What went wrong}\n   100→\n   101→## Next Steps\n   102→Will retry on next loop iteration.\n   103→\n   104→## Cost Summary\n   105→| Agent | Model | Tokens (in/out/cached) | Cost |\n   106→|-------|-------|----------------------|------|\n   107→| Agent 1 | {model} | {in}/{out}/{cached} | ${cost} |\n   108→| Agent 2 | {model} | {in}/{out}/{cached} | ${cost} |\n   109→| **Total** | - | {totals} | **${total_cost}** |\n   110→```\n   111→\n   112→If merge was blocked (Agent 2 outputs `merge_status: blocked`):\n   113→\n   114→```\n   115→**Merge Blocked** | {loop instance name} | {current timestamp}\n   116→\n   117→**Stage**: {stage completed (validate or oneshot)}\n   118→**Loop Instance**: {loop instance name from session stats}\n   119→**Duration**: {loop total duration from session stats}\n   120→**Branch**: {branch_name}\n   121→**Commit**: {commit hash on feature branch}\n   122→\n   123→## Status\n   124→Work completed successfully, but merge to main was blocked due to conflicts.\n   125→\n   126→## Merge Conflicts\n   127→The following files have conflicts that require human resolution:\n   128→- `{file1.ts}`\n   129→- `{file2.ts}`\n   130→- ...\n   131→\n   132→## Resolution Steps\n   133→1. Checkout the branch: `git checkout {branch_name}`\n   134→2. Merge main into the branch: `git merge main`\n   135→3. Resolve conflicts in the listed files\n   136→4. Commit the merge: `git commit -m \"Merge main into {branch_name}\"`\n   137→5. Push: `git push origin {branch_name}`\n   138→6. Re-run validation or merge manually\n   139→\n   140→## Cost Summary\n   141→| Agent | Model | Tokens (in/out/cached) | Cost |\n   142→|-------|-------|----------------------|------|\n   143→| Agent 1 | {model} | {in}/{out}/{cached} | ${cost} |\n   144→| Agent 2 | {model} | {in}/{out}/{cached} | ${cost} |\n   145→| **Total** | - | {totals} | **${total_cost}** |\n   146→```\n   147→\n   148→If PR was created (Agent 2 outputs `merge_status: pr_created`):\n   149→\n   150→```\n   151→**PR Created** | {loop instance name} | {current timestamp}\n   152→\n   153→**Stage**: {stage completed (validate or oneshot)}\n   154→**Loop Instance**: {loop instance name from session stats}\n   155→**Duration**: {loop total duration from session stats}\n   156→**Branch**: {branch_name}\n   157→**Commit**: {commit hash on feature branch}\n   158→**PR**: {pr_url}\n   159→\n   160→## Status\n   161→Work completed successfully. Pull request created for human review.\n   162→\n   163→## Pull Request\n   164→{pr_url}\n   165→\n   166→## Next Steps\n   167→1. Review the PR at the link above\n   168→2. Approve and merge when ready\n   169→3. The Linear status will remain at `∞ Awaiting Merge` until merged\n   170→\n   171→## Cost Summary\n   172→| Agent | Model | Tokens (in/out/cached) | Cost |\n   173→|-------|-------|----------------------|------|\n   174→| Agent 1 | {model} | {in}/{out}/{cached} | ${cost} |\n   175→| Agent 2 | {model} | {in}/{out}/{cached} | ${cost} |\n   176→| **Total** | - | {totals} | **${total_cost}** |\n   177→```\n   178→\n   179→## Status Updates\n   180→\n   181→**Note**: Agent 2's `workflow` field indicates whether the task followed oneshot or staged flow. Status routing is determined by `next_status` from Agent 2, not the `workflow` field directly. The `workflow` field is primarily for logging and tracking purposes.\n   182→\n   183→Update the issue status based on what happened AND the merge status:\n   184→\n   185→### When merge_status is \"success\" (or not applicable)\n   186→- **oneshot complete + merge success** → `∞ Done`\n   187→- **validate complete + merge success** → `∞ Done`\n   188→- **research complete** → `∞ Needs Specification` or `∞ Needs Plan` (based on Agent 2's next_status)\n   189→- **specification complete** → `∞ Needs Plan`\n   190→- **plan complete** → `∞ Needs Implement`\n   191→- **implement complete** → `∞ Needs Validate`\n   192→- **any failure** → Keep current status (don't change)\n   193→\n   194→### When merge_status is \"blocked\"\n   195→- **oneshot/validate complete + merge blocked** → \"Blocked\"\n   196→  - Use status ID: `723acd28-e8a4-4083-a0ff-85986b42c2c2`\n   197→  - This indicates the work is done but needs human intervention for merge conflicts\n   198→\n   199→### When merge_status is \"pr_created\"\n   200→- **oneshot/validate complete + PR created** → `∞ Awaiting Merge`\n   201→  - This indicates the work is done and awaiting human review/merge\n   202→  - Include the PR URL in the comment\n   203→  - Attach the PR URL as a link to the issue (see Branch Linking section)\n   204→\n   205→### When next_status is \"∞ Blocked\"\n   206→- **Any stage incomplete + blocked** → `∞ Blocked`\n   207→  - This indicates the agent needs human intervention to proceed\n   208→  - The error field in WORK_RESULT contains details about what's blocked\n   209→  - Human should review the error details and either:\n   210→    - Clarify requirements and move to appropriate \"∞ Needs X\" status\n   211→    - Make a decision and move to appropriate \"∞ Needs X\" status\n   212→    - Add a comment with the answer and move back to the status where work stopped\n   213→\n   214→### Status Update Command\n   215→\n   216→Use `mcp__linear__update_issue` to change the status:\n   217→\n   218→```\n   219→mcp__linear__update_issue({\n   220→  id: \"{issue_id}\",\n   221→  state: \"{status_name}\"  // e.g., \"∞ Done\", \"Blocked\", \"∞ Needs Validate\"\n   222→})\n   223→```\n   224→\n   225→For \"Blocked\" status specifically, you can use the status ID directly:\n   226→```\n   227→mcp__linear__update_issue({\n   228→  id: \"{issue_id}\",\n   229→  state: \"723acd28-e8a4-4083-a0ff-85986b42c2c2\"  // Blocked status ID\n   230→})\n   231→```\n   232→\n   233→## Creating Sub-Issues\n   234→\n   235→If Agent 2's WORK_RESULT contains a `sub_issues` array, create each sub-issue in Linear:\n   236→\n   237→1. **Parse sub-issues** from Agent 2's output (look for `sub_issues:` block in WORK_RESULT)\n   238→\n   239→2. **For each sub-issue**, use `mcp__linear__create_issue`:\n   240→   - `title`: Use the title from the sub-issue\n   241→   - `description`: Use the description from the sub-issue\n   242→   - `team`: Same team as the parent issue (extract team from issue identifier, e.g., \"RSK\" from \"RSK-20\")\n   243→   - `parentId`: The issue ID from Agent 1's output (this links it as a sub-issue)\n   244→   - `state`: `∞ Needs Implement` (since the plan already covers their implementation)\n   245→   - `labels`: Copy any relevant labels from the parent issue\n   246→\n   247→3. **Report creation** in your comment:\n   248→   ```\n   249→   ## Sub-Issues Created\n   250→   - {sub-issue identifier}: {title}\n   251→   - {sub-issue identifier}: {title}\n   252→   ```\n   253→\n   254→4. **Error handling**: If sub-issue creation fails:\n   255→   - Log the error but don't fail the entire update\n   256→   - Report which sub-issues could not be created\n   257→   - The main issue status should still be updated\n   258→\n   259→Example sub-issue creation:\n   260→```\n   261→mcp__linear__create_issue({\n   262→  title: \"{identifier}a: Implement parser changes\",\n   263→  description: \"Implement parser updates for sub-issue support.\\nSee Phase 2 of the implementation plan.\",\n   264→  team: \"{team_key from Linear Team Configuration above}\",\n   265→  parentId: \"{issue_id from Agent 1's output}\",\n   266→  state: \"∞ Needs Implement\"\n   267→})\n   268→```\n   269→\n   270→## Reminders\n   271→\n   272→- Extract the issue ID from Agent 1's output\n   273→- Use `mcp__linear__create_comment` to post the comment\n   274→- Use `mcp__linear__update_issue` to update status\n   275→- If you can't find the issue ID, just log an error and don't crash\n   276→"}]},"uuid":"f518dd59-8fae-49e5-9817-46f08ab1c3a8","timestamp":"2026-02-14T12:03:12.887Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"8e4145ba-7729-413c-b217-5ea32b8051da","timestamp":"2026-02-14T12:03:12.918Z"}
{"parentUuid":"8e4145ba-7729-413c-b217-5ea32b8051da","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:03:15.754Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Lbm5BKne9vZ7gfY2sstCmo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RZ81NqLtpuFoqzoJQYSsZw","name":"Bash","input":{"command":"find /Users/ob1/projects/opus-hackathon/napoli-matcha/prompts -type f -name \"*.md\" | head -20","description":"List all prompt files in napoli-matcha"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":6,"cache_creation_input_tokens":4653,"cache_read_input_tokens":55230,"cache_creation":{"ephemeral_5m_input_tokens":4653,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7vo8Esmitm6KB2TLSv2","uuid":"00c15d79-b409-4182-adec-5576752cb258"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"f387cf95-a6df-49fb-acd6-de6a7363e90f","timestamp":"2026-02-14T12:03:15.754Z"}
{"parentUuid":"f387cf95-a6df-49fb-acd6-de6a7363e90f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RZ81NqLtpuFoqzoJQYSsZw","type":"tool_result","content":"/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/agent2-worker-oneshot.md\n/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-auto.md\n/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-pr.md\n/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-direct.md\n/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/agent3-linear-writer.md\n/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/agent2-worker-validate.md\n/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/agent2-worker.md\n/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/agent2-worker-specification.md\n/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/agent1-linear-reader.md\n/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/agent2-worker-plan.md\n/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/agent2-worker-implement.md\n/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/agent2-worker-research.md","is_error":false}]},"uuid":"96ab44d5-bb53-42e3-a0b3-006b93c78844","timestamp":"2026-02-14T12:03:15.864Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd"},"toolUseID":"agent_msg_01RLwpkm1sFmgYyUuiVnZBcH","parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","uuid":"4f275c7a-5047-4bd2-84d3-fb3ce5d27f90","timestamp":"2026-02-14T12:03:15.898Z"}
{"parentUuid":"4f275c7a-5047-4bd2-84d3-fb3ce5d27f90","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Task","command":"entire hooks claude-code post-task"},"parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","toolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","timestamp":"2026-02-14T12:03:40.996Z","uuid":"962480de-c0ba-4527-8a52-9b98408cd1a6"}
{"parentUuid":"962480de-c0ba-4527-8a52-9b98408cd1a6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Task","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","toolUseID":"toolu_01C7LZvrsqD3xnvAByR58v6R","timestamp":"2026-02-14T12:03:40.996Z","uuid":"ee777a24-5dea-42dd-b6ca-546ec7a5260d"}
{"parentUuid":"1e74da03-08de-4e3c-822e-2daffe24cafb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C7LZvrsqD3xnvAByR58v6R","type":"tool_result","content":[{"type":"text","text":"Now let me compile the comprehensive report. I have all the information I need. Let me create a summary of my findings:\n\n## Search Results: Merge Logic Across napoli-matcha and horizon-cli-agent\n\nI've completed a thorough search of both codebases for merge-related logic and prompts. Here are my findings:\n\n---\n\n## 1. MERGE FRAGMENT PROMPTS\n\nBoth repositories contain identical merge fragment files with three strategies:\n\n### Files Found:\n- `/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-auto.md`\n- `/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-direct.md`\n- `/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-pr.md`\n- `/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-auto.md`\n- `/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-direct.md`\n- `/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-pr.md`\n\n### merge-auto.md (Both repos - identical)\nThe auto merge fragment provides a **decision rubric for agents to choose between direct merge or PR**:\n\n**Prefer PR when:**\n- Changes include significant business logic updates\n- Agent is unsure about correctness, scope, or product intent\n- Assumptions were made or review desired\n- Potential edge cases, migrations, or higher-risk changes\n\n**Prefer direct merge only when:**\n- Changes are small, clearly safe, and well-understood\n- All checks pass with no open questions\n\nThen it provides complete instructions for both paths:\n\n**Option A (Direct Merge):** Git merge with --no-ff, conflict handling (clean/simple/complex), push to main, delete branch\n\n**Option B (PR):** Write PR description doc to `horizon-docs/prs/{identifier}.md`, create PR with `gh pr create`, include branch and PR URLs in WORK_RESULT\n\nBoth options output a `WORK_RESULT` block with fields like:\n- `merge_status`: `success`, `blocked`, or `pr_created`\n- `merge_conflict_files`: Array if blocked\n- `pr_url`: URL if PR created\n- `next_status`: Downstream state indicator\n\n### merge-direct.md (Both repos - similar structure)\nFocused instructions for **direct merge only** (skips the decision rubric). Steps:\n1. Get repo URL\n2. Checkout main, merge with --no-ff\n3. Handle clean/simple/complex conflicts\n4. Push and delete branch\n5. Output `merge_status: success` or `blocked`\n\n### merge-pr.md (Both repos - similar structure)\nFocused instructions for **PR-only flow** (skips the decision rubric). Steps:\n1. Get repo URL\n2. Write PR description document\n3. Create PR with `gh pr create --base main --head {branch}`\n4. Output `merge_status: pr_created` with `pr_url`\n\n---\n\n## 2. NAPOLI-MATCHA SYSTEM\n\n### Architecture:\n- **No orchestrator** - runs simplified, single-agent flow\n- **SandboxQueueProcessor.ts**: Loads tasks from `request_queue/*.md` files and spawns isolated Daytona sandboxes\n- **Claude invoked directly** with task instructions via PTY (pseudo-terminal)\n- **No agent pipeline** - single Claude instance per sandbox, no Agent 1/2/3 separation\n\n### Merge Handling:\n**Napoli-matcha does NOT directly handle merging** - it delegates to the prompt/agent:\n```\nThe fullPrompt instructs Claude to:\n1. Create a feature branch (feat/{task.id})\n2. Implement the feature from task.description\n3. Commit changes\n4. Push branch to origin\n5. Create PR using gh pr create\n\nCRITICAL: The prompt says \"Do NOT use interactive flags\"\n```\n\nThe merge fragments are available in the prompt directory but are NOT actively woven into the execution flow - they're template files available if/when agents need guidance on merge strategies.\n\n**Key Code** (`src/lib/SandboxQueueProcessor.ts`, lines 228-236):\n```typescript\nconst fullPrompt = `You are working in a cloned git repo. Your task:\n1. Create a new branch named \"${branchName}\"\n2. Implement the following feature: ${task.description}\n3. Commit your changes with a clear commit message\n4. Push the branch to origin\n5. Create a pull request using \\`gh pr create\\` with title \"${prTitle}\"...`;\n```\n\n---\n\n## 3. HORIZON-CLI-AGENT SYSTEM\n\n### Architecture:\n- **Three-agent orchestrator** (Agent 1 → Agent 2 → Agent 3)\n- **Agent 1 (Linear Reader)**: Reads Linear, selects issue, determines stage (`oneshot`, `research`, `specification`, `plan`, `implement`, `validate`)\n- **Agent 2 (Worker)**: Executes stage-specific work in isolated git worktree\n- **Agent 3 (Linear Writer)**: Updates Linear with results, creates sub-issues, attaches links\n\n### Merge Handling:\n**Merge is Agent 2's responsibility, controlled by `mergeMode` config**\n\n**Types** (`src/types.ts`, line 6):\n```typescript\nexport type MergeMode = 'auto' | 'merge' | 'pr';\n```\n\n**Config** (`src/config.ts`):\n```typescript\nfunction getMergeMode(): MergeMode {\n  const envMode = process.env.HORIZON_MERGE_MODE?.toLowerCase();\n  if (envMode === 'auto') return 'auto';\n  if (envMode === 'merge') return 'merge';\n  if (envMode === 'pr') return 'pr';\n  return 'auto'; // Default: agent decides safest path\n}\n```\n\n**Setup** (`src/index.ts`, lines 659-691):\nUsers configure merge mode during initialization:\n```typescript\nconsole.log('When work completes:');\nconst mergeModeOptions: SelectOption<MergeMode>[] = [\n  { value: 'auto', label: 'auto', description: 'Agent decides: merge directly or create PR (recommended)' },\n  { value: 'merge', label: 'merge', description: 'Merge directly to main' },\n  { value: 'pr', label: 'pr', description: 'Create PR for review' },\n];\n```\n\n**Agent 2 Execution** (`src/index.ts`, lines 354-351):\n```typescript\n// Build worker prompt by combining the base prompt with agent 1's output\nconst workerBasePrompt = await loadPrompt('agent2-worker');\nconst workerPrompt = `...`;\n// Agent 2 is given the loaded prompt which includes stage-specific instructions\n```\n\n**Agent 2 reads stage file** (`prompts/agent2-worker.md`, lines 5-18):\n```markdown\n| Stage | Instructions File |\n|-------|-------------------|\n| oneshot | `.horizon/prompts/agent2-worker-oneshot.md` |\n| validate | `.horizon/prompts/agent2-worker-validate.md` |\n...\n**Read the file for your stage now, then follow those instructions exactly.**\n```\n\nThe stage files (e.g., `agent2-worker-validate.md`, `agent2-worker-oneshot.md`) then include the merge fragments:\n- If `mergeMode === 'auto'`, include `merge-auto.md` → Agent decides\n- If `mergeMode === 'merge'`, include `merge-direct.md` → Force direct merge\n- If `mergeMode === 'pr'`, include `merge-pr.md` → Force PR\n\n**Agent 2 Output** (WORK_RESULT block):\nAgent 2 produces:\n```yaml\nmerge_status: success | blocked | pr_created\nmerge_conflict_files: [list] # if blocked\npr_url: {url}               # if pr_created\nnext_status: \"∞ Done\"       # downstream status\n```\n\n**Agent 3 Consumption** (`prompts/agent3-linear-writer.md`, lines 12-23):\nAgent 3 reads Agent 2's WORK_RESULT and:\n1. Extracts `merge_status`, `pr_url`, `branch_name`\n2. Posts comment to Linear with merge details\n3. Updates Linear status based on `merge_status`:\n   - `success` + `validate/oneshot` → `∞ Done`\n   - `pr_created` → `∞ Awaiting Merge`\n   - `blocked` → Use \"Blocked\" status ID with merge conflict details\n\n---\n\n## 4. KEY DIFFERENCES\n\n| Aspect | napoli-matcha | horizon-cli-agent |\n|--------|---------------|-------------------|\n| **Orchestration** | Single agent per sandbox | Three-agent pipeline |\n| **Merge Strategy** | Hardcoded to PR only (no config) | Configurable: auto/merge/pr |\n| **Agent Awareness** | No - Claude just runs prompt | Yes - Agent 2 reads mergeMode from config, Agent 3 interprets results |\n| **Worktree Isolation** | No - works in cloned repo | Yes - isolated git worktree per issue |\n| **Conflict Handling** | Not implemented | Agent 2 handles clean/simple/complex per merge-auto.md |\n| **Linear Integration** | None - just GitHub | Full - Agent 1 reads, Agent 3 updates with links & status |\n| **Merge Fragment Location** | Available in prompts/ dir but not woven in | Woven into stage files based on mergeMode config |\n\n---\n\n## 5. MERGE DECISION FLOW (Horizon)\n\n```\nConfig:mergeMode (\"auto\" / \"merge\" / \"pr\")\n    ↓\nAgent 1 determines STAGE\n    ↓\nAgent 2 is given stage-specific prompt which includes merge fragment:\n    • If auto → merge-auto.md (agent decides via rubric)\n    • If merge → merge-direct.md (forced direct)\n    • If pr → merge-pr.md (forced PR)\n    ↓\nAgent 2 executes merge logic, outputs WORK_RESULT with merge_status\n    ↓\nAgent 3 reads WORK_RESULT:\n    • Attaches branch/PR links to Linear\n    • Updates Linear status:\n      - success → ∞ Done\n      - pr_created → ∞ Awaiting Merge\n      - blocked → Blocked status with conflict details\n```\n\nAll merge fragments are located in:\n- `/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-*.md`\n- `/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-*.md`"},{"type":"text","text":"agentId: a0962cd (for resuming to continue this agent's work if needed)\n<usage>total_tokens: 63087\ntool_uses: 27\nduration_ms: 55837</usage>"}]}]},"uuid":"5662493e-9b8d-48d8-a7e5-f1ec106ac9e1","timestamp":"2026-02-14T12:03:40.994Z","toolUseResult":{"status":"completed","prompt":"Search the napoli-matcha codebase at /Users/ob1/projects/opus-hackathon/napoli-matcha for any merge-related logic. Look for:\n1. Any tryMerge, merge, or PR creation methods in src/lib/\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any existing merge handling in SandboxQueueProcessor.ts\n\nAlso search the Horizon agent codebase at /Users/ob1/projects/startup/horizon-cli-agent for:\n1. How merging is handled (auto, PR, direct strategies)\n2. The merge fragment prompts in prompts/fragments/merge-*.md\n3. Any orchestrator-level merge logic vs worker-level merge logic\n\nReport back the full contents of all merge-related fragments from both repos, and describe how each system handles the merge decision.","agentId":"a0962cd","content":[{"type":"text","text":"Now let me compile the comprehensive report. I have all the information I need. Let me create a summary of my findings:\n\n## Search Results: Merge Logic Across napoli-matcha and horizon-cli-agent\n\nI've completed a thorough search of both codebases for merge-related logic and prompts. Here are my findings:\n\n---\n\n## 1. MERGE FRAGMENT PROMPTS\n\nBoth repositories contain identical merge fragment files with three strategies:\n\n### Files Found:\n- `/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-auto.md`\n- `/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-direct.md`\n- `/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-pr.md`\n- `/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-auto.md`\n- `/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-direct.md`\n- `/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-pr.md`\n\n### merge-auto.md (Both repos - identical)\nThe auto merge fragment provides a **decision rubric for agents to choose between direct merge or PR**:\n\n**Prefer PR when:**\n- Changes include significant business logic updates\n- Agent is unsure about correctness, scope, or product intent\n- Assumptions were made or review desired\n- Potential edge cases, migrations, or higher-risk changes\n\n**Prefer direct merge only when:**\n- Changes are small, clearly safe, and well-understood\n- All checks pass with no open questions\n\nThen it provides complete instructions for both paths:\n\n**Option A (Direct Merge):** Git merge with --no-ff, conflict handling (clean/simple/complex), push to main, delete branch\n\n**Option B (PR):** Write PR description doc to `horizon-docs/prs/{identifier}.md`, create PR with `gh pr create`, include branch and PR URLs in WORK_RESULT\n\nBoth options output a `WORK_RESULT` block with fields like:\n- `merge_status`: `success`, `blocked`, or `pr_created`\n- `merge_conflict_files`: Array if blocked\n- `pr_url`: URL if PR created\n- `next_status`: Downstream state indicator\n\n### merge-direct.md (Both repos - similar structure)\nFocused instructions for **direct merge only** (skips the decision rubric). Steps:\n1. Get repo URL\n2. Checkout main, merge with --no-ff\n3. Handle clean/simple/complex conflicts\n4. Push and delete branch\n5. Output `merge_status: success` or `blocked`\n\n### merge-pr.md (Both repos - similar structure)\nFocused instructions for **PR-only flow** (skips the decision rubric). Steps:\n1. Get repo URL\n2. Write PR description document\n3. Create PR with `gh pr create --base main --head {branch}`\n4. Output `merge_status: pr_created` with `pr_url`\n\n---\n\n## 2. NAPOLI-MATCHA SYSTEM\n\n### Architecture:\n- **No orchestrator** - runs simplified, single-agent flow\n- **SandboxQueueProcessor.ts**: Loads tasks from `request_queue/*.md` files and spawns isolated Daytona sandboxes\n- **Claude invoked directly** with task instructions via PTY (pseudo-terminal)\n- **No agent pipeline** - single Claude instance per sandbox, no Agent 1/2/3 separation\n\n### Merge Handling:\n**Napoli-matcha does NOT directly handle merging** - it delegates to the prompt/agent:\n```\nThe fullPrompt instructs Claude to:\n1. Create a feature branch (feat/{task.id})\n2. Implement the feature from task.description\n3. Commit changes\n4. Push branch to origin\n5. Create PR using gh pr create\n\nCRITICAL: The prompt says \"Do NOT use interactive flags\"\n```\n\nThe merge fragments are available in the prompt directory but are NOT actively woven into the execution flow - they're template files available if/when agents need guidance on merge strategies.\n\n**Key Code** (`src/lib/SandboxQueueProcessor.ts`, lines 228-236):\n```typescript\nconst fullPrompt = `You are working in a cloned git repo. Your task:\n1. Create a new branch named \"${branchName}\"\n2. Implement the following feature: ${task.description}\n3. Commit your changes with a clear commit message\n4. Push the branch to origin\n5. Create a pull request using \\`gh pr create\\` with title \"${prTitle}\"...`;\n```\n\n---\n\n## 3. HORIZON-CLI-AGENT SYSTEM\n\n### Architecture:\n- **Three-agent orchestrator** (Agent 1 → Agent 2 → Agent 3)\n- **Agent 1 (Linear Reader)**: Reads Linear, selects issue, determines stage (`oneshot`, `research`, `specification`, `plan`, `implement`, `validate`)\n- **Agent 2 (Worker)**: Executes stage-specific work in isolated git worktree\n- **Agent 3 (Linear Writer)**: Updates Linear with results, creates sub-issues, attaches links\n\n### Merge Handling:\n**Merge is Agent 2's responsibility, controlled by `mergeMode` config**\n\n**Types** (`src/types.ts`, line 6):\n```typescript\nexport type MergeMode = 'auto' | 'merge' | 'pr';\n```\n\n**Config** (`src/config.ts`):\n```typescript\nfunction getMergeMode(): MergeMode {\n  const envMode = process.env.HORIZON_MERGE_MODE?.toLowerCase();\n  if (envMode === 'auto') return 'auto';\n  if (envMode === 'merge') return 'merge';\n  if (envMode === 'pr') return 'pr';\n  return 'auto'; // Default: agent decides safest path\n}\n```\n\n**Setup** (`src/index.ts`, lines 659-691):\nUsers configure merge mode during initialization:\n```typescript\nconsole.log('When work completes:');\nconst mergeModeOptions: SelectOption<MergeMode>[] = [\n  { value: 'auto', label: 'auto', description: 'Agent decides: merge directly or create PR (recommended)' },\n  { value: 'merge', label: 'merge', description: 'Merge directly to main' },\n  { value: 'pr', label: 'pr', description: 'Create PR for review' },\n];\n```\n\n**Agent 2 Execution** (`src/index.ts`, lines 354-351):\n```typescript\n// Build worker prompt by combining the base prompt with agent 1's output\nconst workerBasePrompt = await loadPrompt('agent2-worker');\nconst workerPrompt = `...`;\n// Agent 2 is given the loaded prompt which includes stage-specific instructions\n```\n\n**Agent 2 reads stage file** (`prompts/agent2-worker.md`, lines 5-18):\n```markdown\n| Stage | Instructions File |\n|-------|-------------------|\n| oneshot | `.horizon/prompts/agent2-worker-oneshot.md` |\n| validate | `.horizon/prompts/agent2-worker-validate.md` |\n...\n**Read the file for your stage now, then follow those instructions exactly.**\n```\n\nThe stage files (e.g., `agent2-worker-validate.md`, `agent2-worker-oneshot.md`) then include the merge fragments:\n- If `mergeMode === 'auto'`, include `merge-auto.md` → Agent decides\n- If `mergeMode === 'merge'`, include `merge-direct.md` → Force direct merge\n- If `mergeMode === 'pr'`, include `merge-pr.md` → Force PR\n\n**Agent 2 Output** (WORK_RESULT block):\nAgent 2 produces:\n```yaml\nmerge_status: success | blocked | pr_created\nmerge_conflict_files: [list] # if blocked\npr_url: {url}               # if pr_created\nnext_status: \"∞ Done\"       # downstream status\n```\n\n**Agent 3 Consumption** (`prompts/agent3-linear-writer.md`, lines 12-23):\nAgent 3 reads Agent 2's WORK_RESULT and:\n1. Extracts `merge_status`, `pr_url`, `branch_name`\n2. Posts comment to Linear with merge details\n3. Updates Linear status based on `merge_status`:\n   - `success` + `validate/oneshot` → `∞ Done`\n   - `pr_created` → `∞ Awaiting Merge`\n   - `blocked` → Use \"Blocked\" status ID with merge conflict details\n\n---\n\n## 4. KEY DIFFERENCES\n\n| Aspect | napoli-matcha | horizon-cli-agent |\n|--------|---------------|-------------------|\n| **Orchestration** | Single agent per sandbox | Three-agent pipeline |\n| **Merge Strategy** | Hardcoded to PR only (no config) | Configurable: auto/merge/pr |\n| **Agent Awareness** | No - Claude just runs prompt | Yes - Agent 2 reads mergeMode from config, Agent 3 interprets results |\n| **Worktree Isolation** | No - works in cloned repo | Yes - isolated git worktree per issue |\n| **Conflict Handling** | Not implemented | Agent 2 handles clean/simple/complex per merge-auto.md |\n| **Linear Integration** | None - just GitHub | Full - Agent 1 reads, Agent 3 updates with links & status |\n| **Merge Fragment Location** | Available in prompts/ dir but not woven in | Woven into stage files based on mergeMode config |\n\n---\n\n## 5. MERGE DECISION FLOW (Horizon)\n\n```\nConfig:mergeMode (\"auto\" / \"merge\" / \"pr\")\n    ↓\nAgent 1 determines STAGE\n    ↓\nAgent 2 is given stage-specific prompt which includes merge fragment:\n    • If auto → merge-auto.md (agent decides via rubric)\n    • If merge → merge-direct.md (forced direct)\n    • If pr → merge-pr.md (forced PR)\n    ↓\nAgent 2 executes merge logic, outputs WORK_RESULT with merge_status\n    ↓\nAgent 3 reads WORK_RESULT:\n    • Attaches branch/PR links to Linear\n    • Updates Linear status:\n      - success → ∞ Done\n      - pr_created → ∞ Awaiting Merge\n      - blocked → Blocked status with conflict details\n```\n\nAll merge fragments are located in:\n- `/Users/ob1/projects/opus-hackathon/napoli-matcha/prompts/fragments/merge-*.md`\n- `/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-*.md`"}],"totalDurationMs":55837,"totalTokens":63087,"totalToolUseCount":27,"usage":{"input_tokens":4,"cache_creation_input_tokens":568,"cache_read_input_tokens":59883,"output_tokens":2632,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":568},"inference_geo":"","iterations":[],"speed":"standard"}},"sourceToolAssistantUUID":"1e74da03-08de-4e3c-822e-2daffe24cafb"}
{"parentUuid":"5662493e-9b8d-48d8-a7e5-f1ec106ac9e1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_014AjDPiJAHoFXeCZu2Sa8Da","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I have a clear picture. In Horizon:\n\n1. **Merge mode is configurable** via `HORIZON_MERGE_MODE` env var: `auto`, `merge`, or `pr`\n2. **The worker (Agent 2) handles merging** — not the orchestrator. The merge fragment is woven into the stage-specific prompt based on the merge mode.\n3. **Only terminal stages (validate/oneshot) include merge instructions** — non-terminal stages just push to the branch.\n4. **The orchestrator (Agent 3 in Horizon, TypeScript orchestrator in napoli) reads the WORK_RESULT** which includes `merge_status`, `pr_url`, etc.\n\n\n5. **The IMPLEMENTATION_PLAN.md has it backwards** — `tryMerge()` shouldn't be an orchestrator method running git commands. Instead, workers handle merging directly in their sandboxes with `gh auth setup-git` access, and the orchestrator simply reads the merge status from the result and updates the ticket.\n\nSo I need to remove `tryMerge()` from the orchestrator and ensure the worker prompt includes the merge logic for terminal stages.\n\nNow I should confirm this understanding with the user.","signature":"EqQNCkYICxgCKkAOITYtaFgYY+0oATofu9xEb42fZ7OUIwNN6UB4QVOh9RyOdFzze1pGUkUgCP/QVvVE7VbJPY5pMV8AzZfLyUFIEgzhHw1wfLKsIxd3JVYaDK3sGKm2k9pRLpnlTCIwZZkBhIuhUsFkq9lbPmLMZPYPwj0Av+kk5DA4DmNpxDyfLfyq6/b7vhKlsipLtKo3KosMPr+l/mcDWY7Xqg60LDICwIEj07meFvnjVUfLap5xoF8h45bexK08rtfBkusNxMI9lXjb7KGyNj2fp8ESaxQORs20FW7nR0PsPMh+UiPmiR2H/IACltcFIYJEpMtNrX0KZzuIhBLI3FcSwkD2mh/xczfYgw8v/R5hFwvLfqj4dlj+afxayr7eeykYQP+bc31bGOePyFFe8NbErM4kfJwM9Zk0xd4sHca7hvvXJjKuARHW6zVf+7TnFYn87N9DqiuBROunQY1jltGoEUsp+UoGT/f6/4/TzVD+0Ztf2oubTW9k9jPy/ZKS6qnfkaHvscqBLuhU44Bl3RC21FSfbpoz11i/j1JdiFgdLOYFFl/q91YEAvhOtwbEHOxruv9Czz7iMyUlaRvjANPTfd0j9gXKD82/8Z4EMt5V/JoCCMCi41sngvEagNCcjWZ4I0w060M0ItHkwrC/kHL1sBQPVf0A3dJChtHDwk01srkbIjhuWPu6fG3jPyKGwwY6N6O1i19SGNLEsdFO5MTfQiyvFyl/NtH53vZeFYapADb3qogrUq61eqvJ0b5SCU9yZ+Rj4RgFOj/GQHKWwzVsHT3+SW4RKqnB0n12ugx10CU3P9kbS5/RZr63quOsKzx9PtU7XDZG7w6fh5nd61tJqvi+PtWQFJmzD85hqo1BGNJNMDgv9a/4Ponv1BvYxSITx3qbLDhtOszP3BbSlrH3KrOE6wqBLHMo6vGgoX2HH1pNvGQgUpIVlJqKqnU1XbeqjJoIEB6hgQqwWxEGkZQQdr9vyoyi6MlFfGWLVzOmLfQSnAC+mBqvMHlGsncHOFuyKVFLinWDSrvCSW8c3Y0tfaPqoGTH8/ywsChb3JH0W0CCXHJxCsFFOUuez72/6iLUf15xJZCGUH9SB/aH+2C2lgxXeRjwwuqixnmQV6fCSkHtDIKFfJyNHC2nhDVJXh+wgI4d/U8mI4z8uKfdo3soyFQ5XIvzem/Q+L779TFMYU75J5/DobRwXb15XAey8DFkv+7AH8hPcOc8JwaEHxqo0gzlAxth+a4/2rDYw3ZfPul8P75ZlULgZtHuraJZ+ljnfvEMjqJGgSaxDAJTt1ZcPtn8PdjyKw3Fb2tgPJh6FHqsbfPbzFeucvwkVSkBfVLjljfBfqISDcq6Rk8p+sdYYc5O4PKSwKVfLTL7Zz8FCdZ9eKbmonI7/WthrqaoWzdXTP5++M3yCCa9wL5p/9osUlFk2QlZAdbGE89sdAgrJ3j0n+0Fkb76Bv1leyTSN+q+MqQCkFSkqAnqkTpNSILxqH6+RWoW7frtSUF2OerBrn5mrsrz28M+sG9ma+Tv1Ss7gJRNp+h+kJ75lqoq2pB/mXuk23VcBYIuSI/TcJkW4JQ5rCizyOM0Tnsx8mXYaEmcLceuCm5SZ8PKpETOIux17K4HHjKLPDUlRuYmmX0sj7J9wr7j7c4NUcOVp66cSqPSadGaFEKWEhRupbflkc78vuQu0OrB8exZ8/NgUMwIPt/7ALrRiUhh8dblICOIi9lgDL4eilE6nyGL9jjAjAyPVzbWeWUXkXC6knEF3kn3qyfz9UAkbnowQZJtWlej9qgtoiUmyOjmwK9glPwNnH7+5b0eSKafzbIbM1GP0/I2ouUnxBEbPrW3Eh5702ZCg4RiIrWgTdVFYGNipzt1zeDMgMOHOCSwCDRQLRthRN2+4yhdovzuhmwzGH+UimVpGHB3KfdZIKZOJjg27k+l39i5LG+Ic3f3WydsgUZ48hAguEABBtaLjkCB/ihLpmmUHqYuKB7yJe0Jd4rZlb9EICCzLD1Flh5MacKcdj7c3IZaHen7Z6evEiu2XhT4dVkMtJbKTwnq3UxmHTmVip0TIXFJgoZU5oBTzKR4XEPDix+EQ/ol28JrS7SCUT83zhBp5+WftfV4L7Qg026P3mwu4Z2f02feMJbJmvD0QFDyjpQxgKfN6y4UgNFWlrDeZE6mG9zKQ6NyegcQBSY+Heq6751/Ns7pyYUQgYfG5yp6cmFpOpphej97QdyYZelN5aPX7Km6hcpwDlHi9yOoy2Q6fAH/ZMcYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3053,"cache_read_input_tokens":54937,"cache_creation":{"ephemeral_5m_input_tokens":3053,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vqDj61Qs8ug5nF1cCt","type":"assistant","uuid":"b2b488b9-8ecb-4813-8180-4252088039f2","timestamp":"2026-02-14T12:03:51.673Z"}
{"parentUuid":"b2b488b9-8ecb-4813-8180-4252088039f2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_014AjDPiJAHoFXeCZu2Sa8Da","type":"message","role":"assistant","content":[{"type":"text","text":"Now I see the full picture. The current plan has `tryMerge()` as an **orchestrator method** that runs git commands locally. But in Horizon, merging is the **worker's responsibility** — the merge fragment prompt is injected into the worker's stage prompt (validate/oneshot), and the worker executes the merge inside its sandbox. The orchestrator just reads `merge_status` from WORK_RESULT.\n\nThis makes more sense because:\n- Workers already have git/gh access in their sandboxes\n- The merge decision (auto/direct/PR) is better made by the agent that just did the work\n- The orchestrator stays pure — just polling, dispatching, and recording results"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3053,"cache_read_input_tokens":54937,"cache_creation":{"ephemeral_5m_input_tokens":3053,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vqDj61Qs8ug5nF1cCt","type":"assistant","uuid":"e62e34a8-0bb4-4689-ab7c-0ae75eb0a01a","timestamp":"2026-02-14T12:03:56.990Z"}
{"parentUuid":"e62e34a8-0bb4-4689-ab7c-0ae75eb0a01a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_014AjDPiJAHoFXeCZu2Sa8Da","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012hFCu3X3rA153AcBZyoGmE","name":"AskUserQuestion","input":{"questions":[{"question":"Should merging follow the Horizon pattern where the worker handles it (merge fragment in prompt), not the orchestrator?","header":"Merge owner","options":[{"label":"Worker handles merge (Horizon pattern)","description":"Remove tryMerge() from orchestrator. Inject merge fragment into validate/oneshot prompts for terminal tickets. Worker outputs merge_status in WORK_RESULT. Orchestrator just reads the result."},{"label":"Keep orchestrator merge","description":"Keep tryMerge() on the orchestrator. Orchestrator runs git merge/PR locally after the sandbox worker pushes."}],"multiSelect":false},{"question":"Should merge mode be configurable like Horizon (auto/merge/pr)?","header":"Merge mode","options":[{"label":"Yes, configurable (Recommended)","description":"Add mergeMode config (env var or constructor param). 'auto' = agent decides via rubric, 'merge' = direct merge, 'pr' = always create PR."},{"label":"Always PR","description":"Keep it simple — terminal tickets always create a PR, never auto-merge."},{"label":"Always auto","description":"Always let the agent decide using the merge-auto.md rubric."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":3053,"cache_read_input_tokens":54937,"cache_creation":{"ephemeral_5m_input_tokens":3053,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7vqDj61Qs8ug5nF1cCt","type":"assistant","uuid":"207fdcd4-3f4d-41b3-9656-1445acfd81bb","timestamp":"2026-02-14T12:04:00.520Z"}
{"parentUuid":"207fdcd4-3f4d-41b3-9656-1445acfd81bb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_012hFCu3X3rA153AcBZyoGmE","parentToolUseID":"toolu_012hFCu3X3rA153AcBZyoGmE","uuid":"3e13168a-30e8-498f-8dff-eb18146f0665","timestamp":"2026-02-14T12:04:00.524Z"}
{"parentUuid":"3e13168a-30e8-498f-8dff-eb18146f0665","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_012hFCu3X3rA153AcBZyoGmE","toolUseID":"toolu_012hFCu3X3rA153AcBZyoGmE","timestamp":"2026-02-14T12:06:22.828Z","uuid":"efb2f4ac-97ec-4f2e-b136-0f671e4fdc76"}
{"parentUuid":"207fdcd4-3f4d-41b3-9656-1445acfd81bb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Should merging follow the Horizon pattern where the worker handles it (merge fragment in prompt), not the orchestrator?\"=\"Worker handles merge (Horizon pattern)\", \"Should merge mode be configurable like Horizon (auto/merge/pr)?\"=\"Discuss how we can have a PR-merging subagent that will specialize in determining the merge rule after the validation stage.\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_012hFCu3X3rA153AcBZyoGmE"}]},"uuid":"60c34ee7-444e-45cf-8d28-655c206063f3","timestamp":"2026-02-14T12:06:22.824Z","toolUseResult":{"questions":[{"question":"Should merging follow the Horizon pattern where the worker handles it (merge fragment in prompt), not the orchestrator?","header":"Merge owner","options":[{"label":"Worker handles merge (Horizon pattern)","description":"Remove tryMerge() from orchestrator. Inject merge fragment into validate/oneshot prompts for terminal tickets. Worker outputs merge_status in WORK_RESULT. Orchestrator just reads the result."},{"label":"Keep orchestrator merge","description":"Keep tryMerge() on the orchestrator. Orchestrator runs git merge/PR locally after the sandbox worker pushes."}],"multiSelect":false},{"question":"Should merge mode be configurable like Horizon (auto/merge/pr)?","header":"Merge mode","options":[{"label":"Yes, configurable (Recommended)","description":"Add mergeMode config (env var or constructor param). 'auto' = agent decides via rubric, 'merge' = direct merge, 'pr' = always create PR."},{"label":"Always PR","description":"Keep it simple — terminal tickets always create a PR, never auto-merge."},{"label":"Always auto","description":"Always let the agent decide using the merge-auto.md rubric."}],"multiSelect":false}],"answers":{"Should merging follow the Horizon pattern where the worker handles it (merge fragment in prompt), not the orchestrator?":"Worker handles merge (Horizon pattern)","Should merge mode be configurable like Horizon (auto/merge/pr)?":"Discuss how we can have a PR-merging subagent that will specialize in determining the merge rule after the validation stage."}},"sourceToolAssistantUUID":"207fdcd4-3f4d-41b3-9656-1445acfd81bb"}
{"parentUuid":"60c34ee7-444e-45cf-8d28-655c206063f3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01FgMA9PqCAVM1yfVDbtVNj5","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants a dedicated PR-merging subagent that runs after the validation stage and specializes in determining the merge strategy. This is interesting — rather than having the validate/oneshot worker handle merging (Horizon pattern) or the orchestrator doing it directly, they want a separate agent step.\n\nThis would be like a mini Agent 3 — but instead of writing to Linear, it evaluates the work and decides how to merge.\n\nLet me think about how this would fit:\n\n1. After validate/oneshot completes with `next_status: \"Awaiting Merge\"` (or similar)\n2. The orchestrator dispatches a **merge agent** for terminal tickets\n\n\n3. The merge agent would examine the diff, PR description, and test results to decide between direct merge or opening a PR, then execute that decision and return the merge status as part of its work result.\n\nThis creates a dedicated stage in the pipeline specifically for handling merges on terminal tickets. I should clarify what criteria this agent uses to make merge decisions and what permissions it needs.","signature":"EsIICkYICxgCKkBR0VvcRz27GcKOl+8WozZMywSlBYTriMQ7hRlUOzBJCfnggeEn34VWNspbPVsjxjaCEqzkYgLqba5I6rFEcFNgEgxl+HRZcefX/Tb253kaDLY0B+sFdsCIcu5+mCIwCmWERck8Ejq9BBXoHk/jEAkWbNPCS+T5Gm9DUpgerIVJwRnBupDUVlDuZ1+LXUN9KqkHyKxM3vHZ883OFZiIIo6yH/tuvPeuCzI98JZRkRZcNlgj+FjRvDskRLadiluiS8g4xJ4Vel51ka08KE62MPShqE39kRW7hObbok8UghjKMpAyCb3PRRqz7QBwLnrCF25IUAoLs3e9i3Vp+PrbgayC0kIB1FjclsK8JOFi9BEBxPnGGDTGSi096FWQKoU8sjCK9BD2TNvRovQ9FfhFBtS0Ow93WzG+/+1fbN3XMcmWcbyRIaKsVAMjfOC9JLYTb1+IBEYS6j2UBKfIy51hhGUsq1LhbfSqvURD3927KM1VXjJgnAvIPo5uLW2xbtBZ4lN4oVoqzkLb1i4gzh1kdCzI/y+1XQbbZGE8NS+uB3S9z5trToQLA1NXLmdUb7ofhBJL2WGD9YdtUS2f3Rj+mU1+yaHDA/hhjPxvIa0YThArmN+wbm18q+OQuDdT+TYX1VOWpb/K6b8dT5BdWnB4+Kl2pgnpLhmPcHSemS+Y8igkf3cKFLMVbImrxigiLA8Ejnok+ab2PK9FTNSs8IIgjoXHs16VbWGvztvHYDV5R8uMRo3xa3y0Rk0O5GDKneFZlVwRWMg6DSo3dAmGxoMszM6bYiT06sqL3heF7oeoTKDpFEwCB2qvBy5gAPeDegMs1sRqHvMKHoT3pbJpm2DsUHjFQYKZZsbhxPMb4Otpbl/pwlZG2JHj1gNTLyPEYeP78jKPWgX+94r1ccrmaevcdRQgZzO5k0hguL/bBzQgyFlJt9bLG0T0GH7jrWq+dnC4euxQ3iIHwQfu0NlHBI0YbmL0PSvyj0DN6cdyXjW+D2TFjxEHA6dL6hJ7zLu5IMK3RAFhxub3LMWJctfObTaUkb9fAL044Mi8MZMK2M8x4OxALTJqCG3cXIjeB+/CpBDPeF4q7+jzEavTjAFhcxmNt5MTjN2RfZ1drYwl2xYzbQYtqunQkgZ2OhqAEuvW8j5L+9OGbd2DXFjqDzrNRKUeIRTAwFkoKiKOmgxxh9kIvGw47K91yB1ESUDRXVxCTHa6eOV7wDDxSrlHgC1WIsYQgq0FLe5OSg7EsdebirFnvoyGvA+xbxBaPmUghcqIHOvLWKs8ug63sDTiUwD9nse7edOfTr/J8E5/4OncC/3j639cIjINziQZZ6Djwoa3pC1xunERKF1+3iyLRERmNrT0GdE5rdnSXRAkGQsA+Gde7MDpUk+Hl8Vq3LLgHhTe8GgEVOZnAIXuDk7b2KTnlK/U+HWextLL4c/L6fnOZhgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1048,"cache_read_input_tokens":57990,"cache_creation":{"ephemeral_5m_input_tokens":1048,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7w38QC97s3ugBujNUcA","type":"assistant","uuid":"6f2b2149-d13f-4bf0-aafd-f671de0d4c81","timestamp":"2026-02-14T12:06:32.214Z"}
{"parentUuid":"6f2b2149-d13f-4bf0-aafd-f671de0d4c81","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01FgMA9PqCAVM1yfVDbtVNj5","type":"message","role":"assistant","content":[{"type":"text","text":"Interesting — a dedicated merge subagent. Let me make sure I understand the vision before proposing changes.\n\nIn Horizon, the validate/oneshot worker both validates AND merges in one prompt. You're proposing to **split those concerns** — the validate worker just validates, and then a specialized merge agent runs afterward for terminal tickets to decide and execute the merge strategy."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1048,"cache_read_input_tokens":57990,"cache_creation":{"ephemeral_5m_input_tokens":1048,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7w38QC97s3ugBujNUcA","type":"assistant","uuid":"a6f9b3fd-0936-4fe3-bfb7-96baf41adaac","timestamp":"2026-02-14T12:06:32.354Z"}
{"parentUuid":"a6f9b3fd-0936-4fe3-bfb7-96baf41adaac","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01FgMA9PqCAVM1yfVDbtVNj5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015iXS4nyxrmkyJRb2UjY3s7","name":"AskUserQuestion","input":{"questions":[{"question":"Where should the merge subagent run — in the same sandbox as the worker (before teardown), or as a separate invocation?","header":"Merge sandbox","options":[{"label":"Same sandbox as worker","description":"Like the test-writer, runs after validate/oneshot in the same sandbox before teardown. Has access to the full repo state, branch, and test results."},{"label":"Fresh sandbox","description":"Gets its own sandbox. Clones repo, checks out the branch, reviews the diff, and makes the merge decision independently."},{"label":"Local via ClaudeSpawner","description":"Runs locally on your machine (like the Spec Agent), not in a sandbox. Gets the diff and context passed in the prompt. Executes git merge / gh pr create locally."}],"multiSelect":false},{"question":"What should the merge subagent evaluate when deciding the merge strategy?","header":"Merge criteria","options":[{"label":"Full rubric (merge-auto.md)","description":"Use the existing merge-auto.md decision rubric: assess risk, scope, test coverage, confidence — then choose direct merge or PR."},{"label":"Custom criteria","description":"I want to define custom criteria beyond what merge-auto.md covers. I'll describe them."},{"label":"Always create PR, agent writes description","description":"The merge agent always creates a PR but specializes in writing a thorough PR description, linking tickets, and summarizing the chain of work."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1048,"cache_read_input_tokens":57990,"cache_creation":{"ephemeral_5m_input_tokens":1048,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7w38QC97s3ugBujNUcA","type":"assistant","uuid":"0d3500dd-8ecd-4418-b608-aadb19363a53","timestamp":"2026-02-14T12:06:41.316Z"}
{"parentUuid":"0d3500dd-8ecd-4418-b608-aadb19363a53","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_015iXS4nyxrmkyJRb2UjY3s7","parentToolUseID":"toolu_015iXS4nyxrmkyJRb2UjY3s7","uuid":"b7267ea6-d48b-4722-948e-1b5945ac3022","timestamp":"2026-02-14T12:06:41.319Z"}
{"parentUuid":"b7267ea6-d48b-4722-948e-1b5945ac3022","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_015iXS4nyxrmkyJRb2UjY3s7","toolUseID":"toolu_015iXS4nyxrmkyJRb2UjY3s7","timestamp":"2026-02-14T12:07:14.173Z","uuid":"5583a2cf-0d9f-4e1b-ae10-62e4afa05249"}
{"parentUuid":"0d3500dd-8ecd-4418-b608-aadb19363a53","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Where should the merge subagent run — in the same sandbox as the worker (before teardown), or as a separate invocation?\"=\"Same sandbox as worker\", \"What should the merge subagent evaluate when deciding the merge strategy?\"=\"Full rubric (merge-auto.md)\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_015iXS4nyxrmkyJRb2UjY3s7"}]},"uuid":"0c73edb8-27d6-4f1a-a328-196589f9a1cb","timestamp":"2026-02-14T12:07:14.171Z","toolUseResult":{"questions":[{"question":"Where should the merge subagent run — in the same sandbox as the worker (before teardown), or as a separate invocation?","header":"Merge sandbox","options":[{"label":"Same sandbox as worker","description":"Like the test-writer, runs after validate/oneshot in the same sandbox before teardown. Has access to the full repo state, branch, and test results."},{"label":"Fresh sandbox","description":"Gets its own sandbox. Clones repo, checks out the branch, reviews the diff, and makes the merge decision independently."},{"label":"Local via ClaudeSpawner","description":"Runs locally on your machine (like the Spec Agent), not in a sandbox. Gets the diff and context passed in the prompt. Executes git merge / gh pr create locally."}],"multiSelect":false},{"question":"What should the merge subagent evaluate when deciding the merge strategy?","header":"Merge criteria","options":[{"label":"Full rubric (merge-auto.md)","description":"Use the existing merge-auto.md decision rubric: assess risk, scope, test coverage, confidence — then choose direct merge or PR."},{"label":"Custom criteria","description":"I want to define custom criteria beyond what merge-auto.md covers. I'll describe them."},{"label":"Always create PR, agent writes description","description":"The merge agent always creates a PR but specializes in writing a thorough PR description, linking tickets, and summarizing the chain of work."}],"multiSelect":false}],"answers":{"Where should the merge subagent run — in the same sandbox as the worker (before teardown), or as a separate invocation?":"Same sandbox as worker","What should the merge subagent evaluate when deciding the merge strategy?":"Full rubric (merge-auto.md)"}},"sourceToolAssistantUUID":"0d3500dd-8ecd-4418-b608-aadb19363a53"}
{"parentUuid":"0c73edb8-27d6-4f1a-a328-196589f9a1cb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_012UTyqs1wpQPd2BjbbnDG3B","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Now I have a clear picture. The merge subagent:\n\n1. Runs in the **same sandbox** as the worker (like the test-writer), after validate/oneshot for **terminal tickets only**\n2. Uses the **merge-auto.md rubric** to decide between direct merge and PR\n3. Executes the merge/PR creation in the sandbox\n4. Outputs `merge_status` in WORK_RESULT\n\nSo the `dispatchStage()` flow for terminal, code-producing stages becomes:\n1. Run stage prompt (implement/validate/oneshot)\n2. Run test-writer (same sandbox)\n\n\n3. If terminal: run merge agent (same sandbox, uses merge-auto.md)\n4. Return combined results\n\nThe implementation removes `tryMerge()` from the orchestrator and integrates `runMergeAgent()` directly into `dispatchStage()` alongside the test-writer, passing the merge-auto.md rubric and ticket chain context. The orchestrator then interprets the `merge_status` field to transition the ticket state—success moves it to Done, pr_created to Awaiting Merge, and blocked to Blocked.\n\nNow I'm going through the actual code sections to make these updates: replacing the merge function with agent documentation, modifying the dispatch logic to call the merge agent at the terminal stage, updating the queue processor to read merge status instead of calling tryMerge directly, and refreshing the Files table to reflect these changes.","signature":"Eu4LCkYICxgCKkBllmVbXK9S1BxgdJweA2XC1kbEgSeNR4A6Ekcfbqn1If4xiHW6SWt16Ly/iEGl1Ro/ohhgNHelSmqszVytmr2cEgwBSQWnwH5/SUq7qBIaDLhvtWxDdTUj3nLuiiIw/efuUDj6gt5m8A0QklYSx/Uc3+jtZXELaa0R9rNM8MttD1szUzfUfjDbJ4U8N3DWKtUKUFYEXP8YZMb7cE2KfHpGtN1SNn2G91+VFcQ1rA2wz77rBAuSJCQOpxgxBpjsLon6B2DCkweSUu3q7m6lyfcXmaq03a4eXxoNOZCGWi4+JZNkmkl0YHRBDi8vTfCXbVtgu/5k+MhgXOptzKv70KoXUUGa1SIbW25HWLSo7yrS9jHqbINw/+85rYnwX2Vy9hJr4qeFeQUjIFZPPMuJx1GpByROwQUtTOFKe3bx6L8sT55VPLHyjT4P1IqsSttG1PPZSEC1hSeeo0vh95Yejby4i1dKRyXhPIb1B69HeqfE6rLXz5kpAfgfVnfjMgb7SrXg4jrryaiFENvFAsRlAMCoRIXGI8rPC9ZP0/NjCafFM/NlbICgsrrshO+4CFkTrZ+c0z1wtVG5+OTAgY8gEY5unHcw+nV8RST/E4BxYWpjRRfMUpxVgb9hszKM8JqJlInOs9ZMb9MI8mXLz1vTLkgplQu48/AFFbGIZ4EKHHcnMN2zylMfLcrWg/hhWRGehDr8MAobUOmwhI+UdRa0nGSO8JdhZqB41MrU+lJewyFXfuIiYpKb88uv2RVJdvL9fO6rl3zenyYx5V4txN7y3beH2X36T4FS7LG5mUOWfQk5HBVkHREILFsgZBfBgbSHdyH1KOPM7WMH4a48yYN7QQ//c7ABPbNK5rTJzHhNZpI2yT0RNMyVNf+BQBfaKGCXaypGtQBfed3qKEuWw7NSMpW4qvCGHW9XHEfx+G6iDsHKoal3VD9tKSaM5+Noev4elOp9KFFi2DUPLSURdd1qPh6CvTqAhwHefg5URdQVmCJ0BtpLFj1ZEyzKN3fxXRhcGLAMCcI56LF+A23cw4A1Hy+VE+X0CC+btnPg4hQV8YK2lA+Q9tWUjmoiNHE0x7vuEUHab6TzakB7f+EuIA2PqAill1hxFJgijHg8WFst15RqleBixhkVN19bgaPDpeA1c0lL42Hysz1MfLcGSLCmCtwXOXzZ1BH3ftW9dTNclRgg8US8Oec7GzNzxIsKTG5DBWOBbkXo+fytzCb5x2itI0DDFAYAhKWWdcxSMofmiABQLCfnOKoF2gatGlsu452DKB23iMbybqStHEMa6IalCqELv8yu/LDURcxxI044aWA59xpqkf3GKuUfjRx0wbLFm6OlIWEfbBKxxBfmfkPmjX1jdAyr0TLNgYezCDo3aZ2p7e1iRCcvozMYBX1tvSfjD2cOn3RcTWa2ekzZuOw9K2HNiIPsGeBPxWZEmKg3YXjsTAWftMNL65c8dnJ7PTZ5FT/iJIJFJdCtvP09okCiJZYaf1MMZ8bO39HVsET47zA/QsSkLDI8Ds86n/KWW4GlG+JHk7oViXF1FEbgtvtCNF1PV5JQja3Kw1r8W7ey3vDgHFT1UnhDKc9/78JvfA+maCG62W+67f2GASGjYQXxTI5/H+7zm0iEaZaR1skUPe/kaWeW20Les3o5VBRIaulU8bU69RbxkAd0VFKMxNstUCkg5XlauiuAiRwvzDq0gJVBL4lkpAffBASVSPiylfdXR+0wTtcuxS3I18x9Bc+Za/tbHUXW9YcGHuVKvZ7b4IGkh2p3fx8tjc9nAAHlx4364Wt8SzxNQhN801mtCTQgNwJgiFnR9tg1JzAtJQwc8KaimbesISeFtAlkNtgF9V4UBtZWYnEj/6Kie68mDxNQtfK9yTdF8IVsTk7Sk/PHoU6BjOS2vqemL9UOqmP/lrnZ8Dnpq+1Wzfq1Zyvkzk0f+gTVq2P55TJRRJeDBRC2rvyIe2aDz4YUaxKPJApxsM/tWdGauHu/td9/i9T6PjfQypHdH6BeOJFBGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":937,"cache_read_input_tokens":59038,"cache_creation":{"ephemeral_5m_input_tokens":937,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7w6uvi2T6HFiJ7iBN23","type":"assistant","uuid":"7c1e40e9-ae2d-4ced-a3e0-3bdb140453dd","timestamp":"2026-02-14T12:07:24.883Z"}
{"parentUuid":"7c1e40e9-ae2d-4ced-a3e0-3bdb140453dd","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_012UTyqs1wpQPd2BjbbnDG3B","type":"message","role":"assistant","content":[{"type":"text","text":"Clear. So the architecture for terminal tickets in code-producing stages becomes:\n\n```\ndispatchStage(terminal ticket):\n  1. Worker runs stage prompt (validate/oneshot)\n  2. Test-writer runs (same sandbox)\n  3. Merge agent runs (same sandbox, merge-auto.md rubric)\n  4. Returns combined WORK_RESULT with merge_status\n```\n\nThe orchestrator reads `merge_status` from the result:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`  \n- `blocked` → `Blocked`\n\nLet me apply this. First, I'll remove `tryMerge()` and update `processQueue()`, then update `dispatchStage()`."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":937,"cache_read_input_tokens":59038,"cache_creation":{"ephemeral_5m_input_tokens":937,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7w6uvi2T6HFiJ7iBN23","type":"assistant","uuid":"378bf030-4e99-4364-a84c-ceb344f5fcad","timestamp":"2026-02-14T12:07:26.693Z"}
{"parentUuid":"378bf030-4e99-4364-a84c-ceb344f5fcad","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_012UTyqs1wpQPd2BjbbnDG3B","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017j39kj1v24qZMKZ9b85S4v","name":"Read","input":{"file_path":"REDACTED.md","offset":395,"limit":35},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":937,"cache_read_input_tokens":59038,"cache_creation":{"ephemeral_5m_input_tokens":937,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7w6uvi2T6HFiJ7iBN23","type":"assistant","uuid":"a828c838-7950-441b-a42a-737e4d9323cf","timestamp":"2026-02-14T12:07:27.626Z"}
{"parentUuid":"a828c838-7950-441b-a42a-737e4d9323cf","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_017j39kj1v24qZMKZ9b85S4v","parentToolUseID":"toolu_017j39kj1v24qZMKZ9b85S4v","uuid":"83141d36-d13f-4627-b235-27b053ec4679","timestamp":"2026-02-14T12:07:27.631Z"}
{"parentUuid":"83141d36-d13f-4627-b235-27b053ec4679","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_017j39kj1v24qZMKZ9b85S4v","toolUseID":"toolu_017j39kj1v24qZMKZ9b85S4v","timestamp":"2026-02-14T12:07:27.688Z","uuid":"179c9ee6-f2b6-4c66-9de2-4b4bf860935a"}
{"parentUuid":"179c9ee6-f2b6-4c66-9de2-4b4bf860935a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_017j39kj1v24qZMKZ9b85S4v","toolUseID":"toolu_017j39kj1v24qZMKZ9b85S4v","timestamp":"2026-02-14T12:07:27.688Z","uuid":"978e2fb3-7168-4b77-8fbe-8f5fb0c4524e"}
{"parentUuid":"a828c838-7950-441b-a42a-737e4d9323cf","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017j39kj1v24qZMKZ9b85S4v","type":"tool_result","content":"   395→      await sleep(this.pollIntervalSeconds * 1000);\n   396→      continue;\n   397→    }\n   398→\n   399→    for (const task of eligible) {\n   400→      if (active.size >= this.maxConcurrency) break;\n   401→      const stagePrompt = this.stagePromptMap[task.status];\n   402→      if (!stagePrompt) continue;\n   403→\n   404→      // Transition to \"In Progress\" for this stage\n   405→      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n   406→      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n   407→        // Worker returns next_status in WORK_RESULT\n   408→        await this.writeResults(task, result);\n   409→        await this.updateTaskStatus(task, result.nextStatus);\n   410→        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n   411→          if (await this.isTerminal(task)) {\n   412→            await this.tryMerge(task);\n   413→          }\n   414→        }\n   415→        active.delete(task.id);\n   416→      });\n   417→      active.set(task.id, promise);\n   418→      iteration++;\n   419→    }\n   420→\n   421→    if (active.size > 0) {\n   422→      await Promise.race(active.values());\n   423→    }\n   424→  }\n   425→}\n   426→```\n   427→\n   428→### Independent Worker Per Stage (Horizon Pattern)\n   429→"}]},"uuid":"8c1140bf-b8f9-474e-bcf2-ee446095d579","timestamp":"2026-02-14T12:07:27.687Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n","numLines":35,"startLine":395,"totalLines":1063}},"sourceToolAssistantUUID":"a828c838-7950-441b-a42a-737e4d9323cf"}
{"parentUuid":"8c1140bf-b8f9-474e-bcf2-ee446095d579","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01W9sqyUrdxpn5ENk6AmTGtr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013XTAr6PicEyFJGLV2T8WRm","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });","new_string":"      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1116,"cache_read_input_tokens":59975,"cache_creation":{"ephemeral_5m_input_tokens":1116,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7w7ued4hkiErw3zMTUS","type":"assistant","uuid":"1715a103-3bf4-447f-9415-281008f35639","timestamp":"2026-02-14T12:07:34.202Z"}
{"parentUuid":"1715a103-3bf4-447f-9415-281008f35639","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_013XTAr6PicEyFJGLV2T8WRm","parentToolUseID":"toolu_013XTAr6PicEyFJGLV2T8WRm","uuid":"8d00595e-57b5-4852-a1ab-cf670bd3077c","timestamp":"2026-02-14T12:07:34.206Z"}
{"parentUuid":"8d00595e-57b5-4852-a1ab-cf670bd3077c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_013XTAr6PicEyFJGLV2T8WRm","toolUseID":"toolu_013XTAr6PicEyFJGLV2T8WRm","timestamp":"2026-02-14T12:07:34.267Z","uuid":"3f161525-3e35-45be-a1ab-ebc3285da010"}
{"parentUuid":"3f161525-3e35-45be-a1ab-ebc3285da010","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_013XTAr6PicEyFJGLV2T8WRm","toolUseID":"toolu_013XTAr6PicEyFJGLV2T8WRm","timestamp":"2026-02-14T12:07:34.267Z","uuid":"cedba24d-0a1a-4d7c-aa1c-1ed7539edfec"}
{"parentUuid":"1715a103-3bf4-447f-9415-281008f35639","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013XTAr6PicEyFJGLV2T8WRm","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"89b2eb8c-497e-4883-bf02-90169c2fa76c","timestamp":"2026-02-14T12:07:34.266Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });","newString":"      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      // Transition to \"In Progress\" for this stage\n      await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // Worker returns next_status in WORK_RESULT\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {\n          if (await this.isTerminal(task)) {\n            await this.tryMerge(task);\n          }\n        }\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":401,"oldLines":17,"newStart":401,"newLines":12,"lines":["       const stagePrompt = this.stagePromptMap[task.status];","       if (!stagePrompt) continue;"," ","-      // Transition to \"In Progress\" for this stage","-      await this.updateTaskStatus(task, this.inProgressStatus(task.status));","       const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {","-        // Worker returns next_status in WORK_RESULT","+        // dispatchStage handles: stage → test-writer → merge agent (if terminal)","+        // merge_status in result determines final status:","+        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked","         await this.writeResults(task, result);","         await this.updateTaskStatus(task, result.nextStatus);","-        if (result.nextStatus === \"Done\" || result.nextStatus === \"Awaiting Merge\") {","-          if (await this.isTerminal(task)) {","-            await this.tryMerge(task);","-          }","-        }","         active.delete(task.id);","       });","       active.set(task.id, promise);"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"1715a103-3bf4-447f-9415-281008f35639"}
{"parentUuid":"89b2eb8c-497e-4883-bf02-90169c2fa76c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01QyFEgbjaRrMwm4jVUKTZzf","type":"message","role":"assistant","content":[{"type":"text","text":"Now remove the `tryMerge()` method and replace it with merge agent documentation. Let me find it."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":474,"cache_read_input_tokens":61091,"cache_creation":{"ephemeral_5m_input_tokens":474,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7w8Pj56NuNtGbjrbhKV","type":"assistant","uuid":"2c525769-eb35-46c7-945d-e504e610211d","timestamp":"2026-02-14T12:07:37.029Z"}
{"parentUuid":"2c525769-eb35-46c7-945d-e504e610211d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01QyFEgbjaRrMwm4jVUKTZzf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XQbXr4QwVHNkVagJdxACTR","name":"Read","input":{"file_path":"REDACTED.md","offset":560,"limit":45},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":474,"cache_read_input_tokens":61091,"cache_creation":{"ephemeral_5m_input_tokens":474,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7w8Pj56NuNtGbjrbhKV","type":"assistant","uuid":"22fb67aa-1ea1-4a3d-8065-dcf7a48788b9","timestamp":"2026-02-14T12:07:37.809Z"}
{"parentUuid":"22fb67aa-1ea1-4a3d-8065-dcf7a48788b9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01XQbXr4QwVHNkVagJdxACTR","parentToolUseID":"toolu_01XQbXr4QwVHNkVagJdxACTR","uuid":"b2ddbf74-a5c5-4176-871e-cb8d07a868cb","timestamp":"2026-02-14T12:07:37.812Z"}
{"parentUuid":"b2ddbf74-a5c5-4176-871e-cb8d07a868cb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01XQbXr4QwVHNkVagJdxACTR","toolUseID":"toolu_01XQbXr4QwVHNkVagJdxACTR","timestamp":"2026-02-14T12:07:37.868Z","uuid":"20d25a3c-15d1-480e-9875-97b373965a47"}
{"parentUuid":"20d25a3c-15d1-480e-9875-97b373965a47","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01XQbXr4QwVHNkVagJdxACTR","toolUseID":"toolu_01XQbXr4QwVHNkVagJdxACTR","timestamp":"2026-02-14T12:07:37.868Z","uuid":"4c5ff77a-661e-4ef1-92a2-98bf3a97bc1b"}
{"parentUuid":"22fb67aa-1ea1-4a3d-8065-dcf7a48788b9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XQbXr4QwVHNkVagJdxACTR","type":"tool_result","content":"   560→- Commit: abc1234\n   561→- PR: https://github.com/user/repo/pull/43  (only if terminal)\n   562→```\n   563→\n   564→### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n   565→\n   566→Previous plan merged after every ticket. Now merge only when `isTerminal(task)`:\n   567→\n   568→```typescript\n   569→private async tryMerge(task: TaskRequest): Promise<boolean> {\n   570→  const branch = this.branchName(task);\n   571→  try {\n   572→    execSync(\n   573→      `git fetch origin && git checkout ${branch} && git rebase main` +\n   574→      ` && git checkout main && git merge ${branch}`\n   575→    );\n   576→    return true;\n   577→  } catch {\n   578→    await this.updateTaskStatus(task, \"Blocked\");\n   579→    return false;\n   580→  }\n   581→}\n   582→```\n   583→\n   584→For non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n   585→\n   586→---\n   587→\n   588→## Phase 4: Entry Point (`src/index.ts`)\n   589→\n   590→Two modes of operation:\n   591→\n   592→```typescript\n   593→async function main() {\n   594→  const command = process.argv[2];\n   595→\n   596→  if (command === \"spec\") {\n   597→    const request = process.argv.slice(3).join(\" \") || await readStdin();\n   598→    const specAgent = new SpecAgent(queueDir);\n   599→    await specAgent.clarify(request);\n   600→  } else {\n   601→    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n   602→    await orchestrator.processQueue();\n   603→  }\n   604→}"}]},"uuid":"8f06da37-9f24-430e-9d8a-b69a5dc026e4","timestamp":"2026-02-14T12:07:37.867Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}","numLines":45,"startLine":560,"totalLines":1058}},"sourceToolAssistantUUID":"22fb67aa-1ea1-4a3d-8065-dcf7a48788b9"}
{"parentUuid":"8f06da37-9f24-430e-9d8a-b69a5dc026e4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_013zppSqaG578KEFrv1kDEs9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01M7bKTCbijnNoJjes4zzJz9","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.","new_string":"### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":657,"cache_read_input_tokens":61565,"cache_creation":{"ephemeral_5m_input_tokens":657,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7w8fCVRbMKYMrVH2uQH","type":"assistant","uuid":"a72e03be-2e7a-49f3-8776-281fe98db64c","timestamp":"2026-02-14T12:07:46.699Z"}
{"parentUuid":"a72e03be-2e7a-49f3-8776-281fe98db64c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01M7bKTCbijnNoJjes4zzJz9","parentToolUseID":"toolu_01M7bKTCbijnNoJjes4zzJz9","uuid":"0963bb2c-77ca-426d-ba54-3903ecdd3590","timestamp":"2026-02-14T12:07:46.702Z"}
{"parentUuid":"0963bb2c-77ca-426d-ba54-3903ecdd3590","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01M7bKTCbijnNoJjes4zzJz9","toolUseID":"toolu_01M7bKTCbijnNoJjes4zzJz9","timestamp":"2026-02-14T12:07:46.750Z","uuid":"1ddb4c15-2602-4a8d-93e8-490c1681c1db"}
{"parentUuid":"1ddb4c15-2602-4a8d-93e8-490c1681c1db","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01M7bKTCbijnNoJjes4zzJz9","toolUseID":"toolu_01M7bKTCbijnNoJjes4zzJz9","timestamp":"2026-02-14T12:07:46.750Z","uuid":"202c95f4-8b81-4372-99d4-08b02999f1c1"}
{"parentUuid":"a72e03be-2e7a-49f3-8776-281fe98db64c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01M7bKTCbijnNoJjes4zzJz9","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"cafc7088-33cb-43bb-8750-5dc35a2860a8","timestamp":"2026-02-14T12:07:46.749Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.","newString":"### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Sequential Merge Step — Terminal Tickets Only (CHANGED)\n\nPrevious plan merged after every ticket. Now merge only when `isTerminal(task)`:\n\n```typescript\nprivate async tryMerge(task: TaskRequest): Promise<boolean> {\n  const branch = this.branchName(task);\n  try {\n    execSync(\n      `git fetch origin && git checkout ${branch} && git rebase main` +\n      ` && git checkout main && git merge ${branch}`\n    );\n    return true;\n  } catch {\n    await this.updateTaskStatus(task, \"Blocked\");\n    return false;\n  }\n}\n```\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":561,"oldLines":28,"newStart":561,"newLines":23,"lines":[" - PR: https://github.com/user/repo/pull/43  (only if terminal)"," ```"," ","-### Sequential Merge Step — Terminal Tickets Only (CHANGED)","+### Merge Agent — Terminal Tickets Only (CHANGED)"," ","-Previous plan merged after every ticket. Now merge only when `isTerminal(task)`:","+Merging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does."," ","-```typescript","-private async tryMerge(task: TaskRequest): Promise<boolean> {","-  const branch = this.branchName(task);","-  try {","-    execSync(","-      `git fetch origin && git checkout ${branch} && git rebase main` +","-      ` && git checkout main && git merge ${branch}`","-    );","-    return true;","-  } catch {","-    await this.updateTaskStatus(task, \"Blocked\");","-    return false;","-  }","-}","-```","+The merge agent:","+1. Runs in the same sandbox (has full repo state, branch, test results)","+2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR","+3. Executes `git merge --no-ff` or `gh pr create` accordingly","+4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`"," ","-For non-terminal grouped tickets: the worker just pushes to the shared group branch. The next ticket in the chain picks up where it left off.","+The orchestrator maps `merge_status` to the final ticket status:","+- `success` → `Done`","+- `pr_created` → `Awaiting Merge`","+- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)"," ","+For non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.","+"," ---"," "," ## Phase 4: Entry Point (`src/index.ts`)"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"a72e03be-2e7a-49f3-8776-281fe98db64c"}
{"parentUuid":"cafc7088-33cb-43bb-8750-5dc35a2860a8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01EESwWKohJbeh7WzP1mRrD1","type":"message","role":"assistant","content":[{"type":"text","text":"Now update `dispatchStage()` in the Phase 3 section to include the merge agent step."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":618,"cache_read_input_tokens":62222,"cache_creation":{"ephemeral_5m_input_tokens":618,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7w9KDEnZd1vXUrijLNy","type":"assistant","uuid":"0583d485-caec-462c-9e62-6fbda5d2120b","timestamp":"2026-02-14T12:07:49.525Z"}
{"parentUuid":"0583d485-caec-462c-9e62-6fbda5d2120b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01EESwWKohJbeh7WzP1mRrD1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KbuPq1J9147BMcFAzfoYwF","name":"Read","input":{"file_path":"REDACTED.md","offset":720,"limit":40},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":618,"cache_read_input_tokens":62222,"output_tokens":137,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":618},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7w9KDEnZd1vXUrijLNy","type":"assistant","uuid":"6e8e0431-93d7-4533-a2a7-eb95e2134255","timestamp":"2026-02-14T12:07:50.658Z"}
{"parentUuid":"6e8e0431-93d7-4533-a2a7-eb95e2134255","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01KbuPq1J9147BMcFAzfoYwF","parentToolUseID":"toolu_01KbuPq1J9147BMcFAzfoYwF","uuid":"136ad56d-0d89-4e30-be1d-15517f638710","timestamp":"2026-02-14T12:07:50.661Z"}
{"parentUuid":"136ad56d-0d89-4e30-be1d-15517f638710","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01KbuPq1J9147BMcFAzfoYwF","toolUseID":"toolu_01KbuPq1J9147BMcFAzfoYwF","timestamp":"2026-02-14T12:07:50.698Z","uuid":"329ff4d8-a7d7-4f4f-b7fc-c00067b94ced"}
{"parentUuid":"329ff4d8-a7d7-4f4f-b7fc-c00067b94ced","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01KbuPq1J9147BMcFAzfoYwF","toolUseID":"toolu_01KbuPq1J9147BMcFAzfoYwF","timestamp":"2026-02-14T12:07:50.698Z","uuid":"0f15e85e-d4a3-4f6d-a1ea-8e8b74cc4dc0"}
{"parentUuid":"6e8e0431-93d7-4533-a2a7-eb95e2134255","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KbuPq1J9147BMcFAzfoYwF","type":"tool_result","content":"   720→    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n   721→  }\n   722→\n   723→  return { stage: stageResult, tests: testResult };\n   724→}\n   725→```\n   726→\n   727→Key change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n   728→\n   729→### WORK_RESULT Stage Output\n   730→\n   731→Each stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n   732→\n   733→```yaml\n   734→WORK_RESULT\n   735→---\n   736→success: true\n   737→stage_completed: research\n   738→workflow: staged          # or \"oneshot\"\n   739→next_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n   740→---\n   741→```\n   742→\n   743→### Intervention Statuses\n   744→\n   745→When a worker cannot proceed, it sets one of three intervention statuses:\n   746→\n   747→| Status | Meaning | Example |\n   748→|--------|---------|---------|\n   749→| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n   750→| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n   751→| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n   752→\n   753→Intervention output includes structured context for the human:\n   754→\n   755→```yaml\n   756→WORK_RESULT\n   757→---\n   758→success: false\n   759→stage_completed: research"}]},"uuid":"d6b732b4-66d3-4aff-ae57-90d5164be482","timestamp":"2026-02-14T12:07:50.697Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research","numLines":40,"startLine":720,"totalLines":1053}},"sourceToolAssistantUUID":"6e8e0431-93d7-4533-a2a7-eb95e2134255"}
{"parentUuid":"d6b732b4-66d3-4aff-ae57-90d5164be482","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01GE2godS73KzPToDVi2Xi7z","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Kf1Kqemar3WdSdPZ354JNn","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.","new_string":"  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":648,"cache_read_input_tokens":62840,"output_tokens":439,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":648},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7w9c9DbUru7rKQfAUjv","type":"assistant","uuid":"af0285da-bc3f-48a0-adb5-e0f1717426dc","timestamp":"2026-02-14T12:07:59.432Z"}
{"parentUuid":"af0285da-bc3f-48a0-adb5-e0f1717426dc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01Kf1Kqemar3WdSdPZ354JNn","parentToolUseID":"toolu_01Kf1Kqemar3WdSdPZ354JNn","uuid":"0b97dc6c-6787-4f05-9f05-1cef0e48b42b","timestamp":"2026-02-14T12:07:59.435Z"}
{"parentUuid":"0b97dc6c-6787-4f05-9f05-1cef0e48b42b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01Kf1Kqemar3WdSdPZ354JNn","toolUseID":"toolu_01Kf1Kqemar3WdSdPZ354JNn","timestamp":"2026-02-14T12:07:59.495Z","uuid":"d9e201f8-55d4-466c-95b8-fafc6f035003"}
{"parentUuid":"d9e201f8-55d4-466c-95b8-fafc6f035003","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01Kf1Kqemar3WdSdPZ354JNn","toolUseID":"toolu_01Kf1Kqemar3WdSdPZ354JNn","timestamp":"2026-02-14T12:07:59.495Z","uuid":"8d469d29-7978-443a-bcb3-9ab224a28313"}
{"parentUuid":"af0285da-bc3f-48a0-adb5-e0f1717426dc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Kf1Kqemar3WdSdPZ354JNn","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"16506e77-cfd0-42a9-80df-f50c14f9219d","timestamp":"2026-02-14T12:07:59.494Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.","newString":"  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":720,"oldLines":12,"newStart":720,"newLines":21,"lines":["     testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));","   }"," ","-  return { stage: stageResult, tests: testResult };","+  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)","+  let mergeResult: MergeResult | undefined;","+  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {","+    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment","+    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);","+  }","+","+  return { stage: stageResult, tests: testResult, merge: mergeResult };"," }"," ```"," "," Key change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT."," ","+For terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.","+"," ### WORK_RESULT Stage Output"," "," Each stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"af0285da-bc3f-48a0-adb5-e0f1717426dc"}
{"parentUuid":"16506e77-cfd0-42a9-80df-f50c14f9219d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01FoMVBym6UAxgzCcbj6J9D1","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the Phase 5 version of `dispatchStage()` to match."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":484,"cache_read_input_tokens":63488,"cache_creation":{"ephemeral_5m_input_tokens":484,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wAFtqZd5oXkxkktqKw","type":"assistant","uuid":"ab7ebd86-fb33-4930-b3e4-2f2a5f1cef2c","timestamp":"2026-02-14T12:08:02.018Z"}
{"parentUuid":"ab7ebd86-fb33-4930-b3e4-2f2a5f1cef2c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01FoMVBym6UAxgzCcbj6J9D1","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RquyTzGahqB4WDa2GMjgoS","name":"Read","input":{"file_path":"REDACTED.md","offset":1010,"limit":40},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":484,"cache_read_input_tokens":63488,"cache_creation":{"ephemeral_5m_input_tokens":484,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wAFtqZd5oXkxkktqKw","type":"assistant","uuid":"da0acb5d-5fca-4075-bd43-51b4fe1b321c","timestamp":"2026-02-14T12:08:02.769Z"}
{"parentUuid":"da0acb5d-5fca-4075-bd43-51b4fe1b321c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01RquyTzGahqB4WDa2GMjgoS","parentToolUseID":"toolu_01RquyTzGahqB4WDa2GMjgoS","uuid":"e664532b-79cd-4ece-925b-087badb073e7","timestamp":"2026-02-14T12:08:02.771Z"}
{"parentUuid":"e664532b-79cd-4ece-925b-087badb073e7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01RquyTzGahqB4WDa2GMjgoS","toolUseID":"toolu_01RquyTzGahqB4WDa2GMjgoS","timestamp":"2026-02-14T12:08:02.812Z","uuid":"ed4454f1-8bfb-4b83-8d6b-9b8b37fbdea1"}
{"parentUuid":"ed4454f1-8bfb-4b83-8d6b-9b8b37fbdea1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01RquyTzGahqB4WDa2GMjgoS","toolUseID":"toolu_01RquyTzGahqB4WDa2GMjgoS","timestamp":"2026-02-14T12:08:02.812Z","uuid":"12afd5e5-ae49-4daa-bba3-805e1d9f5c1b"}
{"parentUuid":"da0acb5d-5fca-4075-bd43-51b4fe1b321c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RquyTzGahqB4WDa2GMjgoS","type":"tool_result","content":"  1010→\n  1011→private async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  1012→  const sandbox = await this.createSandbox(task);\n  1013→  const originalStatus = task.status;  // capture before mutation\n  1014→\n  1015→  // Step 1: Transition to In Progress, then run the stage prompt\n  1016→  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  1017→  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n  1018→\n  1019→  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  1020→  let testResult: TestResult | undefined;\n  1021→  if (this.codeProducingStages.has(originalStatus)) {\n  1022→    const isTerminal = await this.isTerminal(task);\n  1023→    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  1024→    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  1025→  }\n  1026→\n  1027→  return { stage: stageResult, tests: testResult };\n  1028→}\n  1029→```\n  1030→\n  1031→### `writeResults` Update\n  1032→\n  1033→The result block now includes test metadata:\n  1034→\n  1035→```markdown\n  1036→## Results\n  1037→\n  1038→**Completed**: 2026-02-14T12:00:00Z\n  1039→**Branch**: feat/dashboard-v2\n  1040→\n  1041→### Summary\n  1042→{parsed from WORK_RESULT}\n  1043→\n  1044→### Tests\n  1045→- Unit tests: 8\n  1046→- Integration tests: 3 (terminal only)\n  1047→- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n  1048→- All passing: true\n  1049→"}]},"uuid":"44d0dfce-d542-482d-8828-1924b6ebfafd","timestamp":"2026-02-14T12:08:02.811Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n","numLines":40,"startLine":1010,"totalLines":1062}},"sourceToolAssistantUUID":"da0acb5d-5fca-4075-bd43-51b4fe1b321c"}
{"parentUuid":"44d0dfce-d542-482d-8828-1924b6ebfafd","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_0161eRLNUFvcpPVnBNsLfsRR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BV382t6NFbEoEWSUbGuXXC","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true","new_string":"  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test and merge metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Merge (terminal only)\n- Strategy: PR (or direct merge)\n- Status: pr_created\n- PR: https://github.com/user/repo/pull/43"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":792,"cache_read_input_tokens":63972,"cache_creation":{"ephemeral_5m_input_tokens":792,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wAVozhkoHBCyeYFxgd","type":"assistant","uuid":"97c72741-3433-45c5-9a1a-3a5f9ca6269f","timestamp":"2026-02-14T12:08:11.028Z"}
{"parentUuid":"97c72741-3433-45c5-9a1a-3a5f9ca6269f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01BV382t6NFbEoEWSUbGuXXC","parentToolUseID":"toolu_01BV382t6NFbEoEWSUbGuXXC","uuid":"9fd0c3e6-94cb-4d71-8147-c519e19caa5c","timestamp":"2026-02-14T12:08:11.030Z"}
{"parentUuid":"9fd0c3e6-94cb-4d71-8147-c519e19caa5c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01BV382t6NFbEoEWSUbGuXXC","toolUseID":"toolu_01BV382t6NFbEoEWSUbGuXXC","timestamp":"2026-02-14T12:08:11.077Z","uuid":"12e2e0fc-76d0-4ea1-b9d1-bceb283a5835"}
{"parentUuid":"12e2e0fc-76d0-4ea1-b9d1-bceb283a5835","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01BV382t6NFbEoEWSUbGuXXC","toolUseID":"toolu_01BV382t6NFbEoEWSUbGuXXC","timestamp":"2026-02-14T12:08:11.077Z","uuid":"bbf2dfc9-0f40-4a2e-b385-c9d9953a65cc"}
{"parentUuid":"97c72741-3433-45c5-9a1a-3a5f9ca6269f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BV382t6NFbEoEWSUbGuXXC","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"29ae40ca-4d86-4e8a-9272-2d7010b47836","timestamp":"2026-02-14T12:08:11.076Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true","newString":"  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test and merge metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Merge (terminal only)\n- Strategy: PR (or direct merge)\n- Status: pr_created\n- PR: https://github.com/user/repo/pull/43","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  return { stage: stageResult, tests: testResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":1024,"oldLines":13,"newStart":1024,"newLines":20,"lines":["     testResult = await this.runTestWriterAgent(sandbox, testPrompt);","   }"," ","-  return { stage: stageResult, tests: testResult };","+  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)","+  let mergeResult: MergeResult | undefined;","+  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {","+    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment","+    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);","+  }","+","+  return { stage: stageResult, tests: testResult, merge: mergeResult };"," }"," ```"," "," ### `writeResults` Update"," ","-The result block now includes test metadata:","+The result block now includes test and merge metadata:"," "," ```markdown"," ## Results"]},{"oldStart":1047,"oldLines":6,"newStart":1054,"newLines":11,"lines":[" - Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts"," - All passing: true"," ","+### Merge (terminal only)","+- Strategy: PR (or direct merge)","+- Status: pr_created","+- PR: https://github.com/user/repo/pull/43","+"," ### Artifacts"," - Commit: abc1234 (implementation)"," - Commit: def5678 (tests)"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"97c72741-3433-45c5-9a1a-3a5f9ca6269f"}
{"parentUuid":"29ae40ca-4d86-4e8a-9272-2d7010b47836","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01NBG1245tbiH4BDb7PffMpN","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the Files table to reflect the merge agent additions. Let me also update the `dispatchStage` description in the Phase 3 narrative."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":840,"cache_read_input_tokens":64764,"cache_creation":{"ephemeral_5m_input_tokens":840,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wB7Bk6QzVXdeqcKGx6","type":"assistant","uuid":"01205d07-f196-4085-988b-c1e9a3e8c1ad","timestamp":"2026-02-14T12:08:14.312Z"}
{"parentUuid":"01205d07-f196-4085-988b-c1e9a3e8c1ad","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01NBG1245tbiH4BDb7PffMpN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XACFEafHP3ye5HfSUdDFwx","name":"Read","input":{"file_path":"REDACTED.md","offset":521,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":840,"cache_read_input_tokens":64764,"cache_creation":{"ephemeral_5m_input_tokens":840,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wB7Bk6QzVXdeqcKGx6","type":"assistant","uuid":"4d115d21-7523-4948-a0de-1817cbb5ce1e","timestamp":"2026-02-14T12:08:15.098Z"}
{"parentUuid":"4d115d21-7523-4948-a0de-1817cbb5ce1e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01XACFEafHP3ye5HfSUdDFwx","parentToolUseID":"toolu_01XACFEafHP3ye5HfSUdDFwx","uuid":"de299cf7-0394-438f-9862-624aedcf3510","timestamp":"2026-02-14T12:08:15.101Z"}
{"parentUuid":"de299cf7-0394-438f-9862-624aedcf3510","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01XACFEafHP3ye5HfSUdDFwx","toolUseID":"toolu_01XACFEafHP3ye5HfSUdDFwx","timestamp":"2026-02-14T12:08:15.156Z","uuid":"a9592dcf-099b-4fa5-b236-751ec9b73547"}
{"parentUuid":"a9592dcf-099b-4fa5-b236-751ec9b73547","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01XACFEafHP3ye5HfSUdDFwx","toolUseID":"toolu_01XACFEafHP3ye5HfSUdDFwx","timestamp":"2026-02-14T12:08:15.156Z","uuid":"f1930243-be8c-4066-8efe-5f2f0dd22739"}
{"parentUuid":"4d115d21-7523-4948-a0de-1817cbb5ce1e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XACFEafHP3ye5HfSUdDFwx","type":"tool_result","content":"   521→- **Terminal**: Create PR, attempt merge to main\n   522→- **Non-terminal**: Just push to group branch, no PR, no merge\n   523→\n   524→### `branchName(task)` — Group-Aware Branch Naming (NEW)\n   525→\n   526→```typescript\n   527→private branchName(task: TaskRequest): string {\n   528→  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n   529→}\n   530→```\n   531→\n   532→### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n   533→\n   534→Each invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n   535→"}]},"uuid":"139f0d81-75c7-41d9-bafe-a208f5ab3adf","timestamp":"2026-02-14T12:08:15.155Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n","numLines":15,"startLine":521,"totalLines":1074}},"sourceToolAssistantUUID":"4d115d21-7523-4948-a0de-1817cbb5ce1e"}
{"parentUuid":"139f0d81-75c7-41d9-bafe-a208f5ab3adf","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_012PY8cv56LNcES4jCoxp87M","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01B6Er1kyDxkgmVCbLBWa4hy","name":"Read","input":{"file_path":"REDACTED.md","offset":535,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":371,"cache_read_input_tokens":65604,"cache_creation":{"ephemeral_5m_input_tokens":371,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wBQbjt7rSyBTdCQRrT","type":"assistant","uuid":"99c20879-4f00-4514-99ce-9a052a16fde9","timestamp":"2026-02-14T12:08:18.105Z"}
{"parentUuid":"99c20879-4f00-4514-99ce-9a052a16fde9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01B6Er1kyDxkgmVCbLBWa4hy","parentToolUseID":"toolu_01B6Er1kyDxkgmVCbLBWa4hy","uuid":"3ce3d773-bdf1-45d6-b8d2-05788e320c88","timestamp":"2026-02-14T12:08:18.109Z"}
{"parentUuid":"3ce3d773-bdf1-45d6-b8d2-05788e320c88","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01B6Er1kyDxkgmVCbLBWa4hy","toolUseID":"toolu_01B6Er1kyDxkgmVCbLBWa4hy","timestamp":"2026-02-14T12:08:18.168Z","uuid":"e6a8776f-3512-4d33-894b-79fd7321a32a"}
{"parentUuid":"e6a8776f-3512-4d33-894b-79fd7321a32a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01B6Er1kyDxkgmVCbLBWa4hy","toolUseID":"toolu_01B6Er1kyDxkgmVCbLBWa4hy","timestamp":"2026-02-14T12:08:18.168Z","uuid":"16e4568c-4c2d-4734-993b-547eb3351e63"}
{"parentUuid":"99c20879-4f00-4514-99ce-9a052a16fde9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01B6Er1kyDxkgmVCbLBWa4hy","type":"tool_result","content":"   535→\n   536→Key behaviors:\n   537→1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n   538→2. **Branch name** passed to worker prompt uses `branchName(task)`\n   539→3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n   540→4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n   541→5. **`variant_hint`** included in worker prompt when present\n   542→6. Returns parsed WORK_RESULT including `nextStatus` field\n   543→7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n   544→8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n   545→\n   546→### `writeResults(task, result)` — Update MD File\n   547→\n   548→Parses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n   549→"}]},"uuid":"7b094de7-09a0-4510-a07d-11db66d16b50","timestamp":"2026-02-14T12:08:18.167Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n","numLines":15,"startLine":535,"totalLines":1074}},"sourceToolAssistantUUID":"99c20879-4f00-4514-99ce-9a052a16fde9"}
{"parentUuid":"7b094de7-09a0-4510-a07d-11db66d16b50","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01EF3oaLc6zJfWd5vY8MxaFS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TkcGMQLFFiyEz5SStGKB5x","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.","new_string":"3. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":497,"cache_read_input_tokens":65975,"output_tokens":626,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":497},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7wBdY7aHx7pnE2eNFTk","type":"assistant","uuid":"b8a1a5d7-4df7-48c8-8726-c30ab2440049","timestamp":"2026-02-14T12:08:26.660Z"}
{"parentUuid":"b8a1a5d7-4df7-48c8-8726-c30ab2440049","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01TkcGMQLFFiyEz5SStGKB5x","parentToolUseID":"toolu_01TkcGMQLFFiyEz5SStGKB5x","uuid":"d44dbbea-0f1e-4756-b021-25a8da26c804","timestamp":"2026-02-14T12:08:26.662Z"}
{"parentUuid":"d44dbbea-0f1e-4756-b021-25a8da26c804","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01TkcGMQLFFiyEz5SStGKB5x","toolUseID":"toolu_01TkcGMQLFFiyEz5SStGKB5x","timestamp":"2026-02-14T12:08:26.707Z","uuid":"ec07d70b-e262-4f34-99c6-c715d44b331a"}
{"parentUuid":"ec07d70b-e262-4f34-99c6-c715d44b331a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01TkcGMQLFFiyEz5SStGKB5x","toolUseID":"toolu_01TkcGMQLFFiyEz5SStGKB5x","timestamp":"2026-02-14T12:08:26.707Z","uuid":"6a680158-e38b-438c-88f2-92f2a0482b09"}
{"parentUuid":"b8a1a5d7-4df7-48c8-8726-c30ab2440049","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TkcGMQLFFiyEz5SStGKB5x","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"52462489-7263-47e3-b8da-05a1158981f2","timestamp":"2026-02-14T12:08:26.706Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.","newString":"3. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)\n4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n5. **`variant_hint`** included in worker prompt when present\n6. Returns parsed WORK_RESULT including `nextStatus` field\n7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test and merge metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Merge (terminal only)\n- Strategy: PR (or direct merge)\n- Status: pr_created\n- PR: https://github.com/user/repo/pull/43\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":536,"oldLines":12,"newStart":536,"newLines":14,"lines":[" Key behaviors:"," 1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`"," 2. **Branch name** passed to worker prompt uses `branchName(task)`","-3. **Worker prompt includes `isTerminal` flag** so the worker knows whether to create a PR (only relevant for validate/oneshot stages)","-4. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)","-5. **`variant_hint`** included in worker prompt when present","-6. Returns parsed WORK_RESULT including `nextStatus` field","-7. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)","-8. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.","+3. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)","+4. **`variant_hint`** included in worker prompt when present","+5. Returns parsed WORK_RESULT including `nextStatus` field","+6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)","+7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.","+8. **Post-stage subagents** (same sandbox, before teardown):","+   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.","+   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`."," "," ### `writeResults(task, result)` — Update MD File"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"b8a1a5d7-4df7-48c8-8726-c30ab2440049"}
{"parentUuid":"52462489-7263-47e3-b8da-05a1158981f2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_017sjZPUyNG7XJkcXvrxGN6X","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the Files table to include merge agent references."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":671,"cache_read_input_tokens":66472,"cache_creation":{"ephemeral_5m_input_tokens":671,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wCGWqzzRns7iYEtbHe","type":"assistant","uuid":"a9334066-5c00-404f-8546-b2d617dc253a","timestamp":"2026-02-14T12:08:29.011Z"}
{"parentUuid":"a9334066-5c00-404f-8546-b2d617dc253a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_017sjZPUyNG7XJkcXvrxGN6X","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CuLiejkE8d2AaVvGo2VTf6","name":"Read","input":{"file_path":"REDACTED.md","offset":890,"limit":20},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":671,"cache_read_input_tokens":66472,"cache_creation":{"ephemeral_5m_input_tokens":671,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wCGWqzzRns7iYEtbHe","type":"assistant","uuid":"dec28535-98b7-43b7-82f2-0bad3424cb39","timestamp":"2026-02-14T12:08:29.787Z"}
{"parentUuid":"dec28535-98b7-43b7-82f2-0bad3424cb39","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01CuLiejkE8d2AaVvGo2VTf6","parentToolUseID":"toolu_01CuLiejkE8d2AaVvGo2VTf6","uuid":"c5a4d84f-8469-4667-b1c6-48fc313e315e","timestamp":"2026-02-14T12:08:29.790Z"}
{"parentUuid":"c5a4d84f-8469-4667-b1c6-48fc313e315e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01CuLiejkE8d2AaVvGo2VTf6","toolUseID":"toolu_01CuLiejkE8d2AaVvGo2VTf6","timestamp":"2026-02-14T12:08:29.849Z","uuid":"46d6ba38-9409-42fe-a9f5-72873f6a3bfa"}
{"parentUuid":"46d6ba38-9409-42fe-a9f5-72873f6a3bfa","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01CuLiejkE8d2AaVvGo2VTf6","toolUseID":"toolu_01CuLiejkE8d2AaVvGo2VTf6","timestamp":"2026-02-14T12:08:29.849Z","uuid":"66f4781f-d768-45c4-979b-a2958d5e6e80"}
{"parentUuid":"dec28535-98b7-43b7-82f2-0bad3424cb39","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CuLiejkE8d2AaVvGo2VTf6","type":"tool_result","content":"   890→\n   891→User gets 2 PRs to compare side-by-side.\n   892→\n   893→---\n   894→\n   895→## Files\n   896→\n   897→| File | Change |\n   898→|------|--------|\n   899→| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n   900→| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n   901→| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n   902→| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n   903→| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n   904→| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n   905→| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n   906→| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n   907→| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n   908→| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n   909→"}]},"uuid":"caedb3ff-41c5-40d4-9eed-c50caf7ccec6","timestamp":"2026-02-14T12:08:29.848Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n","numLines":20,"startLine":890,"totalLines":1076}},"sourceToolAssistantUUID":"dec28535-98b7-43b7-82f2-0bad3424cb39"}
{"parentUuid":"caedb3ff-41c5-40d4-9eed-c50caf7ccec6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_019VS8Ebmw7ikvhLg6DneATr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011Xvvtj6UkdjqJSDdjYfzZo","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |","new_string":"| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":697,"cache_read_input_tokens":67143,"output_tokens":387,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":697},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7wCVP1QEPCsqwEa1NTT","type":"assistant","uuid":"3bc0760b-f446-42d2-89a1-047a4b25d1d7","timestamp":"2026-02-14T12:08:34.809Z"}
{"parentUuid":"3bc0760b-f446-42d2-89a1-047a4b25d1d7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_011Xvvtj6UkdjqJSDdjYfzZo","parentToolUseID":"toolu_011Xvvtj6UkdjqJSDdjYfzZo","uuid":"c8f07c98-f8f7-4302-acd5-4096fde9e441","timestamp":"2026-02-14T12:08:34.813Z"}
{"parentUuid":"c8f07c98-f8f7-4302-acd5-4096fde9e441","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_011Xvvtj6UkdjqJSDdjYfzZo","toolUseID":"toolu_011Xvvtj6UkdjqJSDdjYfzZo","timestamp":"2026-02-14T12:08:34.863Z","uuid":"97029a06-6c6c-42f4-8413-e067c93cedc5"}
{"parentUuid":"97029a06-6c6c-42f4-8413-e067c93cedc5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_011Xvvtj6UkdjqJSDdjYfzZo","toolUseID":"toolu_011Xvvtj6UkdjqJSDdjYfzZo","timestamp":"2026-02-14T12:08:34.863Z","uuid":"07e8250e-b306-483e-b2bf-dac614044976"}
{"parentUuid":"3bc0760b-f446-42d2-89a1-047a4b25d1d7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011Xvvtj6UkdjqJSDdjYfzZo","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"8caed4f0-0abb-4186-8573-8be9058d93d4","timestamp":"2026-02-14T12:08:34.862Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |","newString":"| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test and merge metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Merge (terminal only)\n- Strategy: PR (or direct merge)\n- Status: pr_created\n- PR: https://github.com/user/repo/pull/43\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":899,"oldLines":7,"newStart":899,"newLines":7,"lines":[" | `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |"," | `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |"," | `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |","-| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, terminal-only merge, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer, result writing with `nextStatus` parsing |","+| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |"," | `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |"," | `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |"," | `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"3bc0760b-f446-42d2-89a1-047a4b25d1d7"}
{"parentUuid":"8caed4f0-0abb-4186-8573-8be9058d93d4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_014UBjfbHG22j8cM91iLE2NT","type":"message","role":"assistant","content":[{"type":"text","text":"Also add the merge fragments to the Files table since they're now actively used (not just sitting in the directory)."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":432,"cache_read_input_tokens":67840,"cache_creation":{"ephemeral_5m_input_tokens":432,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wCrvJaUayhjzrwbcJ2","type":"assistant","uuid":"156cca39-3ac4-478f-a838-abe91cac9c7e","timestamp":"2026-02-14T12:08:38.718Z"}
{"parentUuid":"156cca39-3ac4-478f-a838-abe91cac9c7e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_014UBjfbHG22j8cM91iLE2NT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012adWEh9DqS1yRcGF1BLqWV","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |","new_string":"| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":432,"cache_read_input_tokens":67840,"output_tokens":368,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":432},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7wCrvJaUayhjzrwbcJ2","type":"assistant","uuid":"977a16f7-2437-449f-be21-df809db7ac05","timestamp":"2026-02-14T12:08:43.397Z"}
{"parentUuid":"977a16f7-2437-449f-be21-df809db7ac05","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_012adWEh9DqS1yRcGF1BLqWV","parentToolUseID":"toolu_012adWEh9DqS1yRcGF1BLqWV","uuid":"eeaa6716-f397-4877-bb14-3a73ff6dfb12","timestamp":"2026-02-14T12:08:43.399Z"}
{"parentUuid":"eeaa6716-f397-4877-bb14-3a73ff6dfb12","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_012adWEh9DqS1yRcGF1BLqWV","toolUseID":"toolu_012adWEh9DqS1yRcGF1BLqWV","timestamp":"2026-02-14T12:08:43.462Z","uuid":"68dd9c43-c4ff-456e-9470-638db97b53e3"}
{"parentUuid":"68dd9c43-c4ff-456e-9470-638db97b53e3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_012adWEh9DqS1yRcGF1BLqWV","toolUseID":"toolu_012adWEh9DqS1yRcGF1BLqWV","timestamp":"2026-02-14T12:08:43.462Z","uuid":"5494db41-c369-4385-96d1-fbe9e25a9101"}
{"parentUuid":"977a16f7-2437-449f-be21-df809db7ac05","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012adWEh9DqS1yRcGF1BLqWV","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"1b1d9a3d-3f6f-4e30-877e-11635dd3dd31","timestamp":"2026-02-14T12:08:43.461Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |","newString":"| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test and merge metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Merge (terminal only)\n- Strategy: PR (or direct merge)\n- Status: pr_created\n- PR: https://github.com/user/repo/pull/43\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":906,"oldLines":6,"newStart":906,"newLines":9,"lines":[" | `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |"," | `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |"," | `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |","+| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |","+| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |","+| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |"," "," ---"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"977a16f7-2437-449f-be21-df809db7ac05"}
{"parentUuid":"1b1d9a3d-3f6f-4e30-877e-11635dd3dd31","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01DBCgkrWpvYxqy5m7mVaLwR","type":"message","role":"assistant","content":[{"type":"text","text":"Issue #5 fixed — `tryMerge()` replaced with merge agent that runs in the worker sandbox using `merge-auto.md`. Moving on.\n\n---\n\n**Issue #6: Prompt template interpolation**\n\nThe worker and test-writer prompts use template variables like `{ticket title + description}`, `{git diff main...HEAD}`, `{true/false}`, but there's no description of how these get interpolated. `buildTestWriterPrompt()` and `buildMergePrompt()` are referenced but the general prompt loading mechanism isn't described. Horizon has `src/lib/prompts.ts` for this."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":524,"cache_read_input_tokens":68272,"cache_creation":{"ephemeral_5m_input_tokens":524,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wDVbBjQmAXHNPTZLZo","type":"assistant","uuid":"de1613b1-b0a4-4e82-b2e8-7f0da9eead58","timestamp":"2026-02-14T12:08:51.071Z"}
{"parentUuid":"de1613b1-b0a4-4e82-b2e8-7f0da9eead58","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01DBCgkrWpvYxqy5m7mVaLwR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MBgzUuc6DJmNximsgr9o98","name":"AskUserQuestion","input":{"questions":[{"question":"How should prompt templates be loaded and interpolated? The plan references buildTestWriterPrompt(), buildMergePrompt() etc. but doesn't describe the mechanism.","header":"Prompt loading","options":[{"label":"Simple string interpolation","description":"A loadPrompt(name) function reads the .md file, then a fillTemplate(prompt, vars) does basic {{variable}} replacement. No Mustache/Handlebars — just string.replace()."},{"label":"Prompt builder per agent type","description":"Each build*Prompt() method constructs the full prompt programmatically in TypeScript by concatenating the loaded .md template with dynamically built context sections. No template engine."},{"label":"Don't specify in plan","description":"Leave this as an implementation detail. The plan already names the methods — the loader pattern will be clear during implementation."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":524,"cache_read_input_tokens":68272,"output_tokens":418,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":524},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7wDVbBjQmAXHNPTZLZo","type":"assistant","uuid":"9a39ac27-12d3-4555-adc6-7d42f0f4e595","timestamp":"2026-02-14T12:08:56.449Z"}
{"parentUuid":"9a39ac27-12d3-4555-adc6-7d42f0f4e595","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01MBgzUuc6DJmNximsgr9o98","parentToolUseID":"toolu_01MBgzUuc6DJmNximsgr9o98","uuid":"05c03c20-72d0-4edc-8615-a09a327bc8ce","timestamp":"2026-02-14T12:08:56.452Z"}
{"parentUuid":"05c03c20-72d0-4edc-8615-a09a327bc8ce","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01MBgzUuc6DJmNximsgr9o98","toolUseID":"toolu_01MBgzUuc6DJmNximsgr9o98","timestamp":"2026-02-14T12:09:18.691Z","uuid":"0b3cb3e3-2579-43c3-86c4-38e59d136072"}
{"parentUuid":"9a39ac27-12d3-4555-adc6-7d42f0f4e595","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"How should prompt templates be loaded and interpolated? The plan references buildTestWriterPrompt(), buildMergePrompt() etc. but doesn't describe the mechanism.\"=\"Simple string interpolation\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01MBgzUuc6DJmNximsgr9o98"}]},"uuid":"190e7c09-4dfb-4a18-8226-7a35a7855d50","timestamp":"2026-02-14T12:09:18.688Z","toolUseResult":{"questions":[{"question":"How should prompt templates be loaded and interpolated? The plan references buildTestWriterPrompt(), buildMergePrompt() etc. but doesn't describe the mechanism.","header":"Prompt loading","options":[{"label":"Simple string interpolation","description":"A loadPrompt(name) function reads the .md file, then a fillTemplate(prompt, vars) does basic {{variable}} replacement. No Mustache/Handlebars — just string.replace()."},{"label":"Prompt builder per agent type","description":"Each build*Prompt() method constructs the full prompt programmatically in TypeScript by concatenating the loaded .md template with dynamically built context sections. No template engine."},{"label":"Don't specify in plan","description":"Leave this as an implementation detail. The plan already names the methods — the loader pattern will be clear during implementation."}],"multiSelect":false}],"answers":{"How should prompt templates be loaded and interpolated? The plan references buildTestWriterPrompt(), buildMergePrompt() etc. but doesn't describe the mechanism.":"Simple string interpolation"}},"sourceToolAssistantUUID":"9a39ac27-12d3-4555-adc6-7d42f0f4e595"}
{"parentUuid":"190e7c09-4dfb-4a18-8226-7a35a7855d50","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01GemMih8DSmDXjTzEYW8vHe","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GjFANjxNN8SBN8pDRWgubg","name":"Read","input":{"file_path":"REDACTED.md","offset":893,"limit":5},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":490,"cache_read_input_tokens":68796,"output_tokens":113,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":490},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7wG6JJ8GgdwsP7Fk1ut","type":"assistant","uuid":"ad2e22f8-60ff-4047-8e99-4a7640d0298c","timestamp":"2026-02-14T12:09:21.588Z"}
{"parentUuid":"ad2e22f8-60ff-4047-8e99-4a7640d0298c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01GjFANjxNN8SBN8pDRWgubg","parentToolUseID":"toolu_01GjFANjxNN8SBN8pDRWgubg","uuid":"a221f36f-75a1-4791-a0c1-17ace278466c","timestamp":"2026-02-14T12:09:21.593Z"}
{"parentUuid":"a221f36f-75a1-4791-a0c1-17ace278466c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01GjFANjxNN8SBN8pDRWgubg","toolUseID":"toolu_01GjFANjxNN8SBN8pDRWgubg","timestamp":"2026-02-14T12:09:21.669Z","uuid":"e7547455-9167-46ab-a73e-e4534d059d5f"}
{"parentUuid":"e7547455-9167-46ab-a73e-e4534d059d5f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01GjFANjxNN8SBN8pDRWgubg","toolUseID":"toolu_01GjFANjxNN8SBN8pDRWgubg","timestamp":"2026-02-14T12:09:21.669Z","uuid":"65ce0aa6-6886-49da-b2e8-b52fc460c30a"}
{"parentUuid":"ad2e22f8-60ff-4047-8e99-4a7640d0298c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GjFANjxNN8SBN8pDRWgubg","type":"tool_result","content":"   893→---\n   894→\n   895→## Files\n   896→\n   897→| File | Change |"}]},"uuid":"5cef1f1a-c306-4d24-871a-eb2d961faa56","timestamp":"2026-02-14T12:09:21.668Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"---\n\n## Files\n\n| File | Change |","numLines":5,"startLine":893,"totalLines":1079}},"sourceToolAssistantUUID":"ad2e22f8-60ff-4047-8e99-4a7640d0298c"}
{"parentUuid":"5cef1f1a-c306-4d24-871a-eb2d961faa56","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01QHpH28VfACBP8RP5RTj8So","type":"message","role":"assistant","content":[{"type":"text","text":"I'll add a brief section on prompt loading before the Files table."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":152,"cache_read_input_tokens":69286,"cache_creation":{"ephemeral_5m_input_tokens":152,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wGJynttb4cxhYNB3QL","type":"assistant","uuid":"18621a03-d216-4899-8550-512529d12e09","timestamp":"2026-02-14T12:09:24.454Z"}
{"parentUuid":"18621a03-d216-4899-8550-512529d12e09","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01QHpH28VfACBP8RP5RTj8So","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MVd8hmxymow8uk27DPgYDY","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"---\n\n## Files\n\n| File | Change |","new_string":"---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n\n---\n\n## Files\n\n| File | Change |"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":152,"cache_read_input_tokens":69286,"output_tokens":523,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":152},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7wGJynttb4cxhYNB3QL","type":"assistant","uuid":"ea4380dd-c30b-439d-b6c7-e1ac36842e18","timestamp":"2026-02-14T12:09:32.242Z"}
{"parentUuid":"ea4380dd-c30b-439d-b6c7-e1ac36842e18","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01MVd8hmxymow8uk27DPgYDY","parentToolUseID":"toolu_01MVd8hmxymow8uk27DPgYDY","uuid":"3ba696c8-3e46-4eb8-b484-12132fc7288a","timestamp":"2026-02-14T12:09:32.245Z"}
{"parentUuid":"3ba696c8-3e46-4eb8-b484-12132fc7288a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01MVd8hmxymow8uk27DPgYDY","toolUseID":"toolu_01MVd8hmxymow8uk27DPgYDY","timestamp":"2026-02-14T12:09:32.302Z","uuid":"43afe4a9-73b6-42fb-bbd9-f0b8bb283184"}
{"parentUuid":"43afe4a9-73b6-42fb-bbd9-f0b8bb283184","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01MVd8hmxymow8uk27DPgYDY","toolUseID":"toolu_01MVd8hmxymow8uk27DPgYDY","timestamp":"2026-02-14T12:09:32.302Z","uuid":"5be979ab-ee43-4b4c-b107-c2ca641e37ae"}
{"parentUuid":"ea4380dd-c30b-439d-b6c7-e1ac36842e18","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MVd8hmxymow8uk27DPgYDY","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"d3157aea-78b2-48b0-97b2-1c08b8bae18e","timestamp":"2026-02-14T12:09:32.301Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"---\n\n## Files\n\n| File | Change |","newString":"---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n\n---\n\n## Files\n\n| File | Change |","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test and merge metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Merge (terminal only)\n- Strategy: PR (or direct merge)\n- Status: pr_created\n- PR: https://github.com/user/repo/pull/43\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":892,"oldLines":6,"newStart":892,"newLines":39,"lines":[" "," ---"," ","+## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)","+","+A simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:","+","+```typescript","+function loadPrompt(name: string): string {","+  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");","+}","+","+function fillTemplate(template: string, vars: Record<string, string>): string {","+  return Object.entries(vars).reduce(","+    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template","+  );","+}","+```","+","+Each `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:","+","+```typescript","+// Example: buildTestWriterPrompt","+const template = loadPrompt(\"agent2-worker-test.md\");","+return fillTemplate(template, {","+  TICKET_CONTEXT: `${task.title}\\n${task.description}`,","+  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),","+  IS_TERMINAL: String(isTerminal),","+  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",","+});","+```","+","+For the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.","+","+---","+"," ## Files"," "," | File | Change |"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"ea4380dd-c30b-439d-b6c7-e1ac36842e18"}
{"parentUuid":"d3157aea-78b2-48b0-97b2-1c08b8bae18e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_014JQecT7aS1BV7pQkvyqF9g","type":"message","role":"assistant","content":[{"type":"text","text":"Now add `PromptLoader.ts` to the Files table."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":568,"cache_read_input_tokens":69438,"cache_creation":{"ephemeral_5m_input_tokens":568,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wH6Q2pKLbKQT6gzBhC","type":"assistant","uuid":"5782a88a-71c6-46c9-8855-3f0c8b1d731b","timestamp":"2026-02-14T12:09:35.411Z"}
{"parentUuid":"5782a88a-71c6-46c9-8855-3f0c8b1d731b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_014JQecT7aS1BV7pQkvyqF9g","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ATgK5HjqrPCnnyW52ebfhy","name":"Read","input":{"file_path":"REDACTED.md","offset":929,"limit":5},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":568,"cache_read_input_tokens":69438,"cache_creation":{"ephemeral_5m_input_tokens":568,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wH6Q2pKLbKQT6gzBhC","type":"assistant","uuid":"90e0a6bb-b25d-4042-8688-546b5b742679","timestamp":"2026-02-14T12:09:36.108Z"}
{"parentUuid":"90e0a6bb-b25d-4042-8688-546b5b742679","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01ATgK5HjqrPCnnyW52ebfhy","parentToolUseID":"toolu_01ATgK5HjqrPCnnyW52ebfhy","uuid":"6763000d-f605-4af7-8bb7-61bb4f6833ff","timestamp":"2026-02-14T12:09:36.114Z"}
{"parentUuid":"6763000d-f605-4af7-8bb7-61bb4f6833ff","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01ATgK5HjqrPCnnyW52ebfhy","toolUseID":"toolu_01ATgK5HjqrPCnnyW52ebfhy","timestamp":"2026-02-14T12:09:36.168Z","uuid":"fe686e10-3779-4bb2-bf58-235ef0996b0b"}
{"parentUuid":"fe686e10-3779-4bb2-bf58-235ef0996b0b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01ATgK5HjqrPCnnyW52ebfhy","toolUseID":"toolu_01ATgK5HjqrPCnnyW52ebfhy","timestamp":"2026-02-14T12:09:36.168Z","uuid":"2df105f3-fadb-4d50-a594-5d9c9ac1620d"}
{"parentUuid":"90e0a6bb-b25d-4042-8688-546b5b742679","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ATgK5HjqrPCnnyW52ebfhy","type":"tool_result","content":"   929→\n   930→| File | Change |\n   931→|------|--------|\n   932→| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n   933→| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |"}]},"uuid":"88e98fd3-c315-4ba1-9508-72b528999b14","timestamp":"2026-02-14T12:09:36.166Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |","numLines":5,"startLine":929,"totalLines":1112}},"sourceToolAssistantUUID":"90e0a6bb-b25d-4042-8688-546b5b742679"}
{"parentUuid":"88e98fd3-c315-4ba1-9508-72b528999b14","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01UnKacHYPytEdCrGZ4D3u9e","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MwXBmp8Rz6hQd8d5wihPH1","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |","new_string":"| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":248,"cache_read_input_tokens":70006,"output_tokens":337,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":248},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7wHNui4X9tBEVATj87p","type":"assistant","uuid":"02be345a-df47-4f03-b832-c5734a463831","timestamp":"2026-02-14T12:09:40.970Z"}
{"parentUuid":"02be345a-df47-4f03-b832-c5734a463831","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01MwXBmp8Rz6hQd8d5wihPH1","parentToolUseID":"toolu_01MwXBmp8Rz6hQd8d5wihPH1","uuid":"0297d1b1-3bcc-4496-a9b8-87b200f0d561","timestamp":"2026-02-14T12:09:40.973Z"}
{"parentUuid":"0297d1b1-3bcc-4496-a9b8-87b200f0d561","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01MwXBmp8Rz6hQd8d5wihPH1","toolUseID":"toolu_01MwXBmp8Rz6hQd8d5wihPH1","timestamp":"2026-02-14T12:09:41.023Z","uuid":"1a94ca8a-cd1a-4455-897e-0bb03709aaf3"}
{"parentUuid":"1a94ca8a-cd1a-4455-897e-0bb03709aaf3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01MwXBmp8Rz6hQd8d5wihPH1","toolUseID":"toolu_01MwXBmp8Rz6hQd8d5wihPH1","timestamp":"2026-02-14T12:09:41.023Z","uuid":"5f8e23cc-97e8-4b9d-b129-737ac6cd92ad"}
{"parentUuid":"02be345a-df47-4f03-b832-c5734a463831","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MwXBmp8Rz6hQd8d5wihPH1","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"4fa5db48-ea7e-488e-85e7-ff3f439f5412","timestamp":"2026-02-14T12:09:41.022Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |","newString":"| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test and merge metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Merge (terminal only)\n- Strategy: PR (or direct merge)\n- Status: pr_created\n- PR: https://github.com/user/repo/pull/43\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":930,"oldLines":6,"newStart":930,"newLines":7,"lines":[" | File | Change |"," |------|--------|"," | `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |","+| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |"," | `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |"," | `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |"," | `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"02be345a-df47-4f03-b832-c5734a463831"}
{"parentUuid":"4fa5db48-ea7e-488e-85e7-ff3f439f5412","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01Gm2WptC1pSMHpDnXkCfkfd","type":"message","role":"assistant","content":[{"type":"text","text":"Issue #6 fixed. Moving on.\n\n---\n\n**Issue #7: Sandbox lifecycle — who sets up the clone and branch checkout?**\n\nFor grouped non-first tickets, the plan says \"the sandbox clones the repo, then checks out the existing group branch.\" But it's unclear whether the orchestrator handles this setup or the worker prompt instructs Claude to do it."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":382,"cache_read_input_tokens":70254,"cache_creation":{"ephemeral_5m_input_tokens":382,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wHjirPJMV6ZeJCpYrX","type":"assistant","uuid":"2549b87b-5c11-487a-bc6f-9322d4965a99","timestamp":"2026-02-14T12:09:45.452Z"}
{"parentUuid":"2549b87b-5c11-487a-bc6f-9322d4965a99","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01Gm2WptC1pSMHpDnXkCfkfd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016imwrZzB9kseG6prB6jdmM","name":"AskUserQuestion","input":{"questions":[{"question":"Who sets up the repo clone and branch checkout inside the sandbox?","header":"Sandbox setup","options":[{"label":"Orchestrator (programmatic)","description":"The orchestrator uses the Daytona SDK to clone the repo and checkout the branch before the worker agent starts. The worker sees a ready-to-go working directory."},{"label":"Worker prompt (Claude does it)","description":"The worker prompt instructs Claude to clone the repo and checkout/create the branch as its first step. More flexible but less deterministic."},{"label":"Daytona workspace config","description":"The Daytona workspace is created with a repo URL and branch — it auto-clones on creation. The orchestrator just passes the right config."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":382,"cache_read_input_tokens":70254,"output_tokens":321,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":382},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7wHjirPJMV6ZeJCpYrX","type":"assistant","uuid":"cad8e826-a455-4bb2-997e-da271ac55c6e","timestamp":"2026-02-14T12:10:07.179Z"}
{"parentUuid":"cad8e826-a455-4bb2-997e-da271ac55c6e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_016imwrZzB9kseG6prB6jdmM","parentToolUseID":"toolu_016imwrZzB9kseG6prB6jdmM","uuid":"4e36aa03-4a8a-4a68-b26b-f6de31582ed3","timestamp":"2026-02-14T12:10:07.186Z"}
{"parentUuid":"4e36aa03-4a8a-4a68-b26b-f6de31582ed3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_016imwrZzB9kseG6prB6jdmM","toolUseID":"toolu_016imwrZzB9kseG6prB6jdmM","timestamp":"2026-02-14T12:10:37.667Z","uuid":"bf6258ac-a61f-4517-bb33-0acd5bdbbf76"}
{"parentUuid":"cad8e826-a455-4bb2-997e-da271ac55c6e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Who sets up the repo clone and branch checkout inside the sandbox?\"=\"Orchestrator (programmatic)\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_016imwrZzB9kseG6prB6jdmM"}]},"uuid":"1ba0041e-a731-42dd-bb0f-d5389ec2f777","timestamp":"2026-02-14T12:10:37.664Z","toolUseResult":{"questions":[{"question":"Who sets up the repo clone and branch checkout inside the sandbox?","header":"Sandbox setup","options":[{"label":"Orchestrator (programmatic)","description":"The orchestrator uses the Daytona SDK to clone the repo and checkout the branch before the worker agent starts. The worker sees a ready-to-go working directory."},{"label":"Worker prompt (Claude does it)","description":"The worker prompt instructs Claude to clone the repo and checkout/create the branch as its first step. More flexible but less deterministic."},{"label":"Daytona workspace config","description":"The Daytona workspace is created with a repo URL and branch — it auto-clones on creation. The orchestrator just passes the right config."}],"multiSelect":false}],"answers":{"Who sets up the repo clone and branch checkout inside the sandbox?":"Orchestrator (programmatic)"}},"sourceToolAssistantUUID":"cad8e826-a455-4bb2-997e-da271ac55c6e"}
{"parentUuid":"1ba0041e-a731-42dd-bb0f-d5389ec2f777","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01BkEuUmycuimrWkY8pjtxLo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CijeeAN9gXEqeXJQr4ggi9","name":"Read","input":{"file_path":"REDACTED.md","offset":536,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":484,"cache_read_input_tokens":70636,"output_tokens":113,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":484},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7wMuvsn3UEy7VAdeSsJ","type":"assistant","uuid":"e7a260ca-3b11-419c-8f11-3fce8b1cbadc","timestamp":"2026-02-14T12:10:40.642Z"}
{"parentUuid":"e7a260ca-3b11-419c-8f11-3fce8b1cbadc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01CijeeAN9gXEqeXJQr4ggi9","parentToolUseID":"toolu_01CijeeAN9gXEqeXJQr4ggi9","uuid":"b2f7d1d0-2e5b-4758-8a7b-181f6e62882c","timestamp":"2026-02-14T12:10:40.646Z"}
{"parentUuid":"b2f7d1d0-2e5b-4758-8a7b-181f6e62882c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01CijeeAN9gXEqeXJQr4ggi9","toolUseID":"toolu_01CijeeAN9gXEqeXJQr4ggi9","timestamp":"2026-02-14T12:10:40.729Z","uuid":"f44d418b-206a-4ed8-acd0-909e9b5766f4"}
{"parentUuid":"f44d418b-206a-4ed8-acd0-909e9b5766f4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01CijeeAN9gXEqeXJQr4ggi9","toolUseID":"toolu_01CijeeAN9gXEqeXJQr4ggi9","timestamp":"2026-02-14T12:10:40.729Z","uuid":"2a85cb58-b40b-45e7-b858-cf44203a3a6f"}
{"parentUuid":"e7a260ca-3b11-419c-8f11-3fce8b1cbadc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CijeeAN9gXEqeXJQr4ggi9","type":"tool_result","content":"   536→Key behaviors:\n   537→1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n   538→2. **Branch name** passed to worker prompt uses `branchName(task)`\n   539→3. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n   540→4. **`variant_hint`** included in worker prompt when present\n   541→5. Returns parsed WORK_RESULT including `nextStatus` field\n   542→6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n   543→7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n   544→8. **Post-stage subagents** (same sandbox, before teardown):\n   545→   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   546→   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n   547→\n   548→### `writeResults(task, result)` — Update MD File\n   549→\n   550→Parses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`."}]},"uuid":"f43eea67-22e6-4e02-b70b-42691b6fa3fe","timestamp":"2026-02-14T12:10:40.728Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"Key behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.","numLines":15,"startLine":536,"totalLines":1113}},"sourceToolAssistantUUID":"e7a260ca-3b11-419c-8f11-3fce8b1cbadc"}
{"parentUuid":"f43eea67-22e6-4e02-b70b-42691b6fa3fe","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01PFSvr7XMzQ4KovTPyFuabF","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CaX1eKNLnFVQU2NVEKiPqL","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"3. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)","new_string":"3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":558,"cache_read_input_tokens":71120,"cache_creation":{"ephemeral_5m_input_tokens":558,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wN8xDAiXoKQCvRk2MX","type":"assistant","uuid":"7f4772c1-f481-493e-97e3-6b92745e6fe2","timestamp":"2026-02-14T12:10:48.052Z"}
{"parentUuid":"7f4772c1-f481-493e-97e3-6b92745e6fe2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01CaX1eKNLnFVQU2NVEKiPqL","parentToolUseID":"toolu_01CaX1eKNLnFVQU2NVEKiPqL","uuid":"c9db811d-3470-40f2-af60-900a7973bfcf","timestamp":"2026-02-14T12:10:48.055Z"}
{"parentUuid":"c9db811d-3470-40f2-af60-900a7973bfcf","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01CaX1eKNLnFVQU2NVEKiPqL","toolUseID":"toolu_01CaX1eKNLnFVQU2NVEKiPqL","timestamp":"2026-02-14T12:10:48.106Z","uuid":"2cabe66b-5618-4b03-b1a5-825b816aba5d"}
{"parentUuid":"2cabe66b-5618-4b03-b1a5-825b816aba5d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01CaX1eKNLnFVQU2NVEKiPqL","toolUseID":"toolu_01CaX1eKNLnFVQU2NVEKiPqL","timestamp":"2026-02-14T12:10:48.106Z","uuid":"f352f9c0-0283-46a1-aa0d-44858d251ffa"}
{"parentUuid":"7f4772c1-f481-493e-97e3-6b92745e6fe2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CaX1eKNLnFVQU2NVEKiPqL","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"71f93cba-c105-4fa9-b2f4-94eb26ae60ae","timestamp":"2026-02-14T12:10:48.104Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"3. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)","newString":"3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test and merge metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Merge (terminal only)\n- Strategy: PR (or direct merge)\n- Status: pr_created\n- PR: https://github.com/user/repo/pull/43\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":536,"oldLines":7,"newStart":536,"newLines":11,"lines":[" Key behaviors:"," 1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`"," 2. **Branch name** passed to worker prompt uses `branchName(task)`","-3. **For grouped non-first tickets**: The sandbox clones the repo, then checks out the existing group branch (which has prior chain commits from upstream dependencies)","+3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):","+   - `createSandbox(task)` clones the repo via Daytona SDK","+   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch","+   - Runs `gh auth setup-git` for push access","+   - Worker sees a ready-to-go working directory on the correct branch"," 4. **`variant_hint`** included in worker prompt when present"," 5. Returns parsed WORK_RESULT including `nextStatus` field"," 6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"7f4772c1-f481-493e-97e3-6b92745e6fe2"}
{"parentUuid":"71f93cba-c105-4fa9-b2f4-94eb26ae60ae","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_011vCUkYefwxdwcgZJf2hv7e","type":"message","role":"assistant","content":[{"type":"text","text":"Issue #7 fixed. Moving on.\n\n---\n\n**Issue #8: Phase 5 separated from other phases & duplicate `dispatchStage()`**\n\nPhase 5 (Test-Writer) appears ~200 lines after Phase 4, separated by the Variant Example. It also provides a second version of `dispatchStage()` that supersedes Phase 3's version. Now that I've already synced both versions (adding merge agent to both), should we consolidate?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":320,"cache_read_input_tokens":71678,"cache_creation":{"ephemeral_5m_input_tokens":320,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wNgUmxCnA4piXJLpZP","type":"assistant","uuid":"5ca73889-267c-4fad-89af-5d1c16c739de","timestamp":"2026-02-14T12:10:53.523Z"}
{"parentUuid":"5ca73889-267c-4fad-89af-5d1c16c739de","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_011vCUkYefwxdwcgZJf2hv7e","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JnbgDT6kAokE7SPoifpfNV","name":"AskUserQuestion","input":{"questions":[{"question":"Phase 5 (Test-Writer) is separated from Phases 1-4 by the Variant Example and has a duplicate dispatchStage(). Should I restructure the document?","header":"Doc structure","options":[{"label":"Move Phase 5 after Phase 4 (Recommended)","description":"Reorder so all 5 phases are contiguous. Move Variant Example and Changes table to after Phase 5. Remove the duplicate dispatchStage() from Phase 5 since Phase 3 now has the complete version."},{"label":"Keep current order","description":"The current layout is fine. Phase 5 being at the end emphasizes it was added later. The duplicate dispatchStage() serves as a focused reference for Phase 5 implementers."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":320,"cache_read_input_tokens":71678,"cache_creation":{"ephemeral_5m_input_tokens":320,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wNgUmxCnA4piXJLpZP","type":"assistant","uuid":"bc36fcd4-c28d-4b61-ab33-9058e516fdac","timestamp":"2026-02-14T12:10:57.764Z"}
{"parentUuid":"bc36fcd4-c28d-4b61-ab33-9058e516fdac","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01JnbgDT6kAokE7SPoifpfNV","parentToolUseID":"toolu_01JnbgDT6kAokE7SPoifpfNV","uuid":"4e7bc4cf-dd73-4661-b683-3bc7f9e5a298","timestamp":"2026-02-14T12:10:57.767Z"}
{"parentUuid":"4e7bc4cf-dd73-4661-b683-3bc7f9e5a298","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01JnbgDT6kAokE7SPoifpfNV","toolUseID":"toolu_01JnbgDT6kAokE7SPoifpfNV","timestamp":"2026-02-14T12:12:54.849Z","uuid":"8de6ee05-e82e-4c16-bd2f-ad8f984dd05d"}
{"parentUuid":"bc36fcd4-c28d-4b61-ab33-9058e516fdac","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Phase 5 (Test-Writer) is separated from Phases 1-4 by the Variant Example and has a duplicate dispatchStage(). Should I restructure the document?\"=\"Move Phase 5 after Phase 4 (Recommended)\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01JnbgDT6kAokE7SPoifpfNV"}]},"uuid":"12ed3f29-5570-4b1d-95aa-ee5d24d2a2d5","timestamp":"2026-02-14T12:12:54.845Z","toolUseResult":{"questions":[{"question":"Phase 5 (Test-Writer) is separated from Phases 1-4 by the Variant Example and has a duplicate dispatchStage(). Should I restructure the document?","header":"Doc structure","options":[{"label":"Move Phase 5 after Phase 4 (Recommended)","description":"Reorder so all 5 phases are contiguous. Move Variant Example and Changes table to after Phase 5. Remove the duplicate dispatchStage() from Phase 5 since Phase 3 now has the complete version."},{"label":"Keep current order","description":"The current layout is fine. Phase 5 being at the end emphasizes it was added later. The duplicate dispatchStage() serves as a focused reference for Phase 5 implementers."}],"multiSelect":false}],"answers":{"Phase 5 (Test-Writer) is separated from Phases 1-4 by the Variant Example and has a duplicate dispatchStage(). Should I restructure the document?":"Move Phase 5 after Phase 4 (Recommended)"}},"sourceToolAssistantUUID":"bc36fcd4-c28d-4b61-ab33-9058e516fdac"}
{"parentUuid":"12ed3f29-5570-4b1d-95aa-ee5d24d2a2d5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_015HjGtky4AeWBtSKVo1GxRB","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"I need to:\n1. Move Phase 5 (Test-Writer) section to after Phase 4 (Entry Point)\n2. Remove the duplicate `dispatchStage()` from Phase 5 since Phase 3 already has the complete version\n3. Keep the rest of Phase 5 (purpose, two-tier testing strategy, prompt, execution flow, writeResults update, files update)\n\nLet me read the full Phase 5 section and the surrounding context to plan the move.","signature":"EqwECkYICxgCKkAqYx6ZV37HVw8uoP9xpA11hHXTDpZFysz+xSzBN3iGaouKeXwpa3a9JHJUJI0wZlr3goOJ6xhNKRjVGm5rkAZ2EgynU6J6XzehMeJ1Dt4aDC7OlafrLfSNEXpbSSIwFMqBbeA+t5JH9g6jNpGSI0rqcRY8K3UdfaJbEsgrwe6uTebCOhwTrJphvxKU2ZruKpMDWk89McZeBbEPI6Li8Aqkvy4QQr35kaZNlDKbEv89doa2keHX9CdLLrTeJxOgsUPJZh4XLvzsMH1+6d1BgHezkjQ+ET5Z7AlRnWSqw14Aef62pOXBYtZ1+VEC+4QuUhep++M8qpo+C/rlgI5OoX00Oa0RTfXYfhG0gRAlWfIw1KsmKzO36Uxgz6ybyQTBgm+uG5HNp+vjaIMZokbwMHyP0XBYTIlhs0mkD2BEnmF2Wcxlkx+mxmH0j4ItPSRDfsSmivxTX+pED7Hq4HTjjh0n8qQSUzogcMErFilpJ4WbSse4ffxEKGtnLsf8zqWRRKcees6GmjbtfmCUgx9xcZJfvBUwthaubDcZ+nZ+I0HsPIGWfQaO472tcRcVWbOHABiu2F5WvvtTQyVdsrqQtan8nJj2QtB/AIil8yRrYbYTcnm5eOpCWju9Y34vJgk/JmSC+8dV6J8wg12tN/0YLUgHYyvxU3HLvYeCds8NVSEAp0TOn7ea8cuw2QbS3pbaJMkmHVozJjeK7IVXVYIQWAjEqr2nQxgB"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":440,"cache_read_input_tokens":71998,"cache_creation":{"ephemeral_5m_input_tokens":440,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wY2XHd1oEkMhceEPSM","type":"assistant","uuid":"ce1370c8-90e8-4779-b356-3e0600fe7880","timestamp":"2026-02-14T12:12:59.104Z"}
{"parentUuid":"ce1370c8-90e8-4779-b356-3e0600fe7880","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_015HjGtky4AeWBtSKVo1GxRB","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the sections I need to move around."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":440,"cache_read_input_tokens":71998,"cache_creation":{"ephemeral_5m_input_tokens":440,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wY2XHd1oEkMhceEPSM","type":"assistant","uuid":"6183ed27-a03c-439c-8e36-6a05c918a209","timestamp":"2026-02-14T12:12:59.435Z"}
{"parentUuid":"6183ed27-a03c-439c-8e36-6a05c918a209","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_015HjGtky4AeWBtSKVo1GxRB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DJSjvdHh4ULdWbZZvJgWEr","name":"Read","input":{"file_path":"REDACTED.md","offset":600,"limit":20},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":440,"cache_read_input_tokens":71998,"cache_creation":{"ephemeral_5m_input_tokens":440,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wY2XHd1oEkMhceEPSM","type":"assistant","uuid":"ee71964c-16fb-4d5c-b06c-4c46731dc24a","timestamp":"2026-02-14T12:13:00.151Z"}
{"parentUuid":"ee71964c-16fb-4d5c-b06c-4c46731dc24a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01DJSjvdHh4ULdWbZZvJgWEr","parentToolUseID":"toolu_01DJSjvdHh4ULdWbZZvJgWEr","uuid":"1cdef119-affe-45e4-8f8f-1aa210af0cf7","timestamp":"2026-02-14T12:13:00.155Z"}
{"parentUuid":"1cdef119-affe-45e4-8f8f-1aa210af0cf7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01DJSjvdHh4ULdWbZZvJgWEr","toolUseID":"toolu_01DJSjvdHh4ULdWbZZvJgWEr","timestamp":"2026-02-14T12:13:00.217Z","uuid":"0bde6661-b067-42a4-a271-0b7baf7f02ed"}
{"parentUuid":"0bde6661-b067-42a4-a271-0b7baf7f02ed","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01DJSjvdHh4ULdWbZZvJgWEr","toolUseID":"toolu_01DJSjvdHh4ULdWbZZvJgWEr","timestamp":"2026-02-14T12:13:00.217Z","uuid":"996f1250-0645-4849-b938-2ee933426a26"}
{"parentUuid":"ee71964c-16fb-4d5c-b06c-4c46731dc24a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DJSjvdHh4ULdWbZZvJgWEr","type":"tool_result","content":"   600→    await specAgent.clarify(request);\n   601→  } else {\n   602→    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n   603→    await orchestrator.processQueue();\n   604→  }\n   605→}\n   606→```\n   607→\n   608→Usage:\n   609→- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n   610→- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n   611→- `npx tsx src/index.ts` → Orchestrator loop\n   612→\n   613→---\n   614→\n   615→## `TaskRequest` Interface Update\n   616→\n   617→```typescript\n   618→interface TaskRequest {\n   619→  id: string;"}]},"uuid":"d52a5a62-ceb3-4288-b392-c4c2d4840d7d","timestamp":"2026-02-14T12:13:00.216Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;","numLines":20,"startLine":600,"totalLines":1117}},"sourceToolAssistantUUID":"ee71964c-16fb-4d5c-b06c-4c46731dc24a"}
{"parentUuid":"d52a5a62-ceb3-4288-b392-c4c2d4840d7d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_019FnuSkHaTsz2vbJvxnKe37","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015ucB8FueyLH25CVTqDqvCm","name":"Read","input":{"file_path":"REDACTED.md","offset":960,"limit":120},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":476,"cache_read_input_tokens":72438,"cache_creation":{"ephemeral_5m_input_tokens":476,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wYRNiCzcJvYTHpBNE4","type":"assistant","uuid":"33d0dda3-3097-4311-bced-82a505cf0209","timestamp":"2026-02-14T12:13:03.196Z"}
{"parentUuid":"33d0dda3-3097-4311-bced-82a505cf0209","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_015ucB8FueyLH25CVTqDqvCm","parentToolUseID":"toolu_015ucB8FueyLH25CVTqDqvCm","uuid":"486c3f3a-c566-4b49-bb8b-4f1cf3c91b82","timestamp":"2026-02-14T12:13:03.199Z"}
{"parentUuid":"486c3f3a-c566-4b49-bb8b-4f1cf3c91b82","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_015ucB8FueyLH25CVTqDqvCm","toolUseID":"toolu_015ucB8FueyLH25CVTqDqvCm","timestamp":"2026-02-14T12:13:03.259Z","uuid":"42b14a66-8d04-4586-9104-3be7cf36f220"}
{"parentUuid":"42b14a66-8d04-4586-9104-3be7cf36f220","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_015ucB8FueyLH25CVTqDqvCm","toolUseID":"toolu_015ucB8FueyLH25CVTqDqvCm","timestamp":"2026-02-14T12:13:03.259Z","uuid":"67e6c03e-649e-4b4f-a4d4-06dfe6eb026c"}
{"parentUuid":"33d0dda3-3097-4311-bced-82a505cf0209","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015ucB8FueyLH25CVTqDqvCm","type":"tool_result","content":"   960→6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n   961→7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n   962→8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   963→   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   964→   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   965→   - Non-terminal tickets push to shared branch, no PR\n   966→   - Terminal tickets create PR and attempt merge\n   967→   - Group branch accumulates commits across chain\n   968→9. **Existing tests**: `npm test` passes\n   969→\n   970→---\n   971→\n   972→## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n   973→\n   974→### Purpose\n   975→\n   976→Worker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n   977→\n   978→### Two-Tier Testing Strategy\n   979→\n   980→| Ticket type | Unit tests | Integration tests |\n   981→|-------------|-----------|-------------------|\n   982→| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n   983→| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n   984→\n   985→### Execution Flow\n   986→\n   987→The test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n   988→\n   989→```\n   990→dispatchStage(task, stagePrompt):\n   991→  1. Create Daytona sandbox\n   992→  2. Worker agent runs stage prompt, commits, pushes\n   993→  3. If stage is Implement, Oneshot, or Validate:\n   994→     a. Test-writer agent runs in same sandbox\n   995→     b. Reads the git diff (all commits on this branch vs main)\n   996→     c. Reads the ticket description + acceptance criteria\n   997→     d. If terminal: also reads all tickets in the group chain for integration context\n   998→     e. Writes test files to tests/\n   999→     f. Runs `npm test` to verify all tests pass\n  1000→     g. Commits test files, pushes to same branch\n  1001→  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n  1002→```\n  1003→\n  1004→### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n  1005→\n  1006→```\n  1007→You are a Test-Writer Agent. You have just received a completed implementation in this\n  1008→sandbox. Your job is to write tests for the code that was changed.\n  1009→\n  1010→## Context\n  1011→\n  1012→**Ticket**: {ticket title + description + acceptance criteria}\n  1013→**Branch diff vs main**: {git diff main...HEAD}\n  1014→**Is terminal ticket**: {true/false}\n  1015→{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n  1016→\n  1017→## Rules\n  1018→\n  1019→1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n  1020→2. Follow existing test patterns in the repo (see tests/ for examples).\n  1021→3. Write **unit tests** for:\n  1022→   - Every new public method on any class\n  1023→   - Non-trivial private logic (parsing, state transitions, validation)\n  1024→   - Both happy path and at least one meaningful failure case per method\n  1025→   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n  1026→4. If this is a **terminal ticket**, also write **integration tests** that:\n  1027→   - Exercise the full chain of features built across this variant group\n  1028→   - Test interactions between the new code and pre-existing repo code\n  1029→   - Cover end-to-end flows from the user's perspective where applicable\n  1030→5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n  1031→6. Run `npm test` after writing. If tests fail, fix them before committing.\n  1032→7. Commit all test files with message: \"test: add tests for {ticket title}\"\n  1033→\n  1034→## Output\n  1035→\n  1036→TEST_RESULT\n  1037→---\n  1038→files_created: [list of test file paths]\n  1039→unit_tests: {count}\n  1040→integration_tests: {count}\n  1041→all_passing: {true/false}\n  1042→---\n  1043→```\n  1044→\n  1045→### Orchestrator Integration\n  1046→\n  1047→The `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n  1048→\n  1049→```typescript\n  1050→private readonly codeProducingStages = new Set([\n  1051→  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n  1052→]);\n  1053→\n  1054→private async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  1055→  const sandbox = await this.createSandbox(task);\n  1056→  const originalStatus = task.status;  // capture before mutation\n  1057→\n  1058→  // Step 1: Transition to In Progress, then run the stage prompt\n  1059→  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  1060→  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n  1061→\n  1062→  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  1063→  let testResult: TestResult | undefined;\n  1064→  if (this.codeProducingStages.has(originalStatus)) {\n  1065→    const isTerminal = await this.isTerminal(task);\n  1066→    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n  1067→    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  1068→  }\n  1069→\n  1070→  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  1071→  let mergeResult: MergeResult | undefined;\n  1072→  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n  1073→    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n  1074→    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  1075→  }\n  1076→\n  1077→  return { stage: stageResult, tests: testResult, merge: mergeResult };\n  1078→}\n  1079→```"}]},"uuid":"76cc89a5-f457-429e-9a43-43c6e1a41fdc","timestamp":"2026-02-14T12:13:03.258Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```","numLines":120,"startLine":960,"totalLines":1117}},"sourceToolAssistantUUID":"33d0dda3-3097-4311-bced-82a505cf0209"}
{"parentUuid":"76cc89a5-f457-429e-9a43-43c6e1a41fdc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01DNUKvtkVEnF2XYCGojJBTh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018AjSzmMegvkHc83CY9D4tf","name":"Read","input":{"file_path":"REDACTED.md","offset":1079,"limit":30},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2104,"cache_read_input_tokens":72914,"output_tokens":114,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":2104},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7wYeT27DpUG7pQiVqVA","type":"assistant","uuid":"58116f34-a944-45c5-87f5-0880e055d7ef","timestamp":"2026-02-14T12:13:06.461Z"}
{"parentUuid":"58116f34-a944-45c5-87f5-0880e055d7ef","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_018AjSzmMegvkHc83CY9D4tf","parentToolUseID":"toolu_018AjSzmMegvkHc83CY9D4tf","uuid":"4cfb0131-13c6-4474-a5f3-7b644667bdfc","timestamp":"2026-02-14T12:13:06.464Z"}
{"parentUuid":"4cfb0131-13c6-4474-a5f3-7b644667bdfc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_018AjSzmMegvkHc83CY9D4tf","toolUseID":"toolu_018AjSzmMegvkHc83CY9D4tf","timestamp":"2026-02-14T12:13:06.528Z","uuid":"d1acb2f7-d171-4403-9cd2-06b6b21d185a"}
{"parentUuid":"d1acb2f7-d171-4403-9cd2-06b6b21d185a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_018AjSzmMegvkHc83CY9D4tf","toolUseID":"toolu_018AjSzmMegvkHc83CY9D4tf","timestamp":"2026-02-14T12:13:06.528Z","uuid":"44d694c0-1962-4195-bff6-4abaf0dd214a"}
{"parentUuid":"58116f34-a944-45c5-87f5-0880e055d7ef","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018AjSzmMegvkHc83CY9D4tf","type":"tool_result","content":"  1079→```\n  1080→\n  1081→### `writeResults` Update\n  1082→\n  1083→The result block now includes test and merge metadata:\n  1084→\n  1085→```markdown\n  1086→## Results\n  1087→\n  1088→**Completed**: 2026-02-14T12:00:00Z\n  1089→**Branch**: feat/dashboard-v2\n  1090→\n  1091→### Summary\n  1092→{parsed from WORK_RESULT}\n  1093→\n  1094→### Tests\n  1095→- Unit tests: 8\n  1096→- Integration tests: 3 (terminal only)\n  1097→- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n  1098→- All passing: true\n  1099→\n  1100→### Merge (terminal only)\n  1101→- Strategy: PR (or direct merge)\n  1102→- Status: pr_created\n  1103→- PR: https://github.com/user/repo/pull/43\n  1104→\n  1105→### Artifacts\n  1106→- Commit: abc1234 (implementation)\n  1107→- Commit: def5678 (tests)\n  1108→- PR: https://github.com/user/repo/pull/43 (only if terminal)"}]},"uuid":"7b3ca436-d42e-4959-9af0-a38aa7c06a9f","timestamp":"2026-02-14T12:13:06.526Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"```\n\n### `writeResults` Update\n\nThe result block now includes test and merge metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Merge (terminal only)\n- Strategy: PR (or direct merge)\n- Status: pr_created\n- PR: https://github.com/user/repo/pull/43\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)","numLines":30,"startLine":1079,"totalLines":1117}},"sourceToolAssistantUUID":"58116f34-a944-45c5-87f5-0880e055d7ef"}
{"parentUuid":"7b3ca436-d42e-4959-9af0-a38aa7c06a9f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01SEEiURCYhJW2QsA58Q32fB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01PSZpQn9cNC7KeAeB8GFTP1","name":"Read","input":{"file_path":"REDACTED.md","offset":1108,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":464,"cache_read_input_tokens":75018,"output_tokens":114,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":464},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7wYtUcsswUxXmUCvZ4w","type":"assistant","uuid":"e4ea9964-307a-4dcb-8a5a-b10b0c0a96ea","timestamp":"2026-02-14T12:13:09.638Z"}
{"parentUuid":"e4ea9964-307a-4dcb-8a5a-b10b0c0a96ea","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01PSZpQn9cNC7KeAeB8GFTP1","parentToolUseID":"toolu_01PSZpQn9cNC7KeAeB8GFTP1","uuid":"8e4989cc-e25f-45b2-a564-ae60c1acfa5c","timestamp":"2026-02-14T12:13:09.641Z"}
{"parentUuid":"8e4989cc-e25f-45b2-a564-ae60c1acfa5c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01PSZpQn9cNC7KeAeB8GFTP1","toolUseID":"toolu_01PSZpQn9cNC7KeAeB8GFTP1","timestamp":"2026-02-14T12:13:09.745Z","uuid":"29a3d5ec-d54d-4e97-9850-2765429ae0fa"}
{"parentUuid":"29a3d5ec-d54d-4e97-9850-2765429ae0fa","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01PSZpQn9cNC7KeAeB8GFTP1","toolUseID":"toolu_01PSZpQn9cNC7KeAeB8GFTP1","timestamp":"2026-02-14T12:13:09.745Z","uuid":"f6e739d6-3de8-45a8-9a31-18e5b1a72ecd"}
{"parentUuid":"e4ea9964-307a-4dcb-8a5a-b10b0c0a96ea","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01PSZpQn9cNC7KeAeB8GFTP1","type":"tool_result","content":"  1108→- PR: https://github.com/user/repo/pull/43 (only if terminal)\n  1109→```\n  1110→\n  1111→### Files Update\n  1112→\n  1113→| File | Change |\n  1114→|------|--------|\n  1115→| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n  1116→| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n  1117→"}]},"uuid":"ef5ac5d5-ad35-481b-a7e3-fa7f529b14f9","timestamp":"2026-02-14T12:13:09.743Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","numLines":10,"startLine":1108,"totalLines":1117}},"sourceToolAssistantUUID":"e4ea9964-307a-4dcb-8a5a-b10b0c0a96ea"}
{"parentUuid":"ef5ac5d5-ad35-481b-a7e3-fa7f529b14f9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_013k3gD1AFJbfGnYn8KYiXWq","type":"message","role":"assistant","content":[{"type":"text","text":"Now I'll restructure. The plan is:\n1. Move Phase 5 (lines 972-1116) to right after Phase 4 (after line 612)\n2. Remove the duplicate `dispatchStage()` and `codeProducingStages` from Phase 5 (Phase 3 already has the complete version)\n3. Remove the duplicate Files Update table from Phase 5 (main Files table already covers it)\n\nFirst, let me remove the entire Phase 5 section from its current location, then insert a trimmed version after Phase 4."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":329,"cache_read_input_tokens":75482,"cache_creation":{"ephemeral_5m_input_tokens":329,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wZ84wBWkofdsSTL8ak","type":"assistant","uuid":"0786f36a-b667-4d37-9674-de2178e8d3e7","timestamp":"2026-02-14T12:13:14.951Z"}
{"parentUuid":"0786f36a-b667-4d37-9674-de2178e8d3e7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_013k3gD1AFJbfGnYn8KYiXWq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013PQn65GFXRZW8N3C1SMxjp","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test and merge metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Merge (terminal only)\n- Strategy: PR (or direct merge)\n- Status: pr_created\n- PR: https://github.com/user/repo/pull/43\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |","new_string":""},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":329,"cache_read_input_tokens":75482,"cache_creation":{"ephemeral_5m_input_tokens":329,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wZ84wBWkofdsSTL8ak","type":"assistant","uuid":"a894c3e3-dd81-4798-8f9f-29ec471d2187","timestamp":"2026-02-14T12:13:27.556Z"}
{"parentUuid":"a894c3e3-dd81-4798-8f9f-29ec471d2187","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_013PQn65GFXRZW8N3C1SMxjp","parentToolUseID":"toolu_013PQn65GFXRZW8N3C1SMxjp","uuid":"00432bc6-3403-401b-85ad-d20abf5c8646","timestamp":"2026-02-14T12:13:27.558Z"}
{"parentUuid":"00432bc6-3403-401b-85ad-d20abf5c8646","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_013PQn65GFXRZW8N3C1SMxjp","toolUseID":"toolu_013PQn65GFXRZW8N3C1SMxjp","timestamp":"2026-02-14T12:13:27.600Z","uuid":"19210344-2604-42a3-87c7-084799e4a75b"}
{"parentUuid":"19210344-2604-42a3-87c7-084799e4a75b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_013PQn65GFXRZW8N3C1SMxjp","toolUseID":"toolu_013PQn65GFXRZW8N3C1SMxjp","timestamp":"2026-02-14T12:13:27.600Z","uuid":"5ddb93cc-c257-4299-90d6-9dfda52b2656"}
{"parentUuid":"a894c3e3-dd81-4798-8f9f-29ec471d2187","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013PQn65GFXRZW8N3C1SMxjp","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"1f88aa08-1a11-4771-b03a-f09c14bce1d4","timestamp":"2026-02-14T12:13:27.599Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test and merge metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Merge (terminal only)\n- Strategy: PR (or direct merge)\n- Status: pr_created\n- PR: https://github.com/user/repo/pull/43\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |","newString":"","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. Return combined WORK_RESULT (stage output + test summary if applicable)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {ticket title + description + acceptance criteria}\n**Branch diff vs main**: {git diff main...HEAD}\n**Is terminal ticket**: {true/false}\n{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n### Orchestrator Integration\n\nThe `dispatchStage()` method conditionally runs the test-writer after code-producing stages:\n\n```typescript\nprivate readonly codeProducingStages = new Set([\n  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",\n]);\n\nprivate async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  // Step 1: Transition to In Progress, then run the stage prompt\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Step 2: Test-writer (same sandbox, only for code-producing stages)\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);\n    testResult = await this.runTestWriterAgent(sandbox, testPrompt);\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\n### `writeResults` Update\n\nThe result block now includes test and merge metadata:\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Tests\n- Unit tests: 8\n- Integration tests: 3 (terminal only)\n- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts\n- All passing: true\n\n### Merge (terminal only)\n- Strategy: PR (or direct merge)\n- Status: pr_created\n- PR: https://github.com/user/repo/pull/43\n\n### Artifacts\n- Commit: abc1234 (implementation)\n- Commit: def5678 (tests)\n- PR: https://github.com/user/repo/pull/43 (only if terminal)\n```\n\n### Files Update\n\n| File | Change |\n|------|--------|\n| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |\n","structuredPatch":[{"oldStart":967,"oldLines":150,"newStart":967,"newLines":3,"lines":["    - Group branch accumulates commits across chain"," 9. **Existing tests**: `npm test` passes"," ","----","-","-## Phase 5: Test-Writer Subagent (deterministic pipeline step)","-","-### Purpose","-","-Worker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.","-","-### Two-Tier Testing Strategy","-","-| Ticket type | Unit tests | Integration tests |","-|-------------|-----------|-------------------|","-| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |","-| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |","-","-### Execution Flow","-","-The test-writer runs **inside `dispatchStage()`** for code-producing stages (Implement, Oneshot, Validate), after the worker agent finishes but before the sandbox is torn down:","-","-```","-dispatchStage(task, stagePrompt):","-  1. Create Daytona sandbox","-  2. Worker agent runs stage prompt, commits, pushes","-  3. If stage is Implement, Oneshot, or Validate:","-     a. Test-writer agent runs in same sandbox","-     b. Reads the git diff (all commits on this branch vs main)","-     c. Reads the ticket description + acceptance criteria","-     d. If terminal: also reads all tickets in the group chain for integration context","-     e. Writes test files to tests/","-     f. Runs `npm test` to verify all tests pass","-     g. Commits test files, pushes to same branch","-  4. Return combined WORK_RESULT (stage output + test summary if applicable)","-```","-","-### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)","-","-```","-You are a Test-Writer Agent. You have just received a completed implementation in this","-sandbox. Your job is to write tests for the code that was changed.","-","-## Context","-","-**Ticket**: {ticket title + description + acceptance criteria}","-**Branch diff vs main**: {git diff main...HEAD}","-**Is terminal ticket**: {true/false}","-{If terminal and grouped: **Full chain tickets**: {all ticket descriptions in this group}}","-","-## Rules","-","-1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.","-2. Follow existing test patterns in the repo (see tests/ for examples).","-3. Write **unit tests** for:","-   - Every new public method on any class","-   - Non-trivial private logic (parsing, state transitions, validation)","-   - Both happy path and at least one meaningful failure case per method","-   - Use descriptive test names: \"returns 401 for expired JWT tokens\"","-4. If this is a **terminal ticket**, also write **integration tests** that:","-   - Exercise the full chain of features built across this variant group","-   - Test interactions between the new code and pre-existing repo code","-   - Cover end-to-end flows from the user's perspective where applicable","-5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.","-6. Run `npm test` after writing. If tests fail, fix them before committing.","-7. Commit all test files with message: \"test: add tests for {ticket title}\"","-","-## Output","-","-TEST_RESULT","----","-files_created: [list of test file paths]","-unit_tests: {count}","-integration_tests: {count}","-all_passing: {true/false}","----","-```","-","-### Orchestrator Integration","-","-The `dispatchStage()` method conditionally runs the test-writer after code-producing stages:","-","-```typescript","-private readonly codeProducingStages = new Set([","-  \"Needs Implement\", \"Needs Oneshot\", \"Needs Validate\",","-]);","-","-private async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {","-  const sandbox = await this.createSandbox(task);","-  const originalStatus = task.status;  // capture before mutation","-","-  // Step 1: Transition to In Progress, then run the stage prompt","-  await this.updateTaskStatus(task, this.inProgressStatus(task.status));","-  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);","-","-  // Step 2: Test-writer (same sandbox, only for code-producing stages)","-  let testResult: TestResult | undefined;","-  if (this.codeProducingStages.has(originalStatus)) {","-    const isTerminal = await this.isTerminal(task);","-    const testPrompt = this.buildTestWriterPrompt(task, isTerminal);","-    testResult = await this.runTestWriterAgent(sandbox, testPrompt);","-  }","-","-  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)","-  let mergeResult: MergeResult | undefined;","-  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {","-    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment","-    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);","-  }","-","-  return { stage: stageResult, tests: testResult, merge: mergeResult };","-}","-```","-","-### `writeResults` Update","-","-The result block now includes test and merge metadata:","-","-```markdown","-## Results","-","-**Completed**: 2026-02-14T12:00:00Z","-**Branch**: feat/dashboard-v2","-","-### Summary","-{parsed from WORK_RESULT}","-","-### Tests","-- Unit tests: 8","-- Integration tests: 3 (terminal only)","-- Files: tests/auth_middleware.test.ts, tests/dashboard_api.test.ts","-- All passing: true","-","-### Merge (terminal only)","-- Strategy: PR (or direct merge)","-- Status: pr_created","-- PR: https://github.com/user/repo/pull/43","-","-### Artifacts","-- Commit: abc1234 (implementation)","-- Commit: def5678 (tests)","-- PR: https://github.com/user/repo/pull/43 (only if terminal)","-```","-","-### Files Update","-","-| File | Change |","-|------|--------|","-| `src/lib/SandboxQueueProcessor.ts` | Add `buildTestWriterPrompt()`, `runTestWriterAgent()`, `codeProducingStages` set, update `dispatchStage()` to conditionally run test-writer after Implement/Oneshot/Validate, update `writeResults()` to include test metadata |","-| `prompts/agent2-worker-test.md` | **New** — Test-Writer prompt with template variables for ticket context, diff, and terminal flag |"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"a894c3e3-dd81-4798-8f9f-29ec471d2187"}
{"parentUuid":"1f88aa08-1a11-4771-b03a-f09c14bce1d4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_014ZPGVbhpMkfhbU9a3WQjJk","type":"message","role":"assistant","content":[{"type":"text","text":"Now insert a trimmed Phase 5 after Phase 4 (without the duplicate `dispatchStage()` and Files table, since those are already covered in Phase 3 and the main Files table)."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2062,"cache_read_input_tokens":75811,"cache_creation":{"ephemeral_5m_input_tokens":2062,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7waSXDtAaumpmydzAgZ","type":"assistant","uuid":"67d078f0-742c-4ac4-8e16-d80aedec5012","timestamp":"2026-02-14T12:13:30.936Z"}
{"parentUuid":"67d078f0-742c-4ac4-8e16-d80aedec5012","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_014ZPGVbhpMkfhbU9a3WQjJk","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JvzuHUiFEzpB9KRC2hG6e5","name":"Read","input":{"file_path":"REDACTED.md","offset":607,"limit":10},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2062,"cache_read_input_tokens":75811,"cache_creation":{"ephemeral_5m_input_tokens":2062,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7waSXDtAaumpmydzAgZ","type":"assistant","uuid":"fc35cef7-e93e-42d9-a55a-05d7a7e33020","timestamp":"2026-02-14T12:13:31.605Z"}
{"parentUuid":"fc35cef7-e93e-42d9-a55a-05d7a7e33020","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01JvzuHUiFEzpB9KRC2hG6e5","parentToolUseID":"toolu_01JvzuHUiFEzpB9KRC2hG6e5","uuid":"a36f1525-8f8d-4be4-926d-ec00ee23ed44","timestamp":"2026-02-14T12:13:31.607Z"}
{"parentUuid":"a36f1525-8f8d-4be4-926d-ec00ee23ed44","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01JvzuHUiFEzpB9KRC2hG6e5","toolUseID":"toolu_01JvzuHUiFEzpB9KRC2hG6e5","timestamp":"2026-02-14T12:13:31.680Z","uuid":"a31f1758-9ce4-480d-9697-5f9e238c742a"}
{"parentUuid":"a31f1758-9ce4-480d-9697-5f9e238c742a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01JvzuHUiFEzpB9KRC2hG6e5","toolUseID":"toolu_01JvzuHUiFEzpB9KRC2hG6e5","timestamp":"2026-02-14T12:13:31.680Z","uuid":"fbd87f60-742f-4c6f-8ed6-f2591dc116e2"}
{"parentUuid":"fc35cef7-e93e-42d9-a55a-05d7a7e33020","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JvzuHUiFEzpB9KRC2hG6e5","type":"tool_result","content":"   607→\n   608→Usage:\n   609→- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n   610→- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n   611→- `npx tsx src/index.ts` → Orchestrator loop\n   612→\n   613→---\n   614→\n   615→## `TaskRequest` Interface Update\n   616→"}]},"uuid":"4c9eec11-901e-46e7-92a7-ffc714256d84","timestamp":"2026-02-14T12:13:31.679Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n","numLines":10,"startLine":607,"totalLines":970}},"sourceToolAssistantUUID":"fc35cef7-e93e-42d9-a55a-05d7a7e33020"}
{"parentUuid":"4c9eec11-901e-46e7-92a7-ffc714256d84","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01YKtzyNTo1fj1F4CoQFENLL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01D62Y1TT42MJUJtQU5CYHji","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update","new_string":"- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox, checkout branch\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)\n  5. Return combined result (stage + test summary + merge status)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {{TICKET_CONTEXT}}\n**Branch diff vs main**: {{BRANCH_DIFF}}\n**Is terminal ticket**: {{IS_TERMINAL}}\n{{CHAIN_TICKETS}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n---\n\n## `TaskRequest` Interface Update"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":286,"cache_read_input_tokens":77873,"cache_creation":{"ephemeral_5m_input_tokens":286,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wajwUErSTGENaKPakb","type":"assistant","uuid":"3b730d2c-7c8d-4143-a7a5-a9ca91c07440","timestamp":"2026-02-14T12:13:43.161Z"}
{"parentUuid":"3b730d2c-7c8d-4143-a7a5-a9ca91c07440","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01D62Y1TT42MJUJtQU5CYHji","parentToolUseID":"toolu_01D62Y1TT42MJUJtQU5CYHji","uuid":"a6a77d62-d2f8-446a-b76c-e14ec706ae89","timestamp":"2026-02-14T12:13:43.163Z"}
{"parentUuid":"a6a77d62-d2f8-446a-b76c-e14ec706ae89","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01D62Y1TT42MJUJtQU5CYHji","toolUseID":"toolu_01D62Y1TT42MJUJtQU5CYHji","timestamp":"2026-02-14T12:13:43.210Z","uuid":"5378d483-20e7-4342-9ef5-3a521381a993"}
{"parentUuid":"5378d483-20e7-4342-9ef5-3a521381a993","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01D62Y1TT42MJUJtQU5CYHji","toolUseID":"toolu_01D62Y1TT42MJUJtQU5CYHji","timestamp":"2026-02-14T12:13:43.210Z","uuid":"2f523849-9ed0-4d50-9dba-603ee0c9df64"}
{"parentUuid":"3b730d2c-7c8d-4143-a7a5-a9ca91c07440","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01D62Y1TT42MJUJtQU5CYHji","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"f40b7c8f-2d3b-46f2-b840-7c180df7a2b9","timestamp":"2026-02-14T12:13:43.209Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update","newString":"- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox, checkout branch\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)\n  5. Return combined result (stage + test summary + merge status)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {{TICKET_CONTEXT}}\n**Branch diff vs main**: {{BRANCH_DIFF}}\n**Is terminal ticket**: {{IS_TERMINAL}}\n{{CHAIN_TICKETS}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n---\n\n## `TaskRequest` Interface Update","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n","structuredPatch":[{"oldStart":612,"oldLines":6,"newStart":612,"newLines":82,"lines":[" "," ---"," ","+## Phase 5: Test-Writer Subagent (deterministic pipeline step)","+","+### Purpose","+","+Worker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.","+","+### Two-Tier Testing Strategy","+","+| Ticket type | Unit tests | Integration tests |","+|-------------|-----------|-------------------|","+| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |","+| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |","+","+### Execution Flow","+","+The test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:","+","+```","+dispatchStage(task, stagePrompt):","+  1. Create Daytona sandbox, checkout branch","+  2. Worker agent runs stage prompt, commits, pushes","+  3. If stage is Implement, Oneshot, or Validate:","+     a. Test-writer agent runs in same sandbox","+     b. Reads the git diff (all commits on this branch vs main)","+     c. Reads the ticket description + acceptance criteria","+     d. If terminal: also reads all tickets in the group chain for integration context","+     e. Writes test files to tests/","+     f. Runs `npm test` to verify all tests pass","+     g. Commits test files, pushes to same branch","+  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)","+  5. Return combined result (stage + test summary + merge status)","+```","+","+### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)","+","+```","+You are a Test-Writer Agent. You have just received a completed implementation in this","+sandbox. Your job is to write tests for the code that was changed.","+","+## Context","+","+**Ticket**: {{TICKET_CONTEXT}}","+**Branch diff vs main**: {{BRANCH_DIFF}}","+**Is terminal ticket**: {{IS_TERMINAL}}","+{{CHAIN_TICKETS}}","+","+## Rules","+","+1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.","+2. Follow existing test patterns in the repo (see tests/ for examples).","+3. Write **unit tests** for:","+   - Every new public method on any class","+   - Non-trivial private logic (parsing, state transitions, validation)","+   - Both happy path and at least one meaningful failure case per method","+   - Use descriptive test names: \"returns 401 for expired JWT tokens\"","+4. If this is a **terminal ticket**, also write **integration tests** that:","+   - Exercise the full chain of features built across this variant group","+   - Test interactions between the new code and pre-existing repo code","+   - Cover end-to-end flows from the user's perspective where applicable","+5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.","+6. Run `npm test` after writing. If tests fail, fix them before committing.","+7. Commit all test files with message: \"test: add tests for {ticket title}\"","+","+## Output","+","+TEST_RESULT","+---","+files_created: [list of test file paths]","+unit_tests: {count}","+integration_tests: {count}","+all_passing: {true/false}","+---","+```","+","+---","+"," ## `TaskRequest` Interface Update"," "," ```typescript"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"3b730d2c-7c8d-4143-a7a5-a9ca91c07440"}
{"parentUuid":"f40b7c8f-2d3b-46f2-b840-7c180df7a2b9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01XpA5QNsy8MkpYhRKA4zTDy","type":"message","role":"assistant","content":[{"type":"text","text":"Issue #8 fixed — Phase 5 now sits directly after Phase 4, duplicate `dispatchStage()` and Files table removed. Note I also updated the prompt template variables to use `{{VARIABLE}}` syntax to match the new PromptLoader convention.\n\n---\n\n**Issue #9: Two Files tables**\n\nThe Phase 5-specific Files table has been removed. The main Files table already includes `SandboxQueueProcessor.ts` with test-writer + merge agent references, and `agent2-worker-test.md`. Let me verify it's complete."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1086,"cache_read_input_tokens":78159,"cache_creation":{"ephemeral_5m_input_tokens":1086,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wbcaEoESWcA3z5BBja","type":"assistant","uuid":"e1a2773f-c679-4f5b-8425-2aa0aba5f374","timestamp":"2026-02-14T12:13:49.248Z"}
{"parentUuid":"e1a2773f-c679-4f5b-8425-2aa0aba5f374","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01XpA5QNsy8MkpYhRKA4zTDy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WNHVnJ7xBZqZ8ycbBom1RM","name":"Grep","input":{"pattern":"agent2-worker-test","path":"REDACTED.md","output_mode":"content"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1086,"cache_read_input_tokens":78159,"cache_creation":{"ephemeral_5m_input_tokens":1086,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wbcaEoESWcA3z5BBja","type":"assistant","uuid":"eb521333-525f-432e-9f79-40bada98a7f1","timestamp":"2026-02-14T12:13:50.132Z"}
{"parentUuid":"eb521333-525f-432e-9f79-40bada98a7f1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01WNHVnJ7xBZqZ8ycbBom1RM","parentToolUseID":"toolu_01WNHVnJ7xBZqZ8ycbBom1RM","uuid":"bb5b1eee-f186-4039-88f1-58ed5c7cce22","timestamp":"2026-02-14T12:13:50.136Z"}
{"parentUuid":"bb5b1eee-f186-4039-88f1-58ed5c7cce22","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01WNHVnJ7xBZqZ8ycbBom1RM","toolUseID":"toolu_01WNHVnJ7xBZqZ8ycbBom1RM","timestamp":"2026-02-14T12:13:50.487Z","uuid":"ecd72474-6929-4b9b-9c74-6beb650cf226"}
{"parentUuid":"ecd72474-6929-4b9b-9c74-6beb650cf226","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"callback"},"parentToolUseID":"toolu_01WNHVnJ7xBZqZ8ycbBom1RM","toolUseID":"toolu_01WNHVnJ7xBZqZ8ycbBom1RM","timestamp":"2026-02-14T12:13:50.487Z","uuid":"a55ebef4-815a-4fc9-a6ae-bfb818120263"}
{"parentUuid":"eb521333-525f-432e-9f79-40bada98a7f1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WNHVnJ7xBZqZ8ycbBom1RM","type":"tool_result","content":"82:| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n103:agent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n648:### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n995:const template = loadPrompt(\"agent2-worker-test.md\");\n1019:| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |"}]},"uuid":"39f492ae-c2e6-4e6c-9eba-90ee56e392f2","timestamp":"2026-02-14T12:13:50.485Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"82:| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n103:agent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n648:### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n995:const template = loadPrompt(\"agent2-worker-test.md\");\n1019:| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |","numLines":5},"sourceToolAssistantUUID":"eb521333-525f-432e-9f79-40bada98a7f1"}
{"parentUuid":"39f492ae-c2e6-4e6c-9eba-90ee56e392f2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01SZBA87fY2JUdLtJqdAqpVH","type":"message","role":"assistant","content":[{"type":"text","text":"Good — `agent2-worker-test.md` is already in the main Files table (line 1019). Issue #9 is already resolved by the Phase 5 move.\n\n---\n\n**Issue #10: HTML comment block at top**\n\nLines 1-23 contain \"HORIZON AGENT INSTRUCTIONS\" for decomposing the plan into sub-issues. This is meta-instructions for a CI/agent system."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":426,"cache_read_input_tokens":79245,"cache_creation":{"ephemeral_5m_input_tokens":426,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wc8KPyqya4ktw8xfZs","type":"assistant","uuid":"b4459386-2e2b-44ad-a8fa-ed77338463a0","timestamp":"2026-02-14T12:13:55.515Z"}
{"parentUuid":"b4459386-2e2b-44ad-a8fa-ed77338463a0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01SZBA87fY2JUdLtJqdAqpVH","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Sk5HDpgegmXT2CwnsAh672","name":"AskUserQuestion","input":{"questions":[{"question":"The HTML comment block at lines 1-23 contains Horizon Agent decomposition instructions. What should we do with it?","header":"Meta comment","options":[{"label":"Remove it","description":"It's meta-instructions for another system. The plan should stand on its own without CI-specific decomposition hints."},{"label":"Keep it","description":"It's useful guidance for whoever implements the plan (human or agent). The HTML comment keeps it hidden from rendered views."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":426,"cache_read_input_tokens":79245,"cache_creation":{"ephemeral_5m_input_tokens":426,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wc8KPyqya4ktw8xfZs","type":"assistant","uuid":"50663d1f-5865-4ad0-b468-064597f71fe1","timestamp":"2026-02-14T12:13:58.725Z"}
{"parentUuid":"50663d1f-5865-4ad0-b468-064597f71fe1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01Sk5HDpgegmXT2CwnsAh672","parentToolUseID":"toolu_01Sk5HDpgegmXT2CwnsAh672","uuid":"8a1dc6d3-6827-4c46-a31e-e003314c0e89","timestamp":"2026-02-14T12:13:58.728Z"}
{"parentUuid":"8a1dc6d3-6827-4c46-a31e-e003314c0e89","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01Sk5HDpgegmXT2CwnsAh672","toolUseID":"toolu_01Sk5HDpgegmXT2CwnsAh672","timestamp":"2026-02-14T12:14:22.219Z","uuid":"c6d6d296-7905-47f9-b886-9d276e3b87e2"}
{"parentUuid":"50663d1f-5865-4ad0-b468-064597f71fe1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"The HTML comment block at lines 1-23 contains Horizon Agent decomposition instructions. What should we do with it?\"=\"Keep it\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01Sk5HDpgegmXT2CwnsAh672"}]},"uuid":"bc5d8b2f-a5b6-451e-9dbb-64988409d99d","timestamp":"2026-02-14T12:14:22.215Z","toolUseResult":{"questions":[{"question":"The HTML comment block at lines 1-23 contains Horizon Agent decomposition instructions. What should we do with it?","header":"Meta comment","options":[{"label":"Remove it","description":"It's meta-instructions for another system. The plan should stand on its own without CI-specific decomposition hints."},{"label":"Keep it","description":"It's useful guidance for whoever implements the plan (human or agent). The HTML comment keeps it hidden from rendered views."}],"multiSelect":false}],"answers":{"The HTML comment block at lines 1-23 contains Horizon Agent decomposition instructions. What should we do with it?":"Keep it"}},"sourceToolAssistantUUID":"50663d1f-5865-4ad0-b468-064597f71fe1"}
{"parentUuid":"bc5d8b2f-a5b6-451e-9dbb-64988409d99d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_012xEQ3T3M7v8iWSmJMF8WBc","type":"message","role":"assistant","content":[{"type":"text","text":"Fair enough — keeping it. Moving on.\n\n---\n\n**Issue #11: `runWorkerAgent` / `runTestWriterAgent` / `runMergeAgent` — undefined**\n\nThese methods are called in `dispatchStage()` but their signatures/behavior aren't described. They presumably use the Daytona SDK to run Claude inside the sandbox."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":330,"cache_read_input_tokens":79671,"cache_creation":{"ephemeral_5m_input_tokens":330,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7weU4rYtkQc1mXbGAtf","type":"assistant","uuid":"99043708-d49d-4205-b460-c50cda23eb43","timestamp":"2026-02-14T12:14:26.463Z"}
{"parentUuid":"99043708-d49d-4205-b460-c50cda23eb43","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_012xEQ3T3M7v8iWSmJMF8WBc","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01NnGy7gttywiH9P22mGWE5Z","name":"AskUserQuestion","input":{"questions":[{"question":"Should the plan describe how runWorkerAgent/runTestWriterAgent/runMergeAgent work, or leave them as implementation details?","header":"Agent runners","options":[{"label":"Brief description (Recommended)","description":"Add a short paragraph explaining they all follow the same pattern: invoke Claude CLI inside the Daytona sandbox via SSH/exec, pass the prompt, parse WORK_RESULT/TEST_RESULT from stdout."},{"label":"Leave as impl detail","description":"The method names are self-explanatory. Implementation will be clear from the existing SandboxQueueProcessor code."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":330,"cache_read_input_tokens":79671,"cache_creation":{"ephemeral_5m_input_tokens":330,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7weU4rYtkQc1mXbGAtf","type":"assistant","uuid":"4c2e2159-9d3f-4563-ad3f-e0e8230ca2ee","timestamp":"2026-02-14T12:14:29.899Z"}
{"parentUuid":"4c2e2159-9d3f-4563-ad3f-e0e8230ca2ee","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01NnGy7gttywiH9P22mGWE5Z","parentToolUseID":"toolu_01NnGy7gttywiH9P22mGWE5Z","uuid":"4112b9ff-45f0-4e6b-ba3f-cb2fa3ffda41","timestamp":"2026-02-14T12:14:29.902Z"}
{"parentUuid":"4112b9ff-45f0-4e6b-ba3f-cb2fa3ffda41","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01NnGy7gttywiH9P22mGWE5Z","toolUseID":"toolu_01NnGy7gttywiH9P22mGWE5Z","timestamp":"2026-02-14T12:14:48.970Z","uuid":"22dff10d-54d3-4ec1-9229-84fe9b11ed68"}
{"parentUuid":"4c2e2159-9d3f-4563-ad3f-e0e8230ca2ee","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Should the plan describe how runWorkerAgent/runTestWriterAgent/runMergeAgent work, or leave them as implementation details?\"=\"Brief description (Recommended)\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01NnGy7gttywiH9P22mGWE5Z"}]},"uuid":"a28b470a-81db-43af-872b-bd3b428c53d3","timestamp":"2026-02-14T12:14:48.968Z","toolUseResult":{"questions":[{"question":"Should the plan describe how runWorkerAgent/runTestWriterAgent/runMergeAgent work, or leave them as implementation details?","header":"Agent runners","options":[{"label":"Brief description (Recommended)","description":"Add a short paragraph explaining they all follow the same pattern: invoke Claude CLI inside the Daytona sandbox via SSH/exec, pass the prompt, parse WORK_RESULT/TEST_RESULT from stdout."},{"label":"Leave as impl detail","description":"The method names are self-explanatory. Implementation will be clear from the existing SandboxQueueProcessor code."}],"multiSelect":false}],"answers":{"Should the plan describe how runWorkerAgent/runTestWriterAgent/runMergeAgent work, or leave them as implementation details?":"Brief description (Recommended)"}},"sourceToolAssistantUUID":"4c2e2159-9d3f-4563-ad3f-e0e8230ca2ee"}
{"parentUuid":"a28b470a-81db-43af-872b-bd3b428c53d3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01BCZ3j6uLKQEcNnDmHzRWrj","type":"message","role":"assistant","content":[{"type":"text","text":"Let me check how the current codebase runs agents in sandboxes to be accurate."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":355,"cache_read_input_tokens":80001,"cache_creation":{"ephemeral_5m_input_tokens":355,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wgSRw7Ex3o7aoTNffR","type":"assistant","uuid":"3af52991-f004-4580-866b-2ac8219ef56d","timestamp":"2026-02-14T12:14:51.940Z"}
{"parentUuid":"3af52991-f004-4580-866b-2ac8219ef56d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01BCZ3j6uLKQEcNnDmHzRWrj","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XbLEJfUFhPsZ5owRwnAjQL","name":"Task","input":{"description":"Find sandbox execution pattern","prompt":"In /Users/ob1/projects/opus-hackathon/napoli-matcha/src/lib/SandboxQueueProcessor.ts, find how the current code executes Claude inside Daytona sandboxes. Look for the method that spawns/runs the worker agent — how does it invoke Claude CLI, what flags does it use, how does it capture output? Report the key method(s) and their signatures.","subagent_type":"Explore"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":355,"cache_read_input_tokens":80001,"cache_creation":{"ephemeral_5m_input_tokens":355,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wgSRw7Ex3o7aoTNffR","type":"assistant","uuid":"07eef943-b10a-4f6b-b841-5758cc0b20a9","timestamp":"2026-02-14T12:14:54.934Z"}
{"parentUuid":"07eef943-b10a-4f6b-b841-5758cc0b20a9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Task","command":"entire hooks claude-code pre-task"},"toolUseID":"toolu_01XbLEJfUFhPsZ5owRwnAjQL","parentToolUseID":"toolu_01XbLEJfUFhPsZ5owRwnAjQL","uuid":"d0927c68-6a03-4e80-8075-b30f59c3d781","timestamp":"2026-02-14T12:14:54.936Z"}
{"parentUuid":"d0927c68-6a03-4e80-8075-b30f59c3d781","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Task","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01XbLEJfUFhPsZ5owRwnAjQL","parentToolUseID":"toolu_01XbLEJfUFhPsZ5owRwnAjQL","uuid":"c945971b-47f8-4aa7-ac1d-af41ba7080e8","timestamp":"2026-02-14T12:14:54.937Z"}
{"parentUuid":"c945971b-47f8-4aa7-ac1d-af41ba7080e8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"type":"text","text":"In /Users/ob1/projects/opus-hackathon/napoli-matcha/src/lib/SandboxQueueProcessor.ts, find how the current code executes Claude inside Daytona sandboxes. Look for the method that spawns/runs the worker agent — how does it invoke Claude CLI, what flags does it use, how does it capture output? Report the key method(s) and their signatures."}]},"uuid":"105f8393-e7dd-4fda-90da-67278d47057e","timestamp":"2026-02-14T12:14:55.207Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/ob1/projects/opus-hackathon/napoli-matcha/src/lib/SandboxQueueProcessor.ts, find how the current code executes Claude inside Daytona sandboxes. Look for the method that spawns/runs the worker agent — how does it invoke Claude CLI, what flags does it use, how does it capture output? Report the key method(s) and their signatures.","agentId":"ae9be93"},"toolUseID":"agent_msg_01BCZ3j6uLKQEcNnDmHzRWrj","parentToolUseID":"toolu_01XbLEJfUFhPsZ5owRwnAjQL","uuid":"d543111e-367d-4853-b19c-3314bbc36d8f","timestamp":"2026-02-14T12:14:55.207Z"}
{"parentUuid":"d543111e-367d-4853-b19c-3314bbc36d8f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:14:56.450Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01HBtPABefYNpUVnQp14MuW8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01TjbwW5pxNcfFVitQjNtY5s","name":"Read","input":{"file_path":"/Users/ob1/projects/opus-hackathon/napoli-matcha/src/lib/SandboxQueueProcessor.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":13704,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":13704,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7wgtmxF2Q5bMJfF6ByY","uuid":"11f6c1a2-b948-4c47-92a0-08688f23852a"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/ob1/projects/opus-hackathon/napoli-matcha/src/lib/SandboxQueueProcessor.ts, find how the current code executes Claude inside Daytona sandboxes. Look for the method that spawns/runs the worker agent — how does it invoke Claude CLI, what flags does it use, how does it capture output? Report the key method(s) and their signatures.","agentId":"ae9be93"},"toolUseID":"agent_msg_01BCZ3j6uLKQEcNnDmHzRWrj","parentToolUseID":"toolu_01XbLEJfUFhPsZ5owRwnAjQL","uuid":"634239dd-735a-4ef3-846d-926f6d86facb","timestamp":"2026-02-14T12:14:56.450Z"}
{"parentUuid":"634239dd-735a-4ef3-846d-926f6d86facb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01TjbwW5pxNcfFVitQjNtY5s","type":"tool_result","content":"     1→import { Daytona, Sandbox } from \"@daytonaio/sdk\";\n     2→import matter from \"gray-matter\";\n     3→import { appendFile, mkdir, readdir, readFile, writeFile } from \"fs/promises\";\n     4→import { join } from \"path\";\n     5→\n     6→interface TaskRequest {\n     7→  id: string;\n     8→  file: string;\n     9→  filePath: string;\n    10→  title: string;\n    11→  description: string;\n    12→  repo: string;\n    13→  numberOfSandboxes: number;\n    14→  status: string;\n    15→}\n    16→\n    17→export class SandboxQueueProcessor {\n    18→  private daytona: Daytona;\n    19→  private queueDir: string;\n    20→  private logsDir: string;\n    21→  private config: {\n    22→    anthropicApiKey: string;\n    23→    githubToken: string;\n    24→    claudeModel: string;\n    25→  };\n    26→\n    27→  constructor(daytonaApiKey: string) {\n    28→    this.daytona = new Daytona({ apiKey: daytonaApiKey });\n    29→    const root = join(import.meta.dirname, \"..\", \"..\");\n    30→    this.queueDir = join(root, \"request_queue\");\n    31→    this.logsDir = join(root, \"logs\");\n    32→    this.config = {\n    33→      anthropicApiKey: process.env.ANTHROPIC_API_KEY!,\n    34→      githubToken: process.env.GITHUB_TOKEN!,\n    35→      claudeModel: \"claude-sonnet-4-5-20250929\",\n    36→    };\n    37→  }\n    38→\n    39→  async processQueue(): Promise<void> {\n    40→    const tasks = await this.loadTasksFromQueue();\n    41→\n    42→    for (const task of tasks) {\n    43→      console.log(`Processing: ${task.title}`);\n    44→      await this.updateTaskStatus(task, \"In Progress\");\n    45→\n    46→      const sandboxTasks = Array.from(\n    47→        { length: task.numberOfSandboxes },\n    48→        (_, i) => this.runInSandbox(task, i + 1)\n    49→      );\n    50→      await Promise.all(sandboxTasks);\n    51→\n    52→      await this.updateTaskStatus(task, \"Done\");\n    53→      console.log(`Completed: ${task.title}`);\n    54→    }\n    55→  }\n    56→\n    57→  private async loadTasksFromQueue(): Promise<TaskRequest[]> {\n    58→    const files = (await readdir(this.queueDir)).filter((f) =>\n    59→      f.endsWith(\".md\")\n    60→    );\n    61→\n    62→    // Scan all queue files to find the highest existing AGI-{n} ID\n    63→    let maxId = 0;\n    64→    const allData: { file: string; filePath: string; data: Record<string, unknown>; raw: string }[] = [];\n    65→    for (const file of files) {\n    66→      const filePath = join(this.queueDir, file);\n    67→      const raw = await readFile(filePath, \"utf-8\");\n    68→      const { data } = matter(raw);\n    69→      allData.push({ file, filePath, data, raw });\n    70→      if (typeof data.id === \"string\") {\n    71→        const match = data.id.match(/^AGI-(\\d+)$/);\n    72→        if (match) maxId = Math.max(maxId, parseInt(match[1], 10));\n    73→      }\n    74→    }\n    75→\n    76→    // Assign IDs to Backlog tasks missing one, and collect runnable tasks\n    77→    const tasks: TaskRequest[] = [];\n    78→    for (const { file, filePath, data } of allData) {\n    79→      if (data.status === \"Backlog\" && !data.id) {\n    80→        maxId++;\n    81→        data.id = `AGI-${maxId}`;\n    82→        await writeFile(filePath, matter.stringify(\"\", data));\n    83→        console.log(`Assigned ${data.id} to ${file}`);\n    84→      }\n    85→      if (data.status === \"Backlog\") {\n    86→        tasks.push({\n    87→          id: data.id as string,\n    88→          file,\n    89→          filePath,\n    90→          title: data.title as string,\n    91→          description: data.description as string,\n    92→          repo: data.repo as string,\n    93→          numberOfSandboxes: data.number_of_sandboxes as number,\n    94→          status: data.status as string,\n    95→        });\n    96→      }\n    97→    }\n    98→\n    99→    return tasks;\n   100→  }\n   101→\n   102→  private async updateTaskStatus(\n   103→    task: TaskRequest,\n   104→    status: string\n   105→  ): Promise<void> {\n   106→    const raw = await readFile(task.filePath, \"utf-8\");\n   107→    const { data } = matter(raw);\n   108→    await writeFile(\n   109→      task.filePath,\n   110→      matter.stringify(\"\", { ...data, status })\n   111→    );\n   112→  }\n   113→\n   114→  private async runInSandbox(\n   115→    task: TaskRequest,\n   116→    sandboxIndex: number\n   117→  ): Promise<void> {\n   118→    const label = `${task.title}-${sandboxIndex}`;\n   119→    const logDir = join(this.logsDir, task.id);\n   120→    const logFile = join(logDir, `agent-${sandboxIndex}.log`);\n   121→\n   122→    await mkdir(logDir, { recursive: true });\n   123→    const header = [\n   124→      \"=== Agent Log ===\",\n   125→      `Ticket: ${task.id}`,\n   126→      `Title: ${task.title}`,\n   127→      `Queue File: request_queue/${task.file}`,\n   128→      `Sandbox: agent-${sandboxIndex}`,\n   129→      `Started: ${new Date().toISOString()}`,\n   130→      \"===\\n\\n\",\n   131→    ].join(\"\\n\");\n   132→    await writeFile(logFile, header);\n   133→\n   134→    const sandbox = await this.daytona.create({ language: \"typescript\" });\n   135→    console.log(`[${label}] Sandbox created`);\n   136→\n   137→    try {\n   138→      const repoDir = await this.setupSandboxEnvironment(sandbox, task.repo, label);\n   139→      await this.installClaudeCLI(sandbox, label);\n   140→      await this.installGitHubCLI(sandbox, label);\n   141→      await this.configureGit(sandbox, label);\n   142→      await this.executeClaudeCommand(sandbox, task, repoDir, label, logFile);\n   143→    } finally {\n   144→      await sandbox.delete();\n   145→      const footer = `\\n=== Finished: ${new Date().toISOString()} ===\\n`;\n   146→      await appendFile(logFile, footer);\n   147→      console.log(`[${label}] Deleted`);\n   148→    }\n   149→  }\n   150→\n   151→  private async setupSandboxEnvironment(\n   152→    sandbox: Sandbox,\n   153→    repo: string,\n   154→    label: string\n   155→  ): Promise<string> {\n   156→    const repoDir = \"/home/daytona/repo\";\n   157→    await sandbox.git.clone(repo, repoDir);\n   158→    console.log(`[${label}] Repo cloned`);\n   159→    return repoDir;\n   160→  }\n   161→\n   162→  private async installClaudeCLI(\n   163→    sandbox: Sandbox,\n   164→    label: string\n   165→  ): Promise<void> {\n   166→    console.log(`[${label}] Installing Claude CLI...`);\n   167→    const claudeInstall = await sandbox.process.executeCommand(\n   168→      \"mkdir -p ~/.npm-global && npm config set prefix '~/.npm-global' && npm install -g @anthropic-ai/claude-code\"\n   169→    );\n   170→    console.log(`[${label}] Claude CLI exit code: ${claudeInstall.exitCode}`);\n   171→\n   172→    if (claudeInstall.exitCode !== 0) {\n   173→      console.error(\n   174→        `[${label}] Failed to install Claude CLI: ${claudeInstall.result}`\n   175→      );\n   176→      throw new Error(\"Failed to install Claude CLI\");\n   177→    }\n   178→\n   179→    const claudeVerify = await sandbox.process.executeCommand(\n   180→      \"export PATH=~/.npm-global/bin:$PATH && which claude && claude --version\"\n   181→    );\n   182→    console.log(`[${label}] Claude CLI location and version: ${claudeVerify.result}`);\n   183→  }\n   184→\n   185→  private async installGitHubCLI(\n   186→    sandbox: Sandbox,\n   187→    label: string\n   188→  ): Promise<void> {\n   189→    console.log(`[${label}] Installing GitHub CLI from binary...`);\n   190→    const ghInstall = await sandbox.process.executeCommand(\n   191→      \"GH_VERSION=2.86.0 && mkdir -p ~/bin && curl -fsSL https://github.com/cli/cli/releases/download/v${GH_VERSION}/gh_${GH_VERSION}_linux_amd64.tar.gz -o /tmp/gh.tar.gz && tar -xzf /tmp/gh.tar.gz -C /tmp && cp /tmp/gh_${GH_VERSION}_linux_amd64/bin/gh ~/bin/gh && chmod +x ~/bin/gh && export PATH=~/bin:$PATH\"\n   192→    );\n   193→    console.log(`[${label}] GitHub CLI install exit code: ${ghInstall.exitCode}`);\n   194→\n   195→    if (ghInstall.exitCode !== 0) {\n   196→      console.error(\n   197→        `[${label}] Failed to install gh CLI: ${ghInstall.result}`\n   198→      );\n   199→      throw new Error(\"Failed to install gh CLI\");\n   200→    }\n   201→\n   202→    const ghVerify = await sandbox.process.executeCommand(\n   203→      \"export PATH=~/bin:$PATH && gh --version\"\n   204→    );\n   205→    console.log(`[${label}] GitHub CLI version: ${ghVerify.result}`);\n   206→  }\n   207→\n   208→  private async configureGit(sandbox: Sandbox, label: string): Promise<void> {\n   209→    console.log(`[${label}] Configuring git...`);\n   210→    await sandbox.process.executeCommand(\n   211→      'git config --global user.email \"claude@anthropic.com\"'\n   212→    );\n   213→    await sandbox.process.executeCommand(\n   214→      'git config --global user.name \"Claude Agent\"'\n   215→    );\n   216→    console.log(`[${label}] Git configured`);\n   217→  }\n   218→\n   219→  private async executeClaudeCommand(\n   220→    sandbox: Sandbox,\n   221→    task: TaskRequest,\n   222→    repoDir: string,\n   223→    label: string,\n   224→    logFile: string\n   225→  ): Promise<void> {\n   226→    const branchName = `feat/${task.id}`;\n   227→    const prTitle = `${task.id}: ${task.title}`;\n   228→    const fullPrompt = `You are working in a cloned git repo. Your task:\n   229→\n   230→1. Create a new branch named \"${branchName}\"\n   231→2. Implement the following feature: ${task.description}\n   232→3. Commit your changes with a clear commit message\n   233→4. Push the branch to origin\n   234→5. Create a pull request using \\`gh pr create\\` with title \"${prTitle}\" and a clear description\n   235→\n   236→IMPORTANT: Use \\`gh\\` CLI for creating the PR (GITHUB_TOKEN is already set in the environment). Do NOT use interactive flags.`;\n   237→\n   238→    const escaped = fullPrompt.replace(/'/g, \"'\\\\''\");\n   239→    const claudeCmd = `claude -p '${escaped}' --dangerously-skip-permissions --output-format=stream-json --model ${this.config.claudeModel} --verbose`;\n   240→\n   241→    console.log(`[${label}] Starting Claude via PTY...`);\n   242→\n   243→    const decoder = new TextDecoder();\n   244→    let buffer = \"\";\n   245→\n   246→    const pty = await sandbox.process.createPty({\n   247→      id: `claude-${label}-${Date.now()}`,\n   248→      cwd: repoDir,\n   249→      envs: {\n   250→        ANTHROPIC_API_KEY: this.config.anthropicApiKey,\n   251→        GITHUB_TOKEN: this.config.githubToken,\n   252→        PATH: \"/home/daytona/.npm-global/bin:/home/daytona/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n   253→      },\n   254→      onData: (data: Uint8Array) => {\n   255→        const text = decoder.decode(data, { stream: true });\n   256→        process.stdout.write(`[${label}] ${text}`);\n   257→\n   258→        buffer += text;\n   259→        const lines = buffer.split(\"\\n\");\n   260→        buffer = lines.pop()!;\n   261→\n   262→        for (const line of lines) {\n   263→          this.handleStreamLine(line, label, logFile);\n   264→        }\n   265→      },\n   266→    });\n   267→\n   268→    await pty.waitForConnection();\n   269→    pty.sendInput(`${claudeCmd}\\n`);\n   270→    pty.sendInput(\"exit\\n\");\n   271→\n   272→    const result = await pty.wait();\n   273→\n   274→    // Flush remaining buffer\n   275→    if (buffer.trim()) {\n   276→      this.handleStreamLine(buffer, label, logFile);\n   277→    }\n   278→\n   279→    console.log(`[${label}] PTY exited with code: ${result.exitCode}`);\n   280→    await appendFile(logFile, `\\nPTY exited with code: ${result.exitCode}\\n`);\n   281→  }\n   282→\n   283→  private handleStreamLine(line: string, label: string, logFile: string): void {\n   284→    const stripped = line.replace(/\\x1b\\[[0-9;]*[a-zA-Z]/g, \"\").trim();\n   285→    if (!stripped) return;\n   286→\n   287→    if (!stripped.startsWith(\"{\")) {\n   288→      appendFile(logFile, `[raw] ${stripped}\\n`);\n   289→      return;\n   290→    }\n   291→\n   292→    try {\n   293→      const event = JSON.parse(stripped);\n   294→      console.log(`[${label}:json] ${JSON.stringify(event)}`);\n   295→      appendFile(logFile, `[json] ${JSON.stringify(event)}\\n`);\n   296→\n   297→      if (event.type === \"assistant\" && event.message?.content) {\n   298→        for (const block of event.message.content) {\n   299→          if (block.type === \"text\") {\n   300→            console.log(`\\n[${label}:assistant] ${block.text}`);\n   301→          }\n   302→        }\n   303→      } else if (event.type === \"result\") {\n   304→        console.log(`\\n[${label}:result] ${event.result}`);\n   305→      }\n   306→    } catch {\n   307→      appendFile(logFile, `[raw] ${stripped}\\n`);\n   308→    }\n   309→  }\n   310→}\n   311→"}]},"uuid":"a938eb1b-7320-42ea-8169-e623fb3b8b8f","timestamp":"2026-02-14T12:14:56.523Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"In /Users/ob1/projects/opus-hackathon/napoli-matcha/src/lib/SandboxQueueProcessor.ts, find how the current code executes Claude inside Daytona sandboxes. Look for the method that spawns/runs the worker agent — how does it invoke Claude CLI, what flags does it use, how does it capture output? Report the key method(s) and their signatures.","agentId":"ae9be93"},"toolUseID":"agent_msg_01BCZ3j6uLKQEcNnDmHzRWrj","parentToolUseID":"toolu_01XbLEJfUFhPsZ5owRwnAjQL","uuid":"ce53c5f8-66c6-4679-ace1-1aa98e3e6623","timestamp":"2026-02-14T12:14:56.555Z"}
{"parentUuid":"ce53c5f8-66c6-4679-ace1-1aa98e3e6623","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Task","command":"entire hooks claude-code post-task"},"parentToolUseID":"toolu_01XbLEJfUFhPsZ5owRwnAjQL","toolUseID":"toolu_01XbLEJfUFhPsZ5owRwnAjQL","timestamp":"2026-02-14T12:15:05.089Z","uuid":"ce0dd681-599b-42c2-a0ba-7a00bc6e2e55"}
{"parentUuid":"ce0dd681-599b-42c2-a0ba-7a00bc6e2e55","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Task","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01XbLEJfUFhPsZ5owRwnAjQL","toolUseID":"toolu_01XbLEJfUFhPsZ5owRwnAjQL","timestamp":"2026-02-14T12:15:05.089Z","uuid":"b08028d5-a66f-4ab4-9b5e-90cd0f892e90"}
{"parentUuid":"07eef943-b10a-4f6b-b841-5758cc0b20a9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XbLEJfUFhPsZ5owRwnAjQL","type":"tool_result","content":[{"type":"text","text":"Perfect! I've found the key method that spawns/runs the worker agent. Here's my analysis:\n\n## Key Method: `executeClaudeCommand()`\n\n**Signature:**\n```typescript\nprivate async executeClaudeCommand(\n  sandbox: Sandbox,\n  task: TaskRequest,\n  repoDir: string,\n  label: string,\n  logFile: string\n): Promise<void>\n```\n\n**Location:** Lines 219-281 in `/Users/ob1/projects/opus-hackathon/napoli-matcha/src/lib/SandboxQueueProcessor.ts`\n\n## How It Invokes Claude CLI\n\n**Command construction (line 239):**\n```typescript\nconst claudeCmd = `claude -p '${escaped}' --dangerously-skip-permissions --output-format=stream-json --model ${this.config.claudeModel} --verbose`;\n```\n\n**Key flags used:**\n- `-p` — passes the prompt as a string argument\n- `--dangerously-skip-permissions` — bypasses permission checks\n- `--output-format=stream-json` — outputs events as JSON stream (one JSON object per line)\n- `--model` — specifies the Claude model (default: `claude-sonnet-4-5-20250929`)\n- `--verbose` — enables verbose logging\n\n**Model used:** `this.config.claudeModel` (set to `\"claude-sonnet-4-5-20250929\"` in the constructor, line 35)\n\n## How It Spawns/Executes\n\nThe code uses a **PTY (pseudo-terminal)** approach via the Daytona SDK (lines 246-272):\n\n```typescript\nconst pty = await sandbox.process.createPty({\n  id: `claude-${label}-${Date.now()}`,\n  cwd: repoDir,\n  envs: {\n    ANTHROPIC_API_KEY: this.config.anthropicApiKey,\n    GITHUB_TOKEN: this.config.githubToken,\n    PATH: \"/home/daytona/.npm-global/bin:/home/daytona/bin:...\",\n  },\n  onData: (data: Uint8Array) => { ... },\n});\n\nawait pty.waitForConnection();\npty.sendInput(`${claudeCmd}\\n`);\npty.sendInput(\"exit\\n\");\nconst result = await pty.wait();\n```\n\n## How It Captures Output\n\nThe PTY uses a **streaming callback pattern** with a line buffering system (lines 243-264):\n\n1. **Callback registration:** The `onData` callback is registered when creating the PTY\n2. **Text decoding:** Uses `TextDecoder` to convert `Uint8Array` to strings\n3. **Line buffering:** Accumulates data in a `buffer`, splits on newlines, and processes complete lines\n4. **Stream handling:** Each line is passed to `handleStreamLine()` for processing\n\n**Output parsing (lines 283-309):**\n- Strips ANSI color codes\n- Attempts to parse as JSON for structured events\n- Captures three event types:\n  - `assistant` — extracts text blocks from Claude's response\n  - `result` — captures final operation results\n  - Raw output — logs unparseable lines\n- All output is written to the log file via `appendFile()`\n\n## Summary\n\nThe code executes Claude by:\n1. Installing Claude CLI globally in the sandbox (`npm install -g @anthropic-ai/claude-code`)\n2. Creating a PTY session with environment variables (ANTHROPIC_API_KEY, GITHUB_TOKEN)\n3. Sending the command with prompt, flags, and model specification\n4. Streaming output line-by-line through a callback that parses JSON events and writes to log files\n5. Waiting for the PTY to exit and capturing the exit code"},{"type":"text","text":"agentId: ae9be93 (for resuming to continue this agent's work if needed)\n<usage>total_tokens: 19075\ntool_uses: 1\nduration_ms: 9881</usage>"}]}]},"uuid":"6088ccd4-6616-48b7-ae14-70459aab4558","timestamp":"2026-02-14T12:15:05.088Z","toolUseResult":{"status":"completed","prompt":"In /Users/ob1/projects/opus-hackathon/napoli-matcha/src/lib/SandboxQueueProcessor.ts, find how the current code executes Claude inside Daytona sandboxes. Look for the method that spawns/runs the worker agent — how does it invoke Claude CLI, what flags does it use, how does it capture output? Report the key method(s) and their signatures.","agentId":"ae9be93","content":[{"type":"text","text":"Perfect! I've found the key method that spawns/runs the worker agent. Here's my analysis:\n\n## Key Method: `executeClaudeCommand()`\n\n**Signature:**\n```typescript\nprivate async executeClaudeCommand(\n  sandbox: Sandbox,\n  task: TaskRequest,\n  repoDir: string,\n  label: string,\n  logFile: string\n): Promise<void>\n```\n\n**Location:** Lines 219-281 in `/Users/ob1/projects/opus-hackathon/napoli-matcha/src/lib/SandboxQueueProcessor.ts`\n\n## How It Invokes Claude CLI\n\n**Command construction (line 239):**\n```typescript\nconst claudeCmd = `claude -p '${escaped}' --dangerously-skip-permissions --output-format=stream-json --model ${this.config.claudeModel} --verbose`;\n```\n\n**Key flags used:**\n- `-p` — passes the prompt as a string argument\n- `--dangerously-skip-permissions` — bypasses permission checks\n- `--output-format=stream-json` — outputs events as JSON stream (one JSON object per line)\n- `--model` — specifies the Claude model (default: `claude-sonnet-4-5-20250929`)\n- `--verbose` — enables verbose logging\n\n**Model used:** `this.config.claudeModel` (set to `\"claude-sonnet-4-5-20250929\"` in the constructor, line 35)\n\n## How It Spawns/Executes\n\nThe code uses a **PTY (pseudo-terminal)** approach via the Daytona SDK (lines 246-272):\n\n```typescript\nconst pty = await sandbox.process.createPty({\n  id: `claude-${label}-${Date.now()}`,\n  cwd: repoDir,\n  envs: {\n    ANTHROPIC_API_KEY: this.config.anthropicApiKey,\n    GITHUB_TOKEN: this.config.githubToken,\n    PATH: \"/home/daytona/.npm-global/bin:/home/daytona/bin:...\",\n  },\n  onData: (data: Uint8Array) => { ... },\n});\n\nawait pty.waitForConnection();\npty.sendInput(`${claudeCmd}\\n`);\npty.sendInput(\"exit\\n\");\nconst result = await pty.wait();\n```\n\n## How It Captures Output\n\nThe PTY uses a **streaming callback pattern** with a line buffering system (lines 243-264):\n\n1. **Callback registration:** The `onData` callback is registered when creating the PTY\n2. **Text decoding:** Uses `TextDecoder` to convert `Uint8Array` to strings\n3. **Line buffering:** Accumulates data in a `buffer`, splits on newlines, and processes complete lines\n4. **Stream handling:** Each line is passed to `handleStreamLine()` for processing\n\n**Output parsing (lines 283-309):**\n- Strips ANSI color codes\n- Attempts to parse as JSON for structured events\n- Captures three event types:\n  - `assistant` — extracts text blocks from Claude's response\n  - `result` — captures final operation results\n  - Raw output — logs unparseable lines\n- All output is written to the log file via `appendFile()`\n\n## Summary\n\nThe code executes Claude by:\n1. Installing Claude CLI globally in the sandbox (`npm install -g @anthropic-ai/claude-code`)\n2. Creating a PTY session with environment variables (ANTHROPIC_API_KEY, GITHUB_TOKEN)\n3. Sending the command with prompt, flags, and model specification\n4. Streaming output line-by-line through a callback that parses JSON events and writes to log files\n5. Waiting for the PTY to exit and capturing the exit code"}],"totalDurationMs":9881,"totalTokens":19075,"totalToolUseCount":1,"usage":{"input_tokens":5,"cache_creation_input_tokens":4466,"cache_read_input_tokens":13704,"output_tokens":900,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":4466},"inference_geo":"","iterations":[],"speed":"standard"}},"sourceToolAssistantUUID":"07eef943-b10a-4f6b-b841-5758cc0b20a9"}
{"parentUuid":"6088ccd4-6616-48b7-ae14-70459aab4558","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_013KfpUAiRo5a2s7dVhwbJYK","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1278,"cache_read_input_tokens":80356,"cache_creation":{"ephemeral_5m_input_tokens":1278,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wheYDpYuniz1UVJw4U","type":"assistant","uuid":"31dc9bb6-a9f5-44df-a5c3-93883d34be14","timestamp":"2026-02-14T12:15:08.115Z"}
{"parentUuid":"31dc9bb6-a9f5-44df-a5c3-93883d34be14","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_013KfpUAiRo5a2s7dVhwbJYK","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"Good, now I know the current pattern. All agent runners use the same approach: PTY session in Daytona sandbox, `claude -p` with `--output-format=stream-json`. Let me add a brief description to the plan.","signature":"EvMCCkYICxgCKkDivRfEWnslmfaw0fH/h3lncTXZdxLQex0oC0HdmzJ6thrV2bNDRAkFfs/OTYrf2GnS9M/GEd9wseTB865y6k4ZEgykfyPG+BnT5BS6I+MaDHAo4PHqTYbnHXhzbyIwpFbS8D72l+UgLxtijigHbF51sa2RvXVTAKDaEPJ+tBDUzu7OWnXdpuDwzwVvnvDVKtoBQmwPlqkzzKrwH/JQolY2Q+vTA1Col0SRk5Wojq8hz2cAYnkuhGPpTfU0xIZtU2k1sKJQ3qE3R7UEv9eOrJBiq70fYOkcP+VkYPk4V7EkbZ6pRWUr2CCM+1tIH8CLKFvoBO/h83E8mBwweb5cRGMpR6vqLEz/G0TO/Ln/81iQH0bq/WH5D3EplJSPeGK7svQWFtNnpi+yODM8MtXPcFFrcv8WnZkLV6sC6NxponJXz0qzVD59BFnRXCbOwlRF2uOgfau/Ex+8QkVinNtXZCN8gpW31w0Vs0XipocYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1278,"cache_read_input_tokens":80356,"cache_creation":{"ephemeral_5m_input_tokens":1278,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wheYDpYuniz1UVJw4U","type":"assistant","uuid":"c8805c3f-ddb5-42a5-9fb6-f156ee672939","timestamp":"2026-02-14T12:15:09.517Z"}
{"parentUuid":"c8805c3f-ddb5-42a5-9fb6-f156ee672939","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_013KfpUAiRo5a2s7dVhwbJYK","type":"message","role":"assistant","content":[{"type":"text","text":"Good — they all use the same pattern: PTY in Daytona sandbox with `claude -p --output-format=stream-json`. Let me add this to the plan."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1278,"cache_read_input_tokens":80356,"cache_creation":{"ephemeral_5m_input_tokens":1278,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wheYDpYuniz1UVJw4U","type":"assistant","uuid":"91ec0d53-5a16-4aba-907d-b4154ddf652d","timestamp":"2026-02-14T12:15:10.263Z"}
{"parentUuid":"91ec0d53-5a16-4aba-907d-b4154ddf652d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_013KfpUAiRo5a2s7dVhwbJYK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CHx5fQKKZi6KYpnX2nPS2w","name":"Read","input":{"file_path":"REDACTED.md","offset":531,"limit":10},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":1278,"cache_read_input_tokens":80356,"cache_creation":{"ephemeral_5m_input_tokens":1278,"ephemeral_1h_input_tokens":0},"output_tokens":9,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wheYDpYuniz1UVJw4U","type":"assistant","uuid":"d914c140-06e7-4e75-9fd6-d51144bba428","timestamp":"2026-02-14T12:15:10.888Z"}
{"parentUuid":"d914c140-06e7-4e75-9fd6-d51144bba428","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01CHx5fQKKZi6KYpnX2nPS2w","parentToolUseID":"toolu_01CHx5fQKKZi6KYpnX2nPS2w","uuid":"81be1939-c6a1-459a-b8d9-b5e331065e94","timestamp":"2026-02-14T12:15:10.891Z"}
{"parentUuid":"81be1939-c6a1-459a-b8d9-b5e331065e94","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01CHx5fQKKZi6KYpnX2nPS2w","toolUseID":"toolu_01CHx5fQKKZi6KYpnX2nPS2w","timestamp":"2026-02-14T12:15:10.963Z","uuid":"8d9eb090-77dc-4eb8-a7dc-bd889a622cd4"}
{"parentUuid":"8d9eb090-77dc-4eb8-a7dc-bd889a622cd4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01CHx5fQKKZi6KYpnX2nPS2w","toolUseID":"toolu_01CHx5fQKKZi6KYpnX2nPS2w","timestamp":"2026-02-14T12:15:10.963Z","uuid":"c0fb5619-4fd0-40b1-ac39-9481b5a4c88b"}
{"parentUuid":"d914c140-06e7-4e75-9fd6-d51144bba428","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CHx5fQKKZi6KYpnX2nPS2w","type":"tool_result","content":"   531→\n   532→### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n   533→\n   534→Each invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n   535→\n   536→Key behaviors:\n   537→1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n   538→2. **Branch name** passed to worker prompt uses `branchName(task)`\n   539→3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   540→   - `createSandbox(task)` clones the repo via Daytona SDK"}]},"uuid":"c1051dcb-36bc-4636-8314-231d3c7aa02a","timestamp":"2026-02-14T12:15:10.962Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK","numLines":10,"startLine":531,"totalLines":1046}},"sourceToolAssistantUUID":"d914c140-06e7-4e75-9fd6-d51144bba428"}
{"parentUuid":"c1051dcb-36bc-4636-8314-231d3c7aa02a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01TUNaMcXYZx53fHiA85cG9E","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XxQTHC6NNDxhRxhfu43AQ6","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.","new_string":"### Agent Runner Pattern\n\n`runWorkerAgent()`, `runTestWriterAgent()`, and `runMergeAgent()` all follow the same pattern inherited from the existing `executeClaudeCommand()`:\n\n1. Open a PTY session in the Daytona sandbox via the SDK\n2. Invoke `claude -p '<prompt>' --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n3. Stream stdout line-by-line, parse JSON events, log to file\n4. Extract structured output (WORK_RESULT / TEST_RESULT) from the `result` event\n5. Return parsed result\n\nThe only difference between the three is which prompt they receive and which output block they parse.\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":428,"cache_read_input_tokens":81634,"cache_creation":{"ephemeral_5m_input_tokens":428,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wi4PRqfkSXTFHVwYRn","type":"assistant","uuid":"cae1bc00-079e-4c1e-9975-97da00c2f358","timestamp":"2026-02-14T12:15:18.206Z"}
{"parentUuid":"cae1bc00-079e-4c1e-9975-97da00c2f358","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01XxQTHC6NNDxhRxhfu43AQ6","parentToolUseID":"toolu_01XxQTHC6NNDxhRxhfu43AQ6","uuid":"7c622782-d36d-4516-aae3-8afa5c560fcb","timestamp":"2026-02-14T12:15:18.209Z"}
{"parentUuid":"7c622782-d36d-4516-aae3-8afa5c560fcb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01XxQTHC6NNDxhRxhfu43AQ6","toolUseID":"toolu_01XxQTHC6NNDxhRxhfu43AQ6","timestamp":"2026-02-14T12:15:18.259Z","uuid":"ca6f5746-0d95-46e4-8cc5-e8b18cb7a1b2"}
{"parentUuid":"ca6f5746-0d95-46e4-8cc5-e8b18cb7a1b2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01XxQTHC6NNDxhRxhfu43AQ6","toolUseID":"toolu_01XxQTHC6NNDxhRxhfu43AQ6","timestamp":"2026-02-14T12:15:18.259Z","uuid":"e1e0d56b-9a20-401d-9d5c-f6f074843f7a"}
{"parentUuid":"cae1bc00-079e-4c1e-9975-97da00c2f358","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XxQTHC6NNDxhRxhfu43AQ6","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"f933b18a-33ce-46e1-97c8-aa09910f438d","timestamp":"2026-02-14T12:15:18.258Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.","newString":"### Agent Runner Pattern\n\n`runWorkerAgent()`, `runTestWriterAgent()`, and `runMergeAgent()` all follow the same pattern inherited from the existing `executeClaudeCommand()`:\n\n1. Open a PTY session in the Daytona sandbox via the SDK\n2. Invoke `claude -p '<prompt>' --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n3. Stream stdout line-by-line, parse JSON events, log to file\n4. Extract structured output (WORK_RESULT / TEST_RESULT) from the `result` event\n5. Return parsed result\n\nThe only difference between the three is which prompt they receive and which output block they parse.\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox, checkout branch\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)\n  5. Return combined result (stage + test summary + merge status)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {{TICKET_CONTEXT}}\n**Branch diff vs main**: {{BRANCH_DIFF}}\n**Is terminal ticket**: {{IS_TERMINAL}}\n{{CHAIN_TICKETS}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n","structuredPatch":[{"oldStart":529,"oldLines":6,"newStart":529,"newLines":18,"lines":[" }"," ```"," ","+### Agent Runner Pattern","+","+`runWorkerAgent()`, `runTestWriterAgent()`, and `runMergeAgent()` all follow the same pattern inherited from the existing `executeClaudeCommand()`:","+","+1. Open a PTY session in the Daytona sandbox via the SDK","+2. Invoke `claude -p '<prompt>' --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`","+3. Stream stdout line-by-line, parse JSON events, log to file","+4. Extract structured output (WORK_RESULT / TEST_RESULT) from the `result` event","+5. Return parsed result","+","+The only difference between the three is which prompt they receive and which output block they parse.","+"," ### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)"," "," Each invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT."]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"cae1bc00-079e-4c1e-9975-97da00c2f358"}
{"parentUuid":"f933b18a-33ce-46e1-97c8-aa09910f438d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_011r9fALsyVNpLJc4wpPa2Yr","type":"message","role":"assistant","content":[{"type":"text","text":"Issue #11 fixed. Moving on to the last issue.\n\n---\n\n**Issue #12: Error handling on stage failure**\n\nThe plan mentions \"A worker crash doesn't lose progress — the ticket stays at its last In Progress status\" but doesn't describe retry logic, timeouts, or when the orchestrator gives up and sets an intervention status."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":481,"cache_read_input_tokens":82062,"cache_creation":{"ephemeral_5m_input_tokens":481,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wibeNhLEzXctH6JrUB","type":"assistant","uuid":"f8939143-059b-4d16-a526-84c479d70523","timestamp":"2026-02-14T12:15:22.645Z"}
{"parentUuid":"f8939143-059b-4d16-a526-84c479d70523","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_011r9fALsyVNpLJc4wpPa2Yr","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QYewkdoCyzvHvs1Jd6XbK1","name":"AskUserQuestion","input":{"questions":[{"question":"What should happen when a worker crashes (exit code != 0, no WORK_RESULT output)?","header":"Worker failure","options":[{"label":"Retry once, then Blocked","description":"On crash, retry the same stage once. If it fails again, set status to 'Blocked' and log for human attention. Simple, avoids infinite loops."},{"label":"No retry, immediate Blocked","description":"Any crash immediately sets the ticket to 'Blocked'. Humans investigate and manually reset to the 'Needs *' status to retry."},{"label":"Configurable retry count","description":"Add a maxRetries config (default 1). Retry up to N times, then set to 'Blocked'."}],"multiSelect":false},{"question":"Should there be a timeout per stage invocation?","header":"Timeout","options":[{"label":"Yes, configurable (Recommended)","description":"Add a stageTimeoutMs config (e.g., 15 minutes default). If the worker doesn't finish in time, kill it and treat as a crash."},{"label":"No timeout","description":"Let workers run as long as they need. The Daytona sandbox has its own lifetime limits."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":481,"cache_read_input_tokens":82062,"output_tokens":432,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":481},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7wibeNhLEzXctH6JrUB","type":"assistant","uuid":"b6623aa9-2534-493f-ab36-fe2673442920","timestamp":"2026-02-14T12:15:28.715Z"}
{"parentUuid":"b6623aa9-2534-493f-ab36-fe2673442920","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01QYewkdoCyzvHvs1Jd6XbK1","parentToolUseID":"toolu_01QYewkdoCyzvHvs1Jd6XbK1","uuid":"76a18997-deeb-4f6f-a658-06a521b10c22","timestamp":"2026-02-14T12:15:28.719Z"}
{"parentUuid":"76a18997-deeb-4f6f-a658-06a521b10c22","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01QYewkdoCyzvHvs1Jd6XbK1","toolUseID":"toolu_01QYewkdoCyzvHvs1Jd6XbK1","timestamp":"2026-02-14T12:15:59.918Z","uuid":"c64c15a2-fa17-41f0-925b-2c61a5716b3a"}
{"parentUuid":"b6623aa9-2534-493f-ab36-fe2673442920","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"What should happen when a worker crashes (exit code != 0, no WORK_RESULT output)?\"=\"Retry once, then Blocked\", \"Should there be a timeout per stage invocation?\"=\"No timeout\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01QYewkdoCyzvHvs1Jd6XbK1"}]},"uuid":"89790498-134c-495d-87be-bb9b57ada873","timestamp":"2026-02-14T12:15:59.912Z","toolUseResult":{"questions":[{"question":"What should happen when a worker crashes (exit code != 0, no WORK_RESULT output)?","header":"Worker failure","options":[{"label":"Retry once, then Blocked","description":"On crash, retry the same stage once. If it fails again, set status to 'Blocked' and log for human attention. Simple, avoids infinite loops."},{"label":"No retry, immediate Blocked","description":"Any crash immediately sets the ticket to 'Blocked'. Humans investigate and manually reset to the 'Needs *' status to retry."},{"label":"Configurable retry count","description":"Add a maxRetries config (default 1). Retry up to N times, then set to 'Blocked'."}],"multiSelect":false},{"question":"Should there be a timeout per stage invocation?","header":"Timeout","options":[{"label":"Yes, configurable (Recommended)","description":"Add a stageTimeoutMs config (e.g., 15 minutes default). If the worker doesn't finish in time, kill it and treat as a crash."},{"label":"No timeout","description":"Let workers run as long as they need. The Daytona sandbox has its own lifetime limits."}],"multiSelect":false}],"answers":{"What should happen when a worker crashes (exit code != 0, no WORK_RESULT output)?":"Retry once, then Blocked","Should there be a timeout per stage invocation?":"No timeout"}},"sourceToolAssistantUUID":"b6623aa9-2534-493f-ab36-fe2673442920"}
{"parentUuid":"89790498-134c-495d-87be-bb9b57ada873","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01JSQxf8fmNoNmGYhf8N2TDQ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KGDUKH2ewZmLE7QXpVrA5m","name":"Read","input":{"file_path":"REDACTED.md","offset":440,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":509,"cache_read_input_tokens":82543,"cache_creation":{"ephemeral_5m_input_tokens":509,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wmfri4Q4NTRYFgkBTd","type":"assistant","uuid":"09053691-994f-4645-a8b0-905185ff5297","timestamp":"2026-02-14T12:16:02.924Z"}
{"parentUuid":"09053691-994f-4645-a8b0-905185ff5297","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01KGDUKH2ewZmLE7QXpVrA5m","parentToolUseID":"toolu_01KGDUKH2ewZmLE7QXpVrA5m","uuid":"eca49b5c-2cf2-4ac4-ade0-3982862e300b","timestamp":"2026-02-14T12:16:02.928Z"}
{"parentUuid":"eca49b5c-2cf2-4ac4-ade0-3982862e300b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01KGDUKH2ewZmLE7QXpVrA5m","toolUseID":"toolu_01KGDUKH2ewZmLE7QXpVrA5m","timestamp":"2026-02-14T12:16:03.031Z","uuid":"277c5f31-b977-485a-a014-1528e8d4eea4"}
{"parentUuid":"277c5f31-b977-485a-a014-1528e8d4eea4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01KGDUKH2ewZmLE7QXpVrA5m","toolUseID":"toolu_01KGDUKH2ewZmLE7QXpVrA5m","timestamp":"2026-02-14T12:16:03.031Z","uuid":"61c37f4f-1e51-45e2-9662-b858bc48d0f4"}
{"parentUuid":"09053691-994f-4645-a8b0-905185ff5297","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KGDUKH2ewZmLE7QXpVrA5m","type":"tool_result","content":"   440→### Spec Agent Sets Initial Stage\n   441→\n   442→The Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n   443→\n   444→```typescript\n   445→// In the Spec Agent prompt output, each ticket includes a start_status:\n   446→- id: AGI-{n}\n   447→  title: {title}\n   448→  description: {description}\n   449→  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n   450→```\n   451→\n   452→Stage-skipping rules for the Spec Agent:\n   453→\n   454→| Ticket Characteristics | Start Status | Rationale |"}]},"uuid":"9b6da448-84ec-4b94-bf93-3ff8cc567f0c","timestamp":"2026-02-14T12:16:03.030Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |","numLines":15,"startLine":440,"totalLines":1058}},"sourceToolAssistantUUID":"09053691-994f-4645-a8b0-905185ff5297"}
{"parentUuid":"9b6da448-84ec-4b94-bf93-3ff8cc567f0c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01Bx9Laa99mjLpEKufWka85u","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011qDG3AEoHXpDK4c1svZumv","name":"Read","input":{"file_path":"REDACTED.md","offset":427,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":320,"cache_read_input_tokens":83052,"cache_creation":{"ephemeral_5m_input_tokens":320,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wmu5hJs3DPJ6mrGLe3","type":"assistant","uuid":"117149fc-270e-43ff-8c25-d42ee80e5e43","timestamp":"2026-02-14T12:16:06.008Z"}
{"parentUuid":"117149fc-270e-43ff-8c25-d42ee80e5e43","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_011qDG3AEoHXpDK4c1svZumv","parentToolUseID":"toolu_011qDG3AEoHXpDK4c1svZumv","uuid":"8b4fc32a-38d8-4135-ad89-50828565b649","timestamp":"2026-02-14T12:16:06.011Z"}
{"parentUuid":"8b4fc32a-38d8-4135-ad89-50828565b649","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_011qDG3AEoHXpDK4c1svZumv","toolUseID":"toolu_011qDG3AEoHXpDK4c1svZumv","timestamp":"2026-02-14T12:16:06.083Z","uuid":"abd8e065-f865-4979-9561-02093761164d"}
{"parentUuid":"abd8e065-f865-4979-9561-02093761164d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_011qDG3AEoHXpDK4c1svZumv","toolUseID":"toolu_011qDG3AEoHXpDK4c1svZumv","timestamp":"2026-02-14T12:16:06.083Z","uuid":"965c4f55-7851-4b69-bd17-54f4cf101bf3"}
{"parentUuid":"117149fc-270e-43ff-8c25-d42ee80e5e43","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011qDG3AEoHXpDK4c1svZumv","type":"tool_result","content":"   427→1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n   428→2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n   429→3. Orchestrator updates MD file: `status: Needs Plan`\n   430→4. Worker A is released (sandbox torn down if applicable)\n   431→5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n   432→6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n   433→7. Repeat until terminal status\n   434→\n   435→This means:\n   436→- Workers are **stateless** — all context comes from the ticket MD file + repo state\n   437→- Multiple tickets in different stages can run in parallel across different workers\n   438→- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n   439→\n   440→### Spec Agent Sets Initial Stage\n   441→"}]},"uuid":"e3c3193e-1a83-4bda-a66a-262373489a2b","timestamp":"2026-02-14T12:16:06.082Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n","numLines":15,"startLine":427,"totalLines":1058}},"sourceToolAssistantUUID":"117149fc-270e-43ff-8c25-d42ee80e5e43"}
{"parentUuid":"e3c3193e-1a83-4bda-a66a-262373489a2b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_0186RDrXXuCFnrop1JcDFm1A","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Q7hsfdF1iMmp8Ke733ocsh","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"This means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried","new_string":"This means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status\n\n**Crash recovery**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":386,"cache_read_input_tokens":83372,"cache_creation":{"ephemeral_5m_input_tokens":386,"ephemeral_1h_input_tokens":0},"output_tokens":18,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wn86XvriTRP9yHAEEG","type":"assistant","uuid":"5aa058c9-d5d7-44fa-8c62-4cd95e9a440a","timestamp":"2026-02-14T12:16:12.434Z"}
{"parentUuid":"5aa058c9-d5d7-44fa-8c62-4cd95e9a440a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01Q7hsfdF1iMmp8Ke733ocsh","parentToolUseID":"toolu_01Q7hsfdF1iMmp8Ke733ocsh","uuid":"3849a283-c9d4-4fa9-a043-b918e8ab183c","timestamp":"2026-02-14T12:16:12.436Z"}
{"parentUuid":"3849a283-c9d4-4fa9-a043-b918e8ab183c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01Q7hsfdF1iMmp8Ke733ocsh","toolUseID":"toolu_01Q7hsfdF1iMmp8Ke733ocsh","timestamp":"2026-02-14T12:16:12.485Z","uuid":"5b83274b-af89-497e-887b-6d923ef0b3ff"}
{"parentUuid":"5b83274b-af89-497e-887b-6d923ef0b3ff","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01Q7hsfdF1iMmp8Ke733ocsh","toolUseID":"toolu_01Q7hsfdF1iMmp8Ke733ocsh","timestamp":"2026-02-14T12:16:12.485Z","uuid":"d3f83ccb-5738-43a3-b53b-e39a80d7d604"}
{"parentUuid":"5aa058c9-d5d7-44fa-8c62-4cd95e9a440a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q7hsfdF1iMmp8Ke733ocsh","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"2912e65b-194b-4b0c-814d-b1489faa4532","timestamp":"2026-02-14T12:16:12.484Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"This means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried","newString":"This means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status\n\n**Crash recovery**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### Agent Runner Pattern\n\n`runWorkerAgent()`, `runTestWriterAgent()`, and `runMergeAgent()` all follow the same pattern inherited from the existing `executeClaudeCommand()`:\n\n1. Open a PTY session in the Daytona sandbox via the SDK\n2. Invoke `claude -p '<prompt>' --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n3. Stream stdout line-by-line, parse JSON events, log to file\n4. Extract structured output (WORK_RESULT / TEST_RESULT) from the `result` event\n5. Return parsed result\n\nThe only difference between the three is which prompt they receive and which output block they parse.\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox, checkout branch\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)\n  5. Return combined result (stage + test summary + merge status)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {{TICKET_CONTEXT}}\n**Branch diff vs main**: {{BRANCH_DIFF}}\n**Is terminal ticket**: {{IS_TERMINAL}}\n{{CHAIN_TICKETS}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n","structuredPatch":[{"oldStart":435,"oldLines":8,"newStart":435,"newLines":10,"lines":[" This means:"," - Workers are **stateless** — all context comes from the ticket MD file + repo state"," - Multiple tickets in different stages can run in parallel across different workers","-- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status and can be retried","+- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status"," ","+**Crash recovery**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.","+"," ### Spec Agent Sets Initial Stage"," "," The Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"5aa058c9-d5d7-44fa-8c62-4cd95e9a440a"}
{"parentUuid":"2912e65b-194b-4b0c-814d-b1489faa4532","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01YaxkWr2nPHe2A4aFHUQdQD","type":"message","role":"assistant","content":[{"type":"text","text":"Issue #12 fixed. All 12 issues are now resolved. Let me do a quick scan to make sure the document is internally consistent after all the edits."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":404,"cache_read_input_tokens":83758,"cache_creation":{"ephemeral_5m_input_tokens":404,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wnbNs17tWcC6zQ5ef7","type":"assistant","uuid":"996de6c4-be8d-4538-80a4-04a1e66ced40","timestamp":"2026-02-14T12:16:16.051Z"}
{"parentUuid":"996de6c4-be8d-4538-80a4-04a1e66ced40","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01YaxkWr2nPHe2A4aFHUQdQD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013AsrATKXX4DKZmGC2XQFKh","name":"Read","input":{"file_path":"REDACTED.md","offset":1,"limit":30},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":404,"cache_read_input_tokens":83758,"cache_creation":{"ephemeral_5m_input_tokens":404,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wnbNs17tWcC6zQ5ef7","type":"assistant","uuid":"bf942e03-bb0b-4cbc-8ae2-845012830205","timestamp":"2026-02-14T12:16:16.938Z"}
{"parentUuid":"bf942e03-bb0b-4cbc-8ae2-845012830205","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_013AsrATKXX4DKZmGC2XQFKh","parentToolUseID":"toolu_013AsrATKXX4DKZmGC2XQFKh","uuid":"d0e4231a-dce9-47c1-b108-c3c5d8a6ae94","timestamp":"2026-02-14T12:16:16.941Z"}
{"parentUuid":"d0e4231a-dce9-47c1-b108-c3c5d8a6ae94","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_013AsrATKXX4DKZmGC2XQFKh","toolUseID":"toolu_013AsrATKXX4DKZmGC2XQFKh","timestamp":"2026-02-14T12:16:17.010Z","uuid":"c94607c4-9632-4662-838d-960146656a61"}
{"parentUuid":"c94607c4-9632-4662-838d-960146656a61","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_013AsrATKXX4DKZmGC2XQFKh","toolUseID":"toolu_013AsrATKXX4DKZmGC2XQFKh","timestamp":"2026-02-14T12:16:17.010Z","uuid":"2313480b-3126-41f2-8561-2e11c3230c29"}
{"parentUuid":"bf942e03-bb0b-4cbc-8ae2-845012830205","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013AsrATKXX4DKZmGC2XQFKh","type":"tool_result","content":"     1→<!--\n     2→HORIZON AGENT INSTRUCTIONS:\n     3→This plan contains 5 major phases with significant new components and core refactoring.\n     4→Please decompose this into sub-issues for judicious parallel execution where possible.\n     5→\n     6→Sub-issues with explicit dependencies:\n     7→1. ClaudeSpawner (Phase 2)           — depends_on: []\n     8→2. SpecAgent (Phase 1)               — depends_on: [1]\n     9→3. TaskStatus enum + helpers         — depends_on: []\n    10→4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n    11→5. Test-Writer (Phase 5)             — depends_on: [4]\n    12→6. Entry Point (Phase 4)             — depends_on: [2, 4]\n    13→7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n    14→\n    15→Execution waves:\n    16→  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n    17→  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n    18→  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n    19→\n    20→Notes:\n    21→- Phase 3 (Orchestrator) is the most complex and touches many files\n    22→- #7 is pure markdown edits with no code dependencies — safe for wave 1\n    23→- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n    24→-->\n    25→\n    26→# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n    27→\n    28→---\n    29→\n    30→## Reference Architecture: Horizon CLI Agent"}]},"uuid":"ed6f2419-e24d-42f8-b563-d54a42532f7c","timestamp":"2026-02-14T12:16:17.009Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent","numLines":30,"startLine":1,"totalLines":1060}},"sourceToolAssistantUUID":"bf942e03-bb0b-4cbc-8ae2-845012830205"}
{"parentUuid":"ed6f2419-e24d-42f8-b563-d54a42532f7c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01VsozLJgEoesHAd7PWBMFcA","type":"message","role":"assistant","content":[{"type":"text","text":"Good — I notice the HTML comment still references the old sub-issue numbering format. Let me also update it to reflect the changes we made (PromptLoader added, merge agent added, etc.)."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":768,"cache_read_input_tokens":84162,"cache_creation":{"ephemeral_5m_input_tokens":768,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wnvv71pNRiGD2F7fax","type":"assistant","uuid":"823d1d80-daaa-4753-b892-4d5caf93912f","timestamp":"2026-02-14T12:16:21.092Z"}
{"parentUuid":"823d1d80-daaa-4753-b892-4d5caf93912f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01VsozLJgEoesHAd7PWBMFcA","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014HWj3Gw5DeELtc3Sg3S8ge","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->","new_string":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. PromptLoader                      — depends_on: []\n3. TaskStatus enum + helpers         — depends_on: []\n4. SpecAgent (Phase 1)               — depends_on: [1, 2]\n5. Orchestrator refactor (Phase 3)   — depends_on: [2, 3]\n6. Test-Writer (Phase 5)             — depends_on: [5]\n7. Entry Point (Phase 4)             — depends_on: [4, 5]\n8. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #2 (PromptLoader), #3 (TaskStatus), #8 (Prompt adaptations)\n  Wave 2: #4 (SpecAgent), #5 (Orchestrator)  — #4 needs #1+#2, #5 needs #2+#3\n  Wave 3: #6 (Test-Writer), #7 (Entry Point) — #6 needs #5, #7 needs #4+#5\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #8 is pure markdown edits with no code dependencies — safe for wave 1\n- #4 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n- Merge agent is part of #5 (Orchestrator) — uses merge-auto.md fragment via PromptLoader\n-->"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":768,"cache_read_input_tokens":84162,"cache_creation":{"ephemeral_5m_input_tokens":768,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wnvv71pNRiGD2F7fax","type":"assistant","uuid":"a3c66859-6502-4075-a6ae-6a53acfb6a2b","timestamp":"2026-02-14T12:16:28.718Z"}
{"parentUuid":"a3c66859-6502-4075-a6ae-6a53acfb6a2b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_014HWj3Gw5DeELtc3Sg3S8ge","parentToolUseID":"toolu_014HWj3Gw5DeELtc3Sg3S8ge","uuid":"47c3843f-91a1-4e6d-b4e9-a56406f8d376","timestamp":"2026-02-14T12:16:28.720Z"}
{"parentUuid":"47c3843f-91a1-4e6d-b4e9-a56406f8d376","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_014HWj3Gw5DeELtc3Sg3S8ge","toolUseID":"toolu_014HWj3Gw5DeELtc3Sg3S8ge","timestamp":"2026-02-14T12:16:28.787Z","uuid":"47078e19-eeed-4198-959c-28957de8df1c"}
{"parentUuid":"47078e19-eeed-4198-959c-28957de8df1c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_014HWj3Gw5DeELtc3Sg3S8ge","toolUseID":"toolu_014HWj3Gw5DeELtc3Sg3S8ge","timestamp":"2026-02-14T12:16:28.787Z","uuid":"e985e99a-ad68-4968-b620-808ad845397c"}
{"parentUuid":"a3c66859-6502-4075-a6ae-6a53acfb6a2b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014HWj3Gw5DeELtc3Sg3S8ge","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"c638f10b-bc01-4cfb-9049-161c5cdd34e0","timestamp":"2026-02-14T12:16:28.786Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->","newString":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. PromptLoader                      — depends_on: []\n3. TaskStatus enum + helpers         — depends_on: []\n4. SpecAgent (Phase 1)               — depends_on: [1, 2]\n5. Orchestrator refactor (Phase 3)   — depends_on: [2, 3]\n6. Test-Writer (Phase 5)             — depends_on: [5]\n7. Entry Point (Phase 4)             — depends_on: [4, 5]\n8. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #2 (PromptLoader), #3 (TaskStatus), #8 (Prompt adaptations)\n  Wave 2: #4 (SpecAgent), #5 (Orchestrator)  — #4 needs #1+#2, #5 needs #2+#3\n  Wave 3: #6 (Test-Writer), #7 (Entry Point) — #6 needs #5, #7 needs #4+#5\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #8 is pure markdown edits with no code dependencies — safe for wave 1\n- #4 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n- Merge agent is part of #5 (Orchestrator) — uses merge-auto.md fragment via PromptLoader\n-->","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. SpecAgent (Phase 1)               — depends_on: [1]\n3. TaskStatus enum + helpers         — depends_on: []\n4. Orchestrator refactor (Phase 3)   — depends_on: [3]\n5. Test-Writer (Phase 5)             — depends_on: [4]\n6. Entry Point (Phase 4)             — depends_on: [2, 4]\n7. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)\n  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3\n  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #7 is pure markdown edits with no code dependencies — safe for wave 1\n- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status\n\n**Crash recovery**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### Agent Runner Pattern\n\n`runWorkerAgent()`, `runTestWriterAgent()`, and `runMergeAgent()` all follow the same pattern inherited from the existing `executeClaudeCommand()`:\n\n1. Open a PTY session in the Daytona sandbox via the SDK\n2. Invoke `claude -p '<prompt>' --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n3. Stream stdout line-by-line, parse JSON events, log to file\n4. Extract structured output (WORK_RESULT / TEST_RESULT) from the `result` event\n5. Return parsed result\n\nThe only difference between the three is which prompt they receive and which output block they parse.\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox, checkout branch\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)\n  5. Return combined result (stage + test summary + merge status)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {{TICKET_CONTEXT}}\n**Branch diff vs main**: {{BRANCH_DIFF}}\n**Is terminal ticket**: {{IS_TERMINAL}}\n{{CHAIN_TICKETS}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n","structuredPatch":[{"oldStart":5,"oldLines":22,"newStart":5,"newLines":24,"lines":[" "," Sub-issues with explicit dependencies:"," 1. ClaudeSpawner (Phase 2)           — depends_on: []","-2. SpecAgent (Phase 1)               — depends_on: [1]","+2. PromptLoader                      — depends_on: []"," 3. TaskStatus enum + helpers         — depends_on: []","-4. Orchestrator refactor (Phase 3)   — depends_on: [3]","-5. Test-Writer (Phase 5)             — depends_on: [4]","-6. Entry Point (Phase 4)             — depends_on: [2, 4]","-7. Prompt adaptations (agent2-worker*.md) — depends_on: []","+4. SpecAgent (Phase 1)               — depends_on: [1, 2]","+5. Orchestrator refactor (Phase 3)   — depends_on: [2, 3]","+6. Test-Writer (Phase 5)             — depends_on: [5]","+7. Entry Point (Phase 4)             — depends_on: [4, 5]","+8. Prompt adaptations (agent2-worker*.md) — depends_on: []"," "," Execution waves:","-  Wave 1: #1 (ClaudeSpawner), #3 (TaskStatus), #7 (Prompt adaptations)","-  Wave 2: #2 (SpecAgent), #4 (Orchestrator)  — #2 needs #1, #4 needs #3","-  Wave 3: #5 (Test-Writer), #6 (Entry Point) — #5 needs #4, #6 needs #2+#4","+  Wave 1: #1 (ClaudeSpawner), #2 (PromptLoader), #3 (TaskStatus), #8 (Prompt adaptations)","+  Wave 2: #4 (SpecAgent), #5 (Orchestrator)  — #4 needs #1+#2, #5 needs #2+#3","+  Wave 3: #6 (Test-Writer), #7 (Entry Point) — #6 needs #5, #7 needs #4+#5"," "," Notes:"," - Phase 3 (Orchestrator) is the most complex and touches many files","-- #7 is pure markdown edits with no code dependencies — safe for wave 1","-- #2 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)","+- #8 is pure markdown edits with no code dependencies — safe for wave 1","+- #4 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)","+- Merge agent is part of #5 (Orchestrator) — uses merge-auto.md fragment via PromptLoader"," -->"," "," # Plan: Agent Pipeline Enhancement in Napoli-Matcha project"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"a3c66859-6502-4075-a6ae-6a53acfb6a2b"}
{"parentUuid":"c638f10b-bc01-4cfb-9049-161c5cdd34e0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","message":{"model":"claude-opus-4-6","id":"msg_01WV4UPn2JCg9BS6hEwJskrJ","type":"message","role":"assistant","content":[{"type":"text","text":"All 12 issues resolved. Here's a summary of every change made:\n\n| # | Issue | Resolution |\n|---|-------|------------|\n| 1 | `codeProducingStages` race | Added `const originalStatus = task.status` before mutation, used for check (both copies) |\n| 2 | `writeResults` double status write | Clarified `writeResults` only appends body, never touches frontmatter status |\n| 3 | `numberOfSandboxes` vestigial | Removed from `TaskRequest` interface and ticket YAML example |\n| 4 | `Backlog` unused | Removed from enum and transition diagram |\n| 5 | Merge location | Replaced `tryMerge()` with merge agent running in worker sandbox using `merge-auto.md` rubric |\n| 6 | Prompt interpolation | Added `PromptLoader.ts` section with `loadPrompt()` + `fillTemplate()` using `{{variable}}` syntax |\n| 7 | Sandbox setup | Clarified orchestrator programmatically clones repo and checks out branch before worker starts |\n| 8 | Phase 5 separation | Moved Phase 5 after Phase 4, removed duplicate `dispatchStage()` and Files table |\n| 9 | Two Files tables | Resolved by Phase 5 move — single consolidated Files table |\n| 10 | HTML comment | Kept per your preference, updated sub-issue numbering to reflect new structure |\n| 11 | Undefined agent runners | Added \"Agent Runner Pattern\" section describing the shared PTY + stream-json pattern |\n| 12 | Crash recovery | Added retry-once-then-Blocked policy, no timeout (Daytona limits apply) |"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1037,"cache_read_input_tokens":84930,"cache_creation":{"ephemeral_5m_input_tokens":1037,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7woo6LnZU85RTMrtXzq","type":"assistant","uuid":"91f5d65f-2432-4da2-a9e9-877b1aa718f0","timestamp":"2026-02-14T12:16:41.478Z"}
{"parentUuid":"91f5d65f-2432-4da2-a9e9-877b1aa718f0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"b40f3698-4a66-4a41-830d-08ff285105f4","toolUseID":"b40f3698-4a66-4a41-830d-08ff285105f4","timestamp":"2026-02-14T12:16:41.721Z","uuid":"de306848-7d1f-4da0-a4c8-f661901fc645"}
{"parentUuid":"de306848-7d1f-4da0-a4c8-f661901fc645","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"d0224bdb-fc4e-42a6-9e8e-4182062566c8","version":"2.1.42","gitBranch":"ralph-loop","slug":"iridescent-stirring-torvalds","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"b40f3698-4a66-4a41-830d-08ff285105f4","toolUseID":"b40f3698-4a66-4a41-830d-08ff285105f4","timestamp":"2026-02-14T12:16:41.722Z","uuid":"207df5a1-3f28-44d8-8286-30c1a024042f"}
