{"type":"file-history-snapshot","messageId":"b90e4500-cae9-45a5-a364-0917b6ded306","snapshot":{"messageId":"b90e4500-cae9-45a5-a364-0917b6ded306","trackedFileBackups":{},"timestamp":"2026-02-14T12:17:08.068Z"},"isSnapshotUpdate":false}
{"parentUuid":null,"isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"SessionStart","hookName":"SessionStart:startup","command":"entire hooks claude-code session-start"},"parentToolUseID":"d5f8cb97-cb39-4e7c-abe1-240b9f9fd49f","toolUseID":"d5f8cb97-cb39-4e7c-abe1-240b9f9fd49f","timestamp":"2026-02-14T12:02:46.936Z","uuid":"41f658d3-a27c-4f47-aec5-090385d1a2bd"}
{"parentUuid":"41f658d3-a27c-4f47-aec5-090385d1a2bd","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","type":"user","message":{"role":"user","content":"Read through @IMPLEMENTATION_PLAN.md carefully top to bottom to read back the clarity of the plan is aligned with the feature enhancements I had in mind, especially since I have edited the plan indepedently multiple times"},"uuid":"b90e4500-cae9-45a5-a364-0917b6ded306","timestamp":"2026-02-14T12:17:07.630Z","thinkingMetadata":{"maxThinkingTokens":31999},"todos":[],"permissionMode":"default"}
{"parentUuid":"b90e4500-cae9-45a5-a364-0917b6ded306","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_011As75G95LNj7Cni6KEwiz2","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":21368,"cache_read_input_tokens":20020,"cache_creation":{"ephemeral_5m_input_tokens":21368,"ephemeral_1h_input_tokens":0},"output_tokens":10,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wrhFSZ5CJgAvoqWBbp","type":"assistant","uuid":"011229ed-3840-430e-a647-4dab29d9b7f1","timestamp":"2026-02-14T12:17:12.035Z"}
{"parentUuid":"011229ed-3840-430e-a647-4dab29d9b7f1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_011As75G95LNj7Cni6KEwiz2","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to read through the IMPLEMENTATION_PLAN.md carefully and provide feedback on its clarity and coherence, especially since they've edited it multiple times independently. The file has already been read (it was loaded in the system reminder), so I have the full content.\n\nLet me analyze the plan systematically for:\n1. Internal consistency\n2. Clarity of each phase\n3. Any contradictions from multiple edits\n4. Gaps or ambiguities\n5. Overall coherence of the architecture\n\nLet me go through it carefully.\n\n**Overall Structure:**\n- Horizon Agent Instructions (decomposition into sub-issues with dependency waves)\n- Reference Architecture (Horizon CLI Agent comparison)\n\n\n- Prompts Directory mapping\n- Full Pipeline overview\n- Phase 1: Spec Agent\n- Phase 2: ClaudeSpawner\n- Phase 3: Orchestrator (the big one)\n- Phase 4: Entry Point\n- Phase 5: Test-Writer Subagent\n- TaskRequest Interface Update\n- Task Status Model\n- Prompt Loading\n- Files summary\n- Verification\n\nNow I'm checking for consistency issues across the document. The Horizon Agent Instructions section looks solid—the wave decomposition makes sense with proper dependencies, and the prompt adaptations task fits naturally in Wave 1 since it's independent work.\n\nThe reference architecture clearly shows how the Reader and Writer agents got absorbed into the TypeScript orchestrator, which aligns with what comes later. The prompts directory has a good mapping table with a clear pipeline diagram and specific adaptation guidelines. The full pipeline ASCII diagram is clean and consistent throughout.\n\nFor Phase 1, the Spec Agent's clarification loop is well-structured with five clear quality criteria, detailed variant handling, and a straightforward ID scheme using FR and AGI prefixes.\n\nPhase 2 with ClaudeSpawner is straightforward—it handles the dangerously-skip-permissions flag and does streaming JSON parsing. Now looking at Phase 3, the Orchestrator is the complex piece. The processQueue loop runs continuously with a worker pool, and each stage has stateless workers that hand off based on status. If a worker crashes, it retries once before marking the task as Blocked. The Spec Agent determines the initial stage based on spec quality, potentially skipping stages. The filterEligible function resolves dependencies and stages, and there's an isTerminal check that appears to be cut off.\n\nLooking at the rest of the orchestration logic, there's branch naming that's group-aware, and the agent runner uses a PTY in a Daytona sandbox. The dispatchStage function is stage-aware and coordinates with test-writer and merge agent subagents. I'm noticing that the Spec Agent runs locally via ClaudeSpawner (Phase 1), which is consistent with the earlier description. In the dispatchStage flow, a worker runs the stage, and if it produces code, the test-writer runs afterward.\n\nNow I'm checking the Stage Transition Diagram against the actual dispatch logic. After Validate completes, non-terminal tickets go straight to Done, while only terminal tickets trigger the merge agent. The isActionable check filters for tasks starting with \"Needs \" but excludes specific statuses like \"Needs Human Review\" and \"Needs Human Decision\", which means Blocked and Done states are also filtered out.\n\nI notice \"Needs Oneshot\" appears in both the stage prompt map and the Status Enum, and the transition diagram shows Research can route to it, so that's consistent. However, I'm seeing that codeProducingStages is referenced in the dispatch logic but I don't see where it's actually defined.\n\nLooking at the variant example, tickets flow through Plan → Implement → Validate → Done, with only terminal tickets creating PRs. That aligns with the architecture. But there's a gap I'm noticing around what happens to \"In Progress\" statuses if the orchestrator restarts mid-execution.\n\nThe crash recovery mechanism says the orchestrator retries once then marks as Blocked, but that only works within a single `dispatchStage` call. If the orchestrator itself crashes and restarts, a ticket stuck at \"Research In Progress\" won't be picked up again since `isActionable()` only matches \"Needs *\" statuses. This means \"In Progress\" tickets become orphaned and require manual intervention to reset. Let me trace through the retry logic more carefully to see if I'm missing something.\n\nLooking at the PromptLoader section placement — it's defined at the end but referenced earlier in Phase 3, and the Files table lists it as a new file while Horizon puts it in Wave 1 with no dependencies. The ordering is a bit awkward but functionally it should work fine. I also notice the `TaskRequest` interface adds a `featureRequest` field for tracking the FR-{n} parent reference.\n\nThe file removals are consistent — both `agent1-linear-reader.md` and `agent3-linear-writer.md` are marked as removed with the same explanation that their logic got absorbed into the TypeScript orchestrator. The Test-Writer phase is well-structured with its two-tier approach (unit tests for everything, integration tests only for terminal nodes), running in the same sandbox after the worker completes, using vitest, and outputting a TEST_RESULT block. I'm noticing something about how the merge agent prompt gets built though.\n\nThe `buildMergePrompt()` function defaults to loading `merge-auto.md`, but the fragments directory actually contains three options: `merge-auto.md`, `merge-direct.md`, and `merge-pr.md`. The code doesn't show a way to override which one gets used, yet the Merge Agent section describes how `merge-auto.md` contains the decision logic for choosing between direct merge and PR, implying the other two are sub-fragments. It's a sensible design but the mechanism for selecting between them isn't explicitly documented. Now I'm looking at the `inProgressStatus()` helper that's referenced in the code and listed in the Files table. I'm checking the diff table to verify the plan evolved correctly—the loading behavior, enum structure, and status handling all align with what's described. The main gaps I'm spotting are that `codeProducingStages` is referenced without definition, the `inProgressStatus()` mapping isn't explicitly spelled out, and there's no clear handling for orphaned tickets if the orchestrator crashes. The merge strategy fragments could also use better integration.","signature":"EpRTCkYICxgCKkBsFU7NVvbPOIlvCTa7etsoQdLP9qK8eXtbgp8YB4LoBZQEQMu8VuL/TL84QyUt3C1hsiK1hqjI28mjApFVM2k+EgyL7rMLdy/cQg0dciQaDJ6p6Q2zQUyRxXP6hiIwCYOI/6BSibCjb1bbBY7eM20+nsZ4TsvynK+ZEbzIfVhYblZxnZRZnFzJ+Dka/hWNKvtRkeuQfzDgluE1BJ2fR+yMEAkaZlMSPDOMrYSiGVVl300zesIOBQCPsrnbpA63zCzbCP1buBm+zfMxbMd1zL6Su7ILainTPbl1tjI/uoOH27V8Wnr0ttEVZTMwIcD7O8H7Ng0sWXKhQBKjQF7pF5I0p5fGsrW7CNClIF2ZkIocyKEknhhJgERsi+hU2giMCPqp2xXc3BRDAQe9fdVGw7EvON3J5W4N88q8VHvVDmyUzKNtTjOkT4Zuwqc72ZTGxCGU+lOfbgMjykPBrEJEgH5c18yGWMcAQYRuKsVzALrGD0uGKqS2d+gWdG3lPnGyes1oAx8caOJEIHfkLg/byZQXc3sOMXFnURZCsnQmjni448rkaobTEKEEO9QehJfBdgDi4TiyO4cI59yS2hRj3QdEjzAfu+NbGPshMrxHQyu6R+lvmTtfUco7DtF0WpV8jvLE2miOnf+wF637U5Vic+RlBdEO8C37DkeZDEHlXjMWxzOk8+Kiwf8o34WBMjJt7kkrpwiSXG9P6vOpXTIbaiWDWOnqG53o/Trtwcx7EUSFUN80zCL7yMQYgftVmymtytBKFpkkwh7IK2XUYmgG3m7w2tWHtuB3ZKDlqMnky5Ul+qsnf2BM0775+jhdVm6+nkpCktOW06JRlBbgpPOijWX/PoviLpC4qa/ShRtKmWNrY6jsPNKb79l3NfL6YBGEUwMdwqYum/FNQZyLjVdaBhy55xgeK4I5psv7pWjPoXImK68stvFgLuhR1AsFgqkgDcFG6xGWOoOic7/RX4e6thcU0xUngGHV/b3veTHluZXK7L+rpO6zWQpV90zdKkXVm3Mvyh89mph01sWtlcDJoFlvDgJC47HylEAOQVgtL2077Jx0ZR6SrFqQ/MlXjRMNyt9duryOVfUqcHH6sm66LCFDWvKEfNPV3MVASWv6w0/KU2bjg4BMot20+hpyxXb6Lsyu/yzoVlwFJuF2E5UYXCwe+p+kMJgdA+HkSU0/sbBn+pbr5PhmvX8ZByVf1+UGqDtXSuhjOcV9AeiHfsalXtCTJOCAcVLKByu5PVyNxOFXzNp9LZo35adk4mt2HG8TOXRq9bYRmvJArtnsFqFQA4TxnYDo4JrEWEeRlBI0HyMarIl4mf7O3qPSMmG7KDZgTWWRPXLNZOMMrV3hXQLUHoDQeBaHZ5L8osjAC9bdwyOb+n7OhXLEgK33uISHooq6mY2McQWvmDnUVJXZSyOJLe79q7J8s537dc3ZN9maldasRy7fyiIIZdT5D41pMLmxNY8CUvOuo8Xxp+4+btNeitwY/ZDN8p80FsrpTuSgSFl0++4UH+oJJkIS8Fz+X8bVueSa+MAxH3/qLCTDk8gjpRVqDEGvp/DQzMIAiyS19l0aioCa33qXzw+P7/0JyA4YHGOpatYO73wuxI7qRAEfSiEn4Dfp+qxeZk5ycaOuE7lbb4mphWVSmf/HX596cjoXqYxGXmJm0Vg4NRygN2ek9Dfk7NLghjJ0QLi9itIyigDjlw9NRdcy5tDk+d9fV7MhlA4obLK1ciktaUMNTZciktY5s/iCzyri9qq2ZwJsHa0iZeh6HA+oosOSj33ivMt2iHXE1CFelIELERBIwXjTcmtpMXFr6hO8VaBUCpokpTqjC6Y/39umyRNttKe3MGqZTmgjaOYeRIydge0UBVCKUr76RROkJZr/HHSfZOazX4lnhEV13sEb5Paa12YpN6hlLZaOJPInu3FewJDW8S+MMUaFM6tdZ61JRUhYVd79nNBiiKYHFf1/E6tg7HTv8PGqy5nmukHJzf2HQCoZFSjGSlBZj0Ij5nrSuykBovpT6DqZIzXtZbrgHMIrMIGggdHBsitfvcLtV2GZekA4BIrB3HjiVcsG2wXQvBui5ttderRfkm4LZtgLomF72rg0IaVwZ5tOQCPjpdwZa9uoO+G21OODpJnGsAe31GlaJxjYAoBgoF7nMrd3Nm7Pz/ZeqoV7kt4OrnsrDpEe47lEZhtnAb/4RK5hbXuh87fXKAyd2C5q7bg425FP3ca/HQqtQoX4jSeCBhHG8Qfb8PM6nbqsaQxAK+fLd7IGNnh0MuyBaqJIXuvMyQc5i0H4hjkvOTOBBKOy6h9SsN+rIv17WLdaAi91VL+5fz7uHBLIQwiYrS5k7xgrQRvWiAZr/XT/FYGjB7H4/BH0FKclBLsy3KX6F9bJKBCs2fhjdADtwNkUjgmlRJB8pOF/9ApR7ZoQRFNcN/F940bAgByvMtFU/mzI4hniYfrtT1yB2PZVh1zKARLoQ5JgnLk7t2/3X8VQyzjNtcTbow/gDrdeKsPRZU1vMRVRIhiNbJgaADO/I29JWwzFbFzNUF2zkhDomkxpswlYJC3urt3ar7lBfz9wHIx1zCr8ObLdTxqlhvu4QURGiqbOVXC+tp6tZv9DvlNtbIoPhkPfIYShoAq/Wzw15/Eag7cuNUhHBuiSHFcsDAUqWQlyyBE1zy4K5cDL/pKQe/JoGUX4G5FmWMEEujHrAXo+3dFnokGEVforPsdA7gScxUefqze9/OmOyXbyiGOdw4GmVWzDAKnkOR0PTEhNZj5SEnA3ykyXQPb0ojnzskgU4w4o2kGHjKob14SmYn+dV4J4XTl7S72uBwwAadDkXP/+0Jc0Vn4L9+4WPiFQcaxK/8CgWnzkxR5M3ukPHfAUbGM7CKsMuKJxUJ2vG3xd2OdlsfUH2ZQYM7svNNMvI4ul02e5iOKOunNBlf+accIu348vJRYnFiVSnbZRLBS2UIPzOjdUC7GaO4sgsvoY8WbVSnIU2syFd8RC3BWcMG73TnV6k+taaSrpDTX1/lsP7Z3Fj3x8tOXN3HGtS5igFrBSmrqDA2d17+WUXiuaemRcROO97ez9qaMoPcnG6dkC8zzFJFaFjqi+NFitPK+gk9oOa9apONHd2KGGIZw0FJYAqv8dAEtfVdQo053gzxHqC7crYThamiKZtZoU2CTy4HcO8kZZOZduab2A/oYeXk3Rfpt7ZZm0BtlFBVoKbD+gnoJTBaYIL+dE1JT629CyJGEBK318w6QPYKklEM4nXa7nP2i7q4qvW2B6OuARTAZIemieo4geweM473gKCizNjUiArA8+AsjAZ1S5QHQkgkzgj89aNIVoUJM9+K8Fi/YIJCTd3lvklwCzxh6SurhfnSPRBlqbnlc1QEqycD+SC/JOjcxpHOf2eyygO1Fit/xIo2qCIl9cr/yaS8bxuLUJwgVeyLweBU0TTqedFJNa6vNNLj/JK+ZrtAaKLbKomhAHQLOD3hq3XkZjUBJjSpAKG6cTkB2WMwCHc3j8a3HVAbVBZuPiipWyJA5VvYBoKWcoS7yrsZNqDxDVW5uGxez+vQ3/lqLMT/qWzI33f0xzv0k4QjTpIASiJLvUOIIeQvMpd6kEOIPowsfs/D6ra4Q36ccpJ0XPTbeOzm3CRONgdNIvPkGZEQhztswZgJjSNypa6uX1bf8C3Q+gnygiVwWgrQHU0zRWUl/kP6Nh+k0HrzbRa3S7ewFA+Mazj6IhXeZJAnZBag0ioKGcLQadDfqafmpc0pPAeqMomMmRlW4s9eYs05PIv3EVzMR1whaBjGt9wA8RtykElhrvqaa08NNGVMclR7ywos6WLH9hczAdF/8wP9WTHdRQHaxoyqlY4cbqKXcu3AT3vFABhdCCWQkyMxMEWjynOVvm3F1TABfvwQvLP3dDPQPc6BBEw3clsALiyntroY4gWG2pIyfEqzjGez7G9o7QpyZ2xBGOUwH3HuFjPGUs08CajocIxlWIQYHshXr3Glpd/27WwmS3Nv4vSKR/SDPlIqTiS0KVXFOizwWZnu7n8HtONtgk0QQIsc10oPhU2OsV/fQ9mcRazVKk5nE2e5peVHF319HWaGBneeVwoiO6Xw5DDhPySd4FoClj9Hxf8J4R1z9wRU2vwSrPhyzDlb76gJfJsxumi4HF45hPtz0K//AO+hqAkx7dSGcyIGDfsn/qUUAJHm39p/aP3OYKjMD0yixXNwU+MgIz/sBiBFss7/5WjYP/cBFCmbG9oWR+wZxak3Qz9z6gFZBtueGgqhKgxD6m9rg5rLkIQuyrCUMigkKUQxOPDT9yzAs7EpMYdvrjfny/hGBeIF1HQdBxSdR7cP+jJrXBqlDBhJtMIjFTrWijovuULd8OUJui5ICEwS4w6A8HQVoci+tYHnjn6CV+jkEE9UKBz6UdLLvGZopvtWQGWHD+8CrwaejTm8fpYdZv5oGp9O4gFvasIbKYNtBBEmfEVytJW+/vBP3R8/Fuulh7aZ7B3qGO3Fu03RphtdESmVrUBwfN4LmYe4f848GgdTBbTUeQx6sFhxRtGx5NrpoL/w+u4QkyuOHuunI6BMaXu9FE16qbjkCouwh0Fgy/7GHszL23iklSHCGFqKEvzPBcU5hsi/f+XQCGFM4uiyYRyNphqFIR4S4l48ldmIOBBepPHepAv7PEFbq//cJXILBXGMmpa+CFXojFuPo0ceTv849rVSDvP+qyTIr7DdP9wQkHpmOVgoLLJYw2N66c/TuIT/JWPkKjBKsDgbGNDpaxpVHprU2AoCFcSrKRB7tqroOyhjEOMpJPKUeekM7gy+N+Zdu8EzATD/ZxNMVyiRvry/BSVgRj4mQDaG7jDIxfpyJ9MVql987pNEkFZ2So5mXm9Jykw2ZYEy+ljaPPwXDhpD5BC/gGjyq52tS8AliqvuekgixmLu8U7D2FP5HfoIVI6K63BfRz7YIkG7tvTwtVFupbsidfqBtk8vlEiD/MLgE1Gs4Nh4IzpAi+JXJw13bWncE7xgL20VUvD2oNWpyVw5v2rQWSXZggtsBde8fcT6/adbyUkFDzh2RZ/OUKtJxgMYJKU1r57HoZ5oWgpfzTXGRs1XW9QDLUNHZL5MUFQtckZSkxzDO3PVzmmSrtDXyHqUgIxqtYSq/wtP2gpnlkEfYsXUOgwyKG/Oimw8Y8LGlCHIkDxbQAxzTbv5iqazuc52oN+fCxDNrLbtgLAdZd0e6JynIwbmX1copAUVLkUd/CaigjEjahfYFZ5L0DKj11RsV4zkedhvbMGl5tJOs1pNyCY5nDTeteT+nou6CbeeY/7QjJQDxIlHH1JLXqB+VPYkMLO9oc/dsK2V+Rb0M0StqYZ/EPo2Ml5GCVGXcP9n7X7ZxJstNvpbvSt5M8snv/W+4I2CJ2EqqMmqjXFYZH5cF6gfMljge3Xe8Y7CLKqGTo7MwsWjxLi9l/MIVMIJFScWmUuh4WB9D/6dEnSPGS08e6oIOrBQmoop8SZICuYtHR7s0vFCLtN4Tt6r3zibv0RzoIxwVxR0pkE+Uy1hXLTRru1co6/Ce5XMzdPeeRjexdJmM1IxrXIRdU1LAtX4O5vjkj/j+0LplDXiebXVS0NSRnDCwohgQMXin9B89YopRW3sEwPZx1MyqnAMq2uf3bnTkrTcITbaqBWCL+b3Jk7yNhmfDfF87rPIjnOn2QigZ2mvkZozvzgVrnvvahBG33s9vU8zl6g1aNX9xT+U9FiTxEG/NABXyw0TbRxHeCF1qsw4lpfqP//UEnq4jYeFO9/5wMYP5UZx4aNSCTe/IA43bcQ3foCb5x6Y++Tf42kMkI9HlW/B+2yIUkPB18JA6q83IPGk2YxKXqEtXZqSfrhVySntQYpfXsIy3mbayAUVe0yHRwBZShWsZA2cGJGkPQ7tBLITLACU7PUPF+A2SyW95y1tZppwCXdnqyV0tRWdpV6K4nmVCyguIYkZxHkNgAz6OsSXqKn/G0kgPQ4daJs/S0wCv/qZujTBcD5tMcnU3KZOJ8G6M8EI7ZOiIiHS6h2B0HT6ertbk8SrD6V4QneiZ/2oWd/Nyz/cmHC83/c5E47WHg1HXv/DuBk/XDOg04UFKcu0XBwM0Z4YdVxdHGoBGfpR9t9WxW0EqH7dT06VDKCCM9cGn4jfaX8LqometwfXYGYKhMPkVUvIaPYSyz874trUl/6DmUboIaynfLq3cl+Cke51fjdG8zT9lmWhCK95YH0LAByRc3lrMHlY8qwwh+UGWZU6lkxwRBYrTCLUbZEaEbhpUz0pPfQVm1GyNCGXLTkRtAiYfzPVOcr/QMDgNiKnM5KHd0k+ja99JNxoViMBMN+yl+OVOSe5ftcRSN3+afYohALMzVCf2bQeidZvDcRwO1OOeya2Icc0Tfe8KzuqZbsRdlc/JRcdOkCFHKsZRwstEbVIoazxrWcqmjniKWelgWQO6glJpps3eYJbxjrll7ZjFHHGQZasbGlTR+yqLg/dSvZDvAA3FbG7Sx9Wb6k9Cl/FP514xsD25/3sLSDhQyKQ3MddOZdjgMGOy7n3KZHPl6JA0YWLe+rAfC7qqeC+MkNk62BbC9ZtMHN1XTUo/ScjGKFChem0c9eXCLxi6lvD7POY1s6Y/hIiz7Yg1Vc0TN3vHyfAKhXQ2RkI2SA6u93ADU7lOrDBcwxGZoM8/O5MKrLXhlPMunsZw1UqgGkBlPU92/R8bdg2DFXjdY6xm/mX+vsvTGEZAPEi4FOQZSmyca3mP9YY4ml3ifpfU4SsMoQrDy7MsV12cwRelSXunBG2I0QDTTjqIv8GUHbCOUKxzWAiMGZ9cN7jAM1OJnhMmi+95VEpXUGZzDeiInHXns7oKjQo3eMExzwgQtgFYcuhlmwWikd8+/TnGbRIlJDZbJz6wpLS614YBoM3QfxL2tDspZMfPFbT0i4bIcLImwZm6YQIgwocEexmZ1j6LRkKQjWsvLJ7nlMCDy2B2zUOA/LeKzMJzUs7e0CC4ZMwyLUeEpQeZFwmJUG4j/YlSWl2a8wulgslKuGeade4PoSh3fQyp7WonLQdbvUhBj60kWGvuYQEvrUn2pbJouaYC2kjG4kWRIV8auRLoNVV+OqO5GbPwUV9h1fCaaHWWOLRoM1unrAUZJj9aHZJ5GnENlG5fsVv/IV9DwlMIQbUqIgfR5wm/90+w7xMboFrm3t24mIS6OD1p+0vlKqoaUHxfyNEIrqnOgg+08iUc9yaSuuAK7jhmVvnn3nei+DwwPCXNcyABzrrvVeo//2scHCPVQpFZYdbmPKnfpS0V62IaGjDAYn+0q9zpXZtGdnyASOrv2eAWTNGXU1zXmR2hTyYoblnqMbj+4snCD2NDFKLDPDuj5J0ttEDaFtZAFTYkEIn1KhdeQ+xCP8u5m9XwphWCztWOKnty/xoHG68Ki1SsrPRTpGDaSBsCPeEdaUrRL8zt+k+GJzdjBbFBkX6iFmK94xLfG8TOcxBT1ULSL5BsAyk+aLtpPlmQYUnP8QZANXoHl2vzj5qhJf8JfqD3QL7yUAgxFuNa2fevDaV3UNbf+g+k4dYuoAVXduhVa6gRpBcM1g+R5xdnxlJhd7uxX5SOexzFi7xX5Wxh5f/vo/18apgsmU3iicfmtT0WWsvoODt/OSrlTaxZ14YqQ0lJr71wfobdKAbC/HOAD5Y+VmOmD2q4jM6kdNm16UIGvT3tzTVWTTiSBZR/dNAdJHJaLkiuSeoBwfxxO5SY8OKuljAUswyJuLfpAyxSREzA6s2MazDJNkR/2xPtolBjgkw4Kibg8g1F1XICk1pNif4pm8mINsEvzY+BbPaUVZk/qb4+nymgUzvGPOMlr4L2c/TRoUIPPe23QRqoAzhJ7FjGrqYwJIzHWfupKWqtLGth55W3YdjIOhlVlCYju6A/WP3AjUaCPrSJrdpDrhtCQwKZivvyhBMCQmPq6v4+AsJXrnk9wEdX5VE1gqW6nYED5fVrhg1nxM9MRZkJXribdl7Bj7C/NStdPmyAPK6B3NwN72tOYrs8tt1spD/ov03lDFW4UXPPduQ+Q3ujOylJeczB6Vq0YkOBhq3CkSVYvku2/LemRLBeSIckCxqT99ZHWVfWazoGnwFVnoCeMGkIPkDtDzhWZdZxGiSKRYtAbBCCPWYZ7aJksKEjai5VmnGBAFT3LoQygotjzah42h4B29rnW95fOmYYZQm0qstFTlfqwwzfGA1P0ux3y4qwO8WG+bT3WRhYbmTm31q0OqzOoqwoQw5CuEVWMTu8XqkldbT7Lp7l7M9LngAigNQM12nF/FSK8G7UU0Z2dFlnbZTYJCVxHqVPrgZP/b+wAKrDzDYWi4hsAZAWF42UQ891rx3kxjEO8BaH0sUkd55LxG6hgmy0Ha2EwkuRajO9RqjwMlt4+cAXEhlVyJvNjxe0EO7NGabcuWvPTT140aQ1O+kN9AL+OW3P1eM1RnCy/om5qHQms8LGih4cG+LpkZ/6w/pKAxiweSYSmxULicmxfX8zt2S3+1Xz7CgNdZz8uhqEY+erqbXF4T1s25OftCIUJwusrEozUgx2MCcGhJDDc6veMbuwFRS76WGYFfzGjovwta53wRwgvXbrO3a/UBz2N3fJTQNwXeVVQyKBMnXrprYB0RoQMJticnJLNS+5z3edNJOVQ55kQnNxzGGIqOtI+cqC6733L0Z2FQYK+phjvs73pr9pOHRHtOIBvQyN0gD0Lv9ZSTzaebzUuj4WJy6h/Zg2o3kY6YXDzwTiRmrUQYzd5kEmIhRQ2CWLW+d0xLvd/DiDs8xL131jUcDT2PFDLh9Vp0BDwlgqJry3Q6FejFcev7hKAYFoWTcatDKwtfkVq7D3oZeOZyhFchw2+iFAfku4mPRcKaW6DCTg9l21XWtZ6pKgRPcpib48qP6wEKV7t/my+NELoZhCJ3QmF1UVYHAA2gBoQzKsU0DCfTSVeaxl1HlzjuFMMLUPSSoWrUnyokPby2bzjJBWFB8n/V0wmnU/U6+Uslr4lG1LCdKEUrwR/BkDtuChIrMy/5FW+KEVbRqt2hT7eIvdnOISJe4LCLd8keKext491Tx4xY73yUc9sMmfG4grO2txvcYwIT6L3eAyvomZezFxWgT/35GvPWEYUefPc8d4vSHGOLaA9JOdd3phKeZlxdoAfKrV6rqbVgC6lTAf/3Fed8xdxCn4xRVnFkvxQM0KGjy6Mb/3ZZ5aue4ZPMC+uXCvlqCTa7pasm6wbBhBb96PJ4dnFPIy3OxUd0iYWtsWmpdwXc+IRfyj7ognq3tnYvd2mSNamMs4VtBrSbeO6PW5IYWLr8F9BY7HnRQL5gvxvXqALR2NH/Nj8d9eN2krBR8G4YIFYKBB1KKScyz/8GvYlsfcAnEDnp+5+3i0x9FQl0O+gNfw3i+32BTpnvsZKnNWjWrO6HEJUb/ECIcGQ1O9ubQKCE41izQyNoZsGELs3UBI7fs0RPsfx8HC5b8HahlJb7fIjKTQZm7GBfzcicDXgIKaZ4MGahlHDvKyiInv9T4evwgznZzTea+zhh4TMmUBl6TNR7xd8gN4NMRpyo4fwXhHLJT61gkonswffXt7PQ9btIZvsQGlUpSq4NVcEGs5Eo7mlABM37zgrT/PMiHAjooRsUxULIEQNb5lKsO+/270viK204yAviAcRFbHL4JvjC0LTlj+e5rrrZePrzuPy7ynsS/LuUmxHer6VANE/PLvfCgpgZDxYIyMj5ZEhh4pQix5eILGDwCDN5rYGo/ZQ6U60XvMGDi+otO/WqugagcAbT4WAxobsfUJmSdWSpw/OMBz2skd+a5/ub6L43gMr6ZRSKhAniwOuFemfMMCO6wdOaK3TszHipmbD0HEYDGgDYzZUpwUHYq6MNWnHOtWCt+vaWNHYZsnGtE9z/Y5rIL/6s/ureWFjWbENf2YQhdJXSRnU4RFjBQWHyk56YttfEzS8gx635x3scJ5pYz5tpoosciiQqJwYINx1yPZmKSBKdPt14sqydn7XQes+4CbWcA95EDqh3yQz9LbqH4vMFmEj3rOORkvy9PuDV6vuU4sT1xpdVqoo/wOSjp+OS3Y7RM4U4F89Cb/r9FPpEfVDJ+avQAGfTiepDFEhpqy1jnn2OtstyHWccCK9/iXopZmfemtXVa/uvTSdrD49lt1u1c/fpVqD3f8QZPunYDXksYelpYKKdI8BPG4i5xnHIfTP4ULkkF5Lq2BLeIgRzCuMrm37HlgRBDD/uyZG0oQrQIzH9Aie5dwOSEhnQmf5pay1xpvaWaYOP3SSY+qxiapUaiPN9m64mCvMuVOE7yPJ6PlogrIUdTRqNstYSneC4KxnZGixCJukkmYtpP8WKU724KeRw3xehfYU6xxBCn+3lr+yI9Ou9aZ0QzxqsCOVejLRvWnkaLMqZwJu5X4vNw//Ao1m3/qNB642u+YADa++TMDMyzvlL1ka9Q0d/pGogTa1SHE9fSryikXm8bd2AlKHJHEigMNqePWjbvVs/tURew17FmH1jyTr1+Yd2X/nfWhWSO56MTEu0JJqyMf+qu08G1opF2SJQ0Vliy6U5Tznt8xUH8vBjHNuDM34cDQ4iOQzochSsAGvMdM8eTKzVr/oL+1KQiDLZg2hualMdjhGa6P7xc7Y5SLX7IemKobBOYns4/QoLmovgy+arK/DSDu5pGuglnHWZkAz9lb7p0uKRElGLpBj3RZ8b5j780xiq8Si17i3GN1E6UfzwkK0xfpUQsTfG4YlQarOJ4kaATjPxwfJQlXuwK1LHV7wS4SOqwqFTW5wfiDeO9CnPpFup7B+Sah2CqTTRXAE5TD/jCZZlS6DzL49n0cXr+XwcDQilQj9TrpwE5pnpwccLrmz3B7ZEzcpNZqjTX7rayYJ23qWJWsfw3o7MwHIcqBHvTqIeqPlseqqmdzBH+jfu2xxsSJpoppy5mm+FiChv60kJmZ8h2AcKZ1cY5g3dRsu29W+4e63MXYHVM9UACL83oH2V8o3aMw+WkpkpBeRTFRFONO9DsXttutUEOOo0UwG5t308xLSEgm46mkMxIpntnDUMBTGpsYZb0op2qnxP2/Sm/i5VQqRq8emG73X6F69aoXXdmt5Y9GiQXx1WrGp6FQpNSXQiEfaACsoQlzZIhRXuUUE8tyVxuo8Y6nIACAdHliNYuebWi8TkjEoHCewO2tPz9nBIMtDBcmMXHDm8jl+yj9LYUtMV4WFvYtSXLlXkJ+4X4Au4vY9eo4PHZdz2hXk8e3qJO+IgHVMSuZnDWHLfLbWikhuyJHyagJ4QoEeW3S61dKuIWjs2W54ofpwu3rVy3ZLXpU7KlIF1Z/2P7gMrLigcGXmEg8gYvVY1NDT+vAvzjLLrhCo/fH5zRjKy0o15bJiVjRfTz6f5wydKajr6TVT3gh6jiqtX0XC4D1C5WeaPfKHEnWFbTjyK3hlURE1WuxFFaSai++n/uviF8xJW4aM3mLYSmxtsPJ7a0tJqpXX5DdHHbAAZNAs7Qh5lguzhxuZ3XOgj2jzvcVx1rLCRriL+XNv+4ZLN1Hrz78vbCgU1pVZqfOe4VndpARDKerWzDh1AkrLdle3jlpjgp6YYMBqDRD2CyJKSRm20ZfgTNPQkZQwsk5B+ziHxWktMfgPX28Y9GsASoKuupBvHAAX/cDdEFoOY2jcVAEuIVQVNxvkAYN3xNVi0FPXgX2pkikgqNjI3tX1rXvvZJZh3Lu/KwfbGZVLv7QJwf7K0iLVo/P+vF9YnSN31EwoImr7fRFd1DTJECieEfROcdGxdMMaLuiHZzOnBnxNyaW9TdksSscpKwRa7sRTbqSw5M31KgN3+0TEPLi50uw5tvyqbIq10Tcj0OlQIbUYbc9lfARd6qboA7s6jjJ6LkJqUZTEH3+PBmsxXnbw9yHRPGlBkx+pm3hcE8s98q+84BZ9PzCzvDUFOcvOTja93KjUQIrYr2+Tz6otelfbirIqBiQzXUB4wehDxqV5pm3ybkXIXbzHEYfmmCW2vdsnJBhqTZq2A80OKu46wZ/mHSq4xI9jeR1D8p5xslwaL6QSiNUpSDXKYcxTPoObnzx5UMIDD/mKv6RuT4F2BAsd157Werc83P575NUgaxePAuMpBZ+hcu7DoAgCuLkRTN2L2r3fkxwy9wDBLQL+z/C+XIkbkkZhlOdxNNEmSkHxgorPPhxTlf3giwF92IT0lAJ7AQ658BMOJqHL3VRXDxboo/RxVACJ3iUhf13o8KwLCO+HDIcGIrLqQaenfyYtyCrzr9W1JW7VN/LmC05aZpqCfeyKbD+j8B1OdNXT6f1USJcEyrI8RQg21PULGGo+wyx+mQG38qQNV6SdfNEzaBWRpZPP6y80mgs02otQfepmcGxSr+5bsmjj+y433qI5Rp5wseG5UI8iav4k1Xn2mUZSArXjuXwaj4Qbh7ciVdQp2H7nAd1lHpUiVGJURe0DxQZznV45iAokrbm7wRyO1nVW+mIBI8a2kCGSwR+EhrHN5zKX0LFdefzzL8xMRFP26Z0r42ZA5f+4T5ssk1OAr4cX1s5jSiSeFfF2ivZ9AsyzK8T4G2NCZubt9RmxNO2jt2J1pbeYYKTTV+jyBbd3yeuBvVftkf/38SDL6mTk5cKbTHEBZUPIjWGW78DUC4o7TYFG0lLBfSLVqaI98K5AN/07qo/GKP34hVmpBL3z7h+yECfM5b1heS2o/xvGe6oHOhFBfX4PLuWpCiVkP6FEkbdEra63wkILPyQxI2CZ1gjVx2UXqPaV3cEXOd7Yfr4TYqiYBRziW1gXp/NTVMU8VKvWNEZndbrRMhBjlxus+fQtp6H6WkqCaqUrus2FdoyqQvDuidz3LHQLeAzZ8O3RNpHOflUW9WtfRmZPzrgMbRDDaBH2exT2J21I8dtLvWi+TwkraYlVziNC96k1Bc5KbHs/nYriaXhfdD0KFQM3oQLLXKr0KUR+SDUWGN/s3jhPJypWYYUjQGxlmF/Ca7Qm6gWKMAcN4DmpyDMdnHffKTL5zl7uOBD7+r3cQfhHt+0DA7sOlywsWImSDofbtMfhXb2Tki78YAowe74l9OYqMLCktTAl92iG2OojPUjb0g7iWnIY/2B2rz/6HxtRpWR522zbVuwhF4h5EsIsgeYTyL+42ny03x2as3whPjWYgLp2RJ8iJMXqNGkmj5m9KQZfTy9D8ewvc/MOCdKod/Two3TY7l44D3jVkXjbBi+uxeLJ7Q1tHHjYR8YQ1nnVVtAWwbuRwQKeo0fbSoqLduyvmaqnig0/JmdR5NtGvR/qTSGYPSCo2paHxZaLDpdFzEp67co6jxkZn4pg97p7qvyPu/e+UXMtXaRYnbgMLOdyt2122JNuaveMh/vLCh2qQVh37wZ5A4g2w7HnRPw8sbvgeSbMk6pVSjZaSlpk1wyM5g7nfKbLI4bc6DGw/Qdn+TY1aRsiqjf3P3NeGZaoX1ZFyrj0EoouQrZBWccM4bnGYMqp9M5qv4iXLaLP/G2Gb92TCfBApzfbURlagtCcUv+I0x2oPOXI3PRK0H5tJvBVPsOSFrrRiP96ccU4dfb5cVHsXtZCJHScmk67ChAYH6JbxeTF8yRSHHP4ddhBBBR8eAbvtlJvVICtLeI/zV8l64qJSyO5IbKGSKRGdGrALsXgBwF8UVF1LmQxIvl20fS59Te28u38W88+0pehQCIVlU2K69TLKprf4kK20g8fUp7cNXJamO0sqBv5FNgc297bvcD1E49JC5o9ZFtrRIubySXvjXh5UVrXYr+0UvfWsR5nIGJsYD34PEYvCcj+AaZLs9O3+YH7Ppcg77NYMjluBgeCr7iMgXXuXM+W5Fnkcx799FCFjbO06ddnb3DJ3G5ba5RVG+9gIvsAKk1Sn2Y8DIqP1r3BJUp/30HPcTkZ4QDf2YpNUISy1h64ZMxm7WESR8yh9eCb2LBGe7x0ckonLZQhz51CTWZPGCD31MKRIXW5gnsMH6m4LwSa8L3lMGfhPTQy0WtiVtoIY1IhVLmk/HiX4JKbI6g5etd+nlBROp4UbsQzfboe/HFvaK/BDAVIzOi6PcNyrG9OkcqvsHJLrfm82wkJMNET1Ug0y3+nj020b9aKFgGwoiircsO6dq9Po22DL7IDwaWuVZcNJdsoCx2zb63pv2sq7zi8BkkTVwnLR/GHFP0OOHhUJiz4Tjw6aSCvVLwFaG2TOrgC+wLbWpYuU9xjX9knr5QjGAE="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":21368,"cache_read_input_tokens":20020,"cache_creation":{"ephemeral_5m_input_tokens":21368,"ephemeral_1h_input_tokens":0},"output_tokens":10,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wrhFSZ5CJgAvoqWBbp","type":"assistant","uuid":"744c028f-ccb7-4a96-a2ba-bfb5297a5a8b","timestamp":"2026-02-14T12:18:18.320Z"}
{"parentUuid":"744c028f-ccb7-4a96-a2ba-bfb5297a5a8b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_011As75G95LNj7Cni6KEwiz2","type":"message","role":"assistant","content":[{"type":"text","text":"I've read the full plan carefully. It's well-structured and internally consistent overall — impressive given the multiple independent edits. Here's my readback organized by what's solid vs. what needs attention:\n\n## What's Clear and Consistent\n\n- **5-phase decomposition with wave execution** — dependency graph is correct, waves make sense\n- **Horizon → Napoli adaptation** — the comparison table and adaptation guidelines are precise about what changes (local file I/O vs Linear API) and what ports directly\n- **Spec Agent (Phase 1)** — stateless retry loop, 5 quality criteria, variant chain duplication, FR/AGI ID scheme, directory structure — all well-defined\n- **Stage-aware orchestrator** — one stage per dispatch, `stagePromptMap` routing, `filterEligible` with `isActionable` guard, `isTerminal` logic — internally consistent\n- **Variant example (lines 916-987)** — traces through the full lifecycle correctly, demonstrates parallelism, branch accumulation, and terminal-only PR creation\n- **Status enum** — the `isActionable` check (`startsWith(\"Needs \")` minus human intervention statuses) correctly excludes `In Progress`, `Blocked`, `Done`, `Awaiting Merge`\n\n## Issues to Address\n\n### 1. Orphaned \"In Progress\" tickets after orchestrator crash\n\nThe crash recovery (line 442) handles **worker** crashes (retry once → Blocked). But if the **orchestrator process itself** dies while a ticket is at `Research In Progress`, there's no mechanism to recover it — `isActionable()` won't match it on restart. The ticket is stuck until a human manually resets it to `Needs *`.\n\nThis is probably fine as a v1 behavior, but it should be explicitly called out rather than left as a silent gap.\n\n### 2. `codeProducingStages` referenced but never defined\n\nLines 816 and 823 use `this.codeProducingStages.has(originalStatus)` but the set is never spelled out. Should be:\n\n```typescript\nprivate codeProducingStages = new Set([\n  TaskStatus.NeedsImplement,\n  TaskStatus.NeedsValidate,\n  TaskStatus.NeedsOneshot,\n]);\n```\n\n### 3. `inProgressStatus()` mapping not defined\n\nReferenced on line 811 but the actual mapping (`Needs Research` → `Research In Progress`, etc.) isn't spelled out in the plan. It's trivially inferrable, but since you're defining the full enum, the mapping table should be explicit.\n\n### 4. Merge fragment relationship is ambiguous\n\nThe plan says merge-auto.md is used \"by default\" (line 1020) and the Files table lists merge-direct.md and merge-pr.md as \"Available if merge mode is overridden.\" But there's no mechanism described for overriding. I believe the intent is:\n\n- `merge-auto.md` = the decision rubric (the merge agent reads it and **chooses** direct vs PR)\n- `merge-direct.md` / `merge-pr.md` = sub-instructions included by the auto rubric\n\nIf so, this should be stated explicitly. If they're genuinely independent override modes, how does the user/config select them?\n\n### 5. \"Changes vs. previous plan\" table may confuse fresh readers\n\nThe table at line 893 (\"Changes Required for Variant Support vs. previous plan\") is a diff from an earlier version of this document. Someone reading the plan fresh wouldn't know what the \"previous plan\" was. Consider either:\n- Removing it (the current plan is self-contained without it)\n- Converting it to a \"Design Decisions\" section explaining **why** these choices were made\n\n### 6. `maxConcurrency` mentioned but not configured\n\n`processQueue()` references `this.maxConcurrency` (line 402) and `this.maxIterations` (line 391) and `this.pollIntervalSeconds` (line 397), but there's no discussion of how these are configured — constructor params, env vars, defaults?\n\n## Minor Nits\n\n- **PromptLoader placement** — it's a Wave 1 (no deps) component but appears near the bottom of the document after Phases 4 and 5. Consider moving it up near Phase 2 (ClaudeSpawner) since they're in the same execution wave.\n- **Line 369**: `--dangerously-skip-permissions` for ClaudeSpawner — worth noting this is intentional for local spec agent only, since the spec agent doesn't execute code.\n- **`loadAllTasks()` is called twice in `dispatchStage`** — once explicitly and once via `isTerminal()` which also calls it (lines 812-823). Minor perf concern for large queues but probably fine for v1.\n\n## Verdict\n\nThe plan is coherent and implementable. The six phases fit together, the data flow is traceable (user request → spec → tickets → stage dispatch → result writing), and the variant support is properly isolated through dependency chains. The main things to tighten up are the undefined helpers (#2, #3), the orphaned ticket gap (#1), and the merge fragment ambiguity (#4). Would you like me to patch these into the document?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":21368,"cache_read_input_tokens":20020,"cache_creation":{"ephemeral_5m_input_tokens":21368,"ephemeral_1h_input_tokens":0},"output_tokens":10,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7wrhFSZ5CJgAvoqWBbp","type":"assistant","uuid":"4af35395-b25e-4c9d-82c0-86ec8a06b775","timestamp":"2026-02-14T12:18:44.345Z"}
{"parentUuid":"4af35395-b25e-4c9d-82c0-86ec8a06b775","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"c92cb7bc-90d3-48d0-a6bd-950f696ba120","toolUseID":"c92cb7bc-90d3-48d0-a6bd-950f696ba120","timestamp":"2026-02-14T12:18:44.383Z","uuid":"db917434-9bab-4c68-a419-e0028baea2da"}
{"parentUuid":"db917434-9bab-4c68-a419-e0028baea2da","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"c92cb7bc-90d3-48d0-a6bd-950f696ba120","toolUseID":"c92cb7bc-90d3-48d0-a6bd-950f696ba120","timestamp":"2026-02-14T12:18:44.383Z","uuid":"1e7c6b9f-4cae-41e7-9494-4a6aaf02fc70"}
{"parentUuid":"1e7c6b9f-4cae-41e7-9494-4a6aaf02fc70","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T12:18:44.667Z","uuid":"b02b61c5-3bb5-4c4e-a69b-f2b8716c782c","toolUseID":"c92cb7bc-90d3-48d0-a6bd-950f696ba120"}
{"parentUuid":"b02b61c5-3bb5-4c4e-a69b-f2b8716c782c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","type":"system","subtype":"turn_duration","durationMs":96599,"timestamp":"2026-02-14T12:18:44.668Z","uuid":"f06c9f53-31dd-4618-84c2-b36a20231ba8","isMeta":false}
{"type":"file-history-snapshot","messageId":"6d5b14e7-1da9-47ed-b5d4-d154b5377b88","snapshot":{"messageId":"6d5b14e7-1da9-47ed-b5d4-d154b5377b88","trackedFileBackups":{},"timestamp":"2026-02-14T12:21:46.104Z"},"isSnapshotUpdate":false}
{"parentUuid":"f06c9f53-31dd-4618-84c2-b36a20231ba8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","type":"user","message":{"role":"user","content":"Let's go through all six issues and three minor niyd step by step by asking me questions, then making the change before moving on to the next issue to address "},"uuid":"6d5b14e7-1da9-47ed-b5d4-d154b5377b88","timestamp":"2026-02-14T12:21:45.721Z","thinkingMetadata":{"maxThinkingTokens":31999},"todos":[],"permissionMode":"default"}
{"parentUuid":"6d5b14e7-1da9-47ed-b5d4-d154b5377b88","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01T9rtkuNVwnj6Lqyw3wSPtw","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":4094,"cache_read_input_tokens":41388,"cache_creation":{"ephemeral_5m_input_tokens":4094,"ephemeral_1h_input_tokens":0},"output_tokens":12,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xDBim4wwvcfnAuCpWk","type":"assistant","uuid":"1dff9aa9-8c5a-416c-8f9a-a2b5564b8b31","timestamp":"2026-02-14T12:21:48.127Z"}
{"parentUuid":"1dff9aa9-8c5a-416c-8f9a-a2b5564b8b31","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01T9rtkuNVwnj6Lqyw3wSPtw","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants to go through all 6 issues and 3 minor nits one by one, asking them a question for each, making the change, then moving to the next. Let me start with Issue #1.","signature":"EtgCCkYICxgCKkBj4kTYXF9hXt1xPaTt7tcJA6xR2KDgdXqb8juaxik4Aeeg4X9eeIRiMxk4pQYkvDCuBI6AivyISlJroBeqKmINEgxTuh5yDIXzKd/4gsQaDH+ysCkB8eBgqWDzEiIwfELFvzaucLrIas+YrtTLtTd1wN2q2GU4MPvUu4I+yDydAIFbAx+lXzoO0V9kPqL7Kr8BYeafGzD0ItRNMAgblaJ0eQ5ZWiOvk88Sf7uYcWghSXh1yq9VMbC17vgDSkztt70IFcquJkj1xMubzYO37dodsbIHj18siFNhihDtvzjTYoXvQa7VgmoNQNyTUHSWs32QFD6awDkhabcb3bd/BgWj5Th09ctMVF9WGcUlEr8N1wSHDlZIJ0tYguUXsaswtJi+kCxpzOVzmhaD64f1SvrbF/H2V9ZPBvRnDR/7wSkGN4WBm7xIyVzmmfepILkNbRsYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":4094,"cache_read_input_tokens":41388,"cache_creation":{"ephemeral_5m_input_tokens":4094,"ephemeral_1h_input_tokens":0},"output_tokens":12,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xDBim4wwvcfnAuCpWk","type":"assistant","uuid":"77715cba-1054-4c19-9efb-86d8101d7e7f","timestamp":"2026-02-14T12:21:49.146Z"}
{"parentUuid":"77715cba-1054-4c19-9efb-86d8101d7e7f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01T9rtkuNVwnj6Lqyw3wSPtw","type":"message","role":"assistant","content":[{"type":"text","text":"Let's start with Issue #1.\n\n### Issue 1: Orphaned \"In Progress\" tickets after orchestrator crash\n\nRight now if the orchestrator dies while a ticket is at `Research In Progress`, it stays stuck — `isActionable()` only matches `Needs *` statuses, so on restart it's invisible to dispatch."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":4094,"cache_read_input_tokens":41388,"cache_creation":{"ephemeral_5m_input_tokens":4094,"ephemeral_1h_input_tokens":0},"output_tokens":12,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xDBim4wwvcfnAuCpWk","type":"assistant","uuid":"d8e44d5d-6a8b-46f4-8e8b-37cbd90b6b36","timestamp":"2026-02-14T12:21:50.750Z"}
{"parentUuid":"d8e44d5d-6a8b-46f4-8e8b-37cbd90b6b36","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01T9rtkuNVwnj6Lqyw3wSPtw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01844xewyaG9uVPmPuEpyquR","name":"AskUserQuestion","input":{"questions":[{"question":"How should the orchestrator handle orphaned 'In Progress' tickets on startup?","header":"Crash recovery","options":[{"label":"Document-only","description":"Just add an explicit note that humans must manually reset stuck 'In Progress' tickets. Keep v1 simple."},{"label":"Startup sweep","description":"Add a startup step that scans for 'In Progress' tickets and resets them back to their 'Needs *' counterpart (assumes no other orchestrator is running)."},{"label":"Timeout-based","description":"Track dispatch timestamps; if a ticket has been 'In Progress' for longer than a configurable threshold, reset it automatically during the poll loop."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":4094,"cache_read_input_tokens":41388,"output_tokens":352,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":4094},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7xDBim4wwvcfnAuCpWk","type":"assistant","uuid":"7238a073-54d3-4414-9201-9c1951337319","timestamp":"2026-02-14T12:21:55.058Z"}
{"parentUuid":"7238a073-54d3-4414-9201-9c1951337319","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01844xewyaG9uVPmPuEpyquR","parentToolUseID":"toolu_01844xewyaG9uVPmPuEpyquR","uuid":"b30d6395-ec30-46b0-bdb8-f365999c55a0","timestamp":"2026-02-14T12:21:55.064Z"}
{"parentUuid":"b30d6395-ec30-46b0-bdb8-f365999c55a0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01844xewyaG9uVPmPuEpyquR","toolUseID":"toolu_01844xewyaG9uVPmPuEpyquR","timestamp":"2026-02-14T12:22:16.093Z","uuid":"471ec407-ddaa-46c3-93cc-c006ae6b638d"}
{"parentUuid":"7238a073-54d3-4414-9201-9c1951337319","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"How should the orchestrator handle orphaned 'In Progress' tickets on startup?\"=\"Document-only\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01844xewyaG9uVPmPuEpyquR"}]},"uuid":"8af060e9-8ebc-42bf-80e7-bfac97f1e842","timestamp":"2026-02-14T12:22:16.091Z","toolUseResult":{"questions":[{"question":"How should the orchestrator handle orphaned 'In Progress' tickets on startup?","header":"Crash recovery","options":[{"label":"Document-only","description":"Just add an explicit note that humans must manually reset stuck 'In Progress' tickets. Keep v1 simple."},{"label":"Startup sweep","description":"Add a startup step that scans for 'In Progress' tickets and resets them back to their 'Needs *' counterpart (assumes no other orchestrator is running)."},{"label":"Timeout-based","description":"Track dispatch timestamps; if a ticket has been 'In Progress' for longer than a configurable threshold, reset it automatically during the poll loop."}],"multiSelect":false}],"answers":{"How should the orchestrator handle orphaned 'In Progress' tickets on startup?":"Document-only"}},"sourceToolAssistantUUID":"7238a073-54d3-4414-9201-9c1951337319"}
{"parentUuid":"8af060e9-8ebc-42bf-80e7-bfac97f1e842","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01YNEKSCcK1ka3mFJHtvGyMs","type":"message","role":"assistant","content":[{"type":"text","text":"Got it — document-only for v1. Let me add an explicit callout to the crash recovery section."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":421,"cache_read_input_tokens":45482,"cache_creation":{"ephemeral_5m_input_tokens":421,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xFQ4yDqokkDWK8U1xE","type":"assistant","uuid":"f3cdf804-30a3-4718-be76-6dda74650db5","timestamp":"2026-02-14T12:22:19.292Z"}
{"parentUuid":"f3cdf804-30a3-4718-be76-6dda74650db5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","message":{"model":"claude-opus-4-6","id":"msg_01YNEKSCcK1ka3mFJHtvGyMs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WtpnSpUwGaADYLRQJHmYL3","name":"Read","input":{"file_path":"REDACTED.md","offset":440,"limit":5},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":421,"cache_read_input_tokens":45482,"cache_creation":{"ephemeral_5m_input_tokens":421,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xFQ4yDqokkDWK8U1xE","type":"assistant","uuid":"4dfdd6f5-86d1-44b0-9b54-8a9ba7ec5c7f","timestamp":"2026-02-14T12:22:20.729Z"}
{"parentUuid":"4dfdd6f5-86d1-44b0-9b54-8a9ba7ec5c7f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01WtpnSpUwGaADYLRQJHmYL3","parentToolUseID":"toolu_01WtpnSpUwGaADYLRQJHmYL3","uuid":"0a37a749-e6a7-423c-ab3a-d2f69f7d081d","timestamp":"2026-02-14T12:22:20.734Z"}
{"parentUuid":"0a37a749-e6a7-423c-ab3a-d2f69f7d081d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01WtpnSpUwGaADYLRQJHmYL3","toolUseID":"toolu_01WtpnSpUwGaADYLRQJHmYL3","timestamp":"2026-02-14T12:22:20.793Z","uuid":"8293ec43-fe82-4967-a4fd-374fd95fe4f7"}
{"parentUuid":"8293ec43-fe82-4967-a4fd-374fd95fe4f7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01WtpnSpUwGaADYLRQJHmYL3","toolUseID":"toolu_01WtpnSpUwGaADYLRQJHmYL3","timestamp":"2026-02-14T12:22:20.793Z","uuid":"d0afc80f-84b5-4d0f-80ce-e184d37b58b9"}
{"parentUuid":"4dfdd6f5-86d1-44b0-9b54-8a9ba7ec5c7f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WtpnSpUwGaADYLRQJHmYL3","type":"tool_result","content":"   440→- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status\n   441→\n   442→**Crash recovery**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.\n   443→\n   444→### Spec Agent Sets Initial Stage"}]},"uuid":"1ce5ad4f-a017-40fd-8b6c-af4bca12feec","timestamp":"2026-02-14T12:22:20.791Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status\n\n**Crash recovery**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.\n\n### Spec Agent Sets Initial Stage","numLines":5,"startLine":440,"totalLines":1062}},"sourceToolAssistantUUID":"4dfdd6f5-86d1-44b0-9b54-8a9ba7ec5c7f"}
{"parentUuid":"1ce5ad4f-a017-40fd-8b6c-af4bca12feec","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01YL4FBxtHRy9vdBtrNqRenR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01MdVuQg1ffDqWwNrWHebdvm","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"**Crash recovery**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.","new_string":"**Crash recovery (worker failure)**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.\n\n**Crash recovery (orchestrator failure)**: If the orchestrator process itself crashes while tickets are `* In Progress`, those tickets remain stuck — `isActionable()` only matches `Needs *` statuses. In v1, a human must manually reset orphaned `In Progress` tickets back to their `Needs *` counterpart to resume processing. A future version could add a startup sweep or timeout-based recovery."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":299,"cache_read_input_tokens":45903,"cache_creation":{"ephemeral_5m_input_tokens":299,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xFkCBrtdu6Gm5fkyLb","type":"assistant","uuid":"5bf4a221-4a5e-43df-a18b-ae08cf8baccf","timestamp":"2026-02-14T12:22:26.536Z"}
{"parentUuid":"5bf4a221-4a5e-43df-a18b-ae08cf8baccf","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01MdVuQg1ffDqWwNrWHebdvm","parentToolUseID":"toolu_01MdVuQg1ffDqWwNrWHebdvm","uuid":"34b30fc1-454e-4342-80d9-bd514c2c84c3","timestamp":"2026-02-14T12:22:26.539Z"}
{"type":"file-history-snapshot","messageId":"5bf4a221-4a5e-43df-a18b-ae08cf8baccf","snapshot":{"messageId":"6d5b14e7-1da9-47ed-b5d4-d154b5377b88","trackedFileBackups":{"IMPLEMENTATION_PLAN.md":{"backupFileName":"7cb5415938e35d8f@v1","version":1,"backupTime":"2026-02-14T12:22:29.019Z"}},"timestamp":"2026-02-14T12:21:46.104Z"},"isSnapshotUpdate":true}
{"parentUuid":"34b30fc1-454e-4342-80d9-bd514c2c84c3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01MdVuQg1ffDqWwNrWHebdvm","toolUseID":"toolu_01MdVuQg1ffDqWwNrWHebdvm","timestamp":"2026-02-14T12:22:29.025Z","uuid":"824d7f4b-1936-4154-aea0-c2a3717f1c3e"}
{"parentUuid":"824d7f4b-1936-4154-aea0-c2a3717f1c3e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01MdVuQg1ffDqWwNrWHebdvm","toolUseID":"toolu_01MdVuQg1ffDqWwNrWHebdvm","timestamp":"2026-02-14T12:22:29.025Z","uuid":"344d9183-3df6-49e9-aca8-63977723b8bb"}
{"parentUuid":"5bf4a221-4a5e-43df-a18b-ae08cf8baccf","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01MdVuQg1ffDqWwNrWHebdvm","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"9f8aaa7f-128f-4305-9721-291df9fcc8f2","timestamp":"2026-02-14T12:22:29.023Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"**Crash recovery**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.","newString":"**Crash recovery (worker failure)**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.\n\n**Crash recovery (orchestrator failure)**: If the orchestrator process itself crashes while tickets are `* In Progress`, those tickets remain stuck — `isActionable()` only matches `Needs *` statuses. In v1, a human must manually reset orphaned `In Progress` tickets back to their `Needs *` counterpart to resume processing. A future version could add a startup sweep or timeout-based recovery.","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. PromptLoader                      — depends_on: []\n3. TaskStatus enum + helpers         — depends_on: []\n4. SpecAgent (Phase 1)               — depends_on: [1, 2]\n5. Orchestrator refactor (Phase 3)   — depends_on: [2, 3]\n6. Test-Writer (Phase 5)             — depends_on: [5]\n7. Entry Point (Phase 4)             — depends_on: [4, 5]\n8. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #2 (PromptLoader), #3 (TaskStatus), #8 (Prompt adaptations)\n  Wave 2: #4 (SpecAgent), #5 (Orchestrator)  — #4 needs #1+#2, #5 needs #2+#3\n  Wave 3: #6 (Test-Writer), #7 (Entry Point) — #6 needs #5, #7 needs #4+#5\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #8 is pure markdown edits with no code dependencies — safe for wave 1\n- #4 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n- Merge agent is part of #5 (Orchestrator) — uses merge-auto.md fragment via PromptLoader\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status\n\n**Crash recovery**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### Agent Runner Pattern\n\n`runWorkerAgent()`, `runTestWriterAgent()`, and `runMergeAgent()` all follow the same pattern inherited from the existing `executeClaudeCommand()`:\n\n1. Open a PTY session in the Daytona sandbox via the SDK\n2. Invoke `claude -p '<prompt>' --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n3. Stream stdout line-by-line, parse JSON events, log to file\n4. Extract structured output (WORK_RESULT / TEST_RESULT) from the `result` event\n5. Return parsed result\n\nThe only difference between the three is which prompt they receive and which output block they parse.\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox, checkout branch\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)\n  5. Return combined result (stage + test summary + merge status)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {{TICKET_CONTEXT}}\n**Branch diff vs main**: {{BRANCH_DIFF}}\n**Is terminal ticket**: {{IS_TERMINAL}}\n{{CHAIN_TICKETS}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n","structuredPatch":[{"oldStart":439,"oldLines":8,"newStart":439,"newLines":10,"lines":[" - Multiple tickets in different stages can run in parallel across different workers"," - A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status"," ","-**Crash recovery**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.","+**Crash recovery (worker failure)**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply."," ","+**Crash recovery (orchestrator failure)**: If the orchestrator process itself crashes while tickets are `* In Progress`, those tickets remain stuck — `isActionable()` only matches `Needs *` statuses. In v1, a human must manually reset orphaned `In Progress` tickets back to their `Needs *` counterpart to resume processing. A future version could add a startup sweep or timeout-based recovery.","+"," ### Spec Agent Sets Initial Stage"," "," The Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"5bf4a221-4a5e-43df-a18b-ae08cf8baccf"}
{"parentUuid":"9f8aaa7f-128f-4305-9721-291df9fcc8f2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_013YoqDeDJMoL9hSGgHomzAz","type":"message","role":"assistant","content":[{"type":"text","text":"Done. Now Issue #2.\n\n### Issue 2: `codeProducingStages` referenced but never defined\n\nLines 816 and 823 use `this.codeProducingStages.has(originalStatus)` but the set contents are never listed."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":480,"cache_read_input_tokens":46202,"cache_creation":{"ephemeral_5m_input_tokens":480,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xGMWxRW2pBsza2wDHP","type":"assistant","uuid":"af473a2e-2a2d-4949-9504-71e917a707f2","timestamp":"2026-02-14T12:22:31.682Z"}
{"parentUuid":"af473a2e-2a2d-4949-9504-71e917a707f2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_013YoqDeDJMoL9hSGgHomzAz","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016JbDQFCKwr1oM6EdJ7Q8aD","name":"AskUserQuestion","input":{"questions":[{"question":"Which statuses should be in the codeProducingStages set? My assumption is Implement, Validate, and Oneshot — but should Validate be included? Validate re-runs tests and may fix code, but it could also be purely verification.","header":"Code stages","options":[{"label":"Implement + Oneshot + Validate","description":"All three produce or modify code. Validate may fix issues found during verification, so test-writer should run after it too."},{"label":"Implement + Oneshot only","description":"Validate is purely verification — it runs existing tests and checks acceptance criteria but doesn't write new code. No need for test-writer after validate."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":480,"cache_read_input_tokens":46202,"cache_creation":{"ephemeral_5m_input_tokens":480,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xGMWxRW2pBsza2wDHP","type":"assistant","uuid":"5cb08393-df29-4357-ba7f-7f0431cd4151","timestamp":"2026-02-14T12:22:35.876Z"}
{"parentUuid":"5cb08393-df29-4357-ba7f-7f0431cd4151","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_016JbDQFCKwr1oM6EdJ7Q8aD","parentToolUseID":"toolu_016JbDQFCKwr1oM6EdJ7Q8aD","uuid":"797940ba-3f25-49f4-aa11-1d66cc49b717","timestamp":"2026-02-14T12:22:35.879Z"}
{"parentUuid":"797940ba-3f25-49f4-aa11-1d66cc49b717","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_016JbDQFCKwr1oM6EdJ7Q8aD","toolUseID":"toolu_016JbDQFCKwr1oM6EdJ7Q8aD","timestamp":"2026-02-14T12:22:48.235Z","uuid":"90ec9a8c-8e81-4b8d-8e58-1803af6ea837"}
{"parentUuid":"5cb08393-df29-4357-ba7f-7f0431cd4151","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Which statuses should be in the codeProducingStages set? My assumption is Implement, Validate, and Oneshot — but should Validate be included? Validate re-runs tests and may fix code, but it could also be purely verification.\"=\"Implement + Oneshot + Validate\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_016JbDQFCKwr1oM6EdJ7Q8aD"}]},"uuid":"1883360c-6cbd-465b-9858-499a872484a9","timestamp":"2026-02-14T12:22:48.233Z","toolUseResult":{"questions":[{"question":"Which statuses should be in the codeProducingStages set? My assumption is Implement, Validate, and Oneshot — but should Validate be included? Validate re-runs tests and may fix code, but it could also be purely verification.","header":"Code stages","options":[{"label":"Implement + Oneshot + Validate","description":"All three produce or modify code. Validate may fix issues found during verification, so test-writer should run after it too."},{"label":"Implement + Oneshot only","description":"Validate is purely verification — it runs existing tests and checks acceptance criteria but doesn't write new code. No need for test-writer after validate."}],"multiSelect":false}],"answers":{"Which statuses should be in the codeProducingStages set? My assumption is Implement, Validate, and Oneshot — but should Validate be included? Validate re-runs tests and may fix code, but it could also be purely verification.":"Implement + Oneshot + Validate"}},"sourceToolAssistantUUID":"5cb08393-df29-4357-ba7f-7f0431cd4151"}
{"parentUuid":"1883360c-6cbd-465b-9858-499a872484a9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01TbzVTc3usV664CeJfLA2wf","type":"message","role":"assistant","content":[{"type":"text","text":"All three. Let me add the explicit definition."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":503,"cache_read_input_tokens":46682,"cache_creation":{"ephemeral_5m_input_tokens":503,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xHmmW5jxLjHJVCHsTx","type":"assistant","uuid":"37a03a8d-7cbf-4e0c-b2f6-9bf1213cfc10","timestamp":"2026-02-14T12:22:50.483Z"}
{"parentUuid":"37a03a8d-7cbf-4e0c-b2f6-9bf1213cfc10","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01TbzVTc3usV664CeJfLA2wf","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018c2jyAhCSAzkijRnd2X5gR","name":"Read","input":{"file_path":"REDACTED.md","offset":806,"limit":10},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":503,"cache_read_input_tokens":46682,"cache_creation":{"ephemeral_5m_input_tokens":503,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xHmmW5jxLjHJVCHsTx","type":"assistant","uuid":"3f1202f1-a262-42c0-b720-2344d900e251","timestamp":"2026-02-14T12:22:51.298Z"}
{"parentUuid":"3f1202f1-a262-42c0-b720-2344d900e251","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_018c2jyAhCSAzkijRnd2X5gR","parentToolUseID":"toolu_018c2jyAhCSAzkijRnd2X5gR","uuid":"69a91035-6dd1-4dad-9b34-95637db1ad6f","timestamp":"2026-02-14T12:22:51.303Z"}
{"parentUuid":"69a91035-6dd1-4dad-9b34-95637db1ad6f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_018c2jyAhCSAzkijRnd2X5gR","toolUseID":"toolu_018c2jyAhCSAzkijRnd2X5gR","timestamp":"2026-02-14T12:22:51.359Z","uuid":"c170085d-310c-4cf9-bc5c-866884a46d0a"}
{"parentUuid":"c170085d-310c-4cf9-bc5c-866884a46d0a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_018c2jyAhCSAzkijRnd2X5gR","toolUseID":"toolu_018c2jyAhCSAzkijRnd2X5gR","timestamp":"2026-02-14T12:22:51.359Z","uuid":"d22d1689-3684-4929-afae-6f5195bfe949"}
{"parentUuid":"3f1202f1-a262-42c0-b720-2344d900e251","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018c2jyAhCSAzkijRnd2X5gR","type":"tool_result","content":"   806→  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n   807→};\n   808→\n   809→async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n   810→  const sandbox = await this.createSandbox(task);\n   811→  const originalStatus = task.status;  // capture before mutation\n   812→\n   813→  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n   814→  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n   815→"}]},"uuid":"e122235b-4296-4f12-a432-605e05fd10ae","timestamp":"2026-02-14T12:22:51.357Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n","numLines":10,"startLine":806,"totalLines":1064}},"sourceToolAssistantUUID":"3f1202f1-a262-42c0-b720-2344d900e251"}
{"parentUuid":"e122235b-4296-4f12-a432-605e05fd10ae","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01EHS3CY4vrEbWd62LVErBsL","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01K5M2P49AMx4kRUkcFRLXN4","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {","new_string":"};\n\nprivate codeProducingStages = new Set([\n  \"Needs Implement\",\n  \"Needs Validate\",\n  \"Needs Oneshot\",\n]);\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":292,"cache_read_input_tokens":47185,"cache_creation":{"ephemeral_5m_input_tokens":292,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xHzs3SNPLvFU5e6Sbb","type":"assistant","uuid":"304a37d3-3af4-4cf1-ae20-12dab391fb1b","timestamp":"2026-02-14T12:22:55.817Z"}
{"parentUuid":"304a37d3-3af4-4cf1-ae20-12dab391fb1b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01K5M2P49AMx4kRUkcFRLXN4","parentToolUseID":"toolu_01K5M2P49AMx4kRUkcFRLXN4","uuid":"cd0badfa-1e1a-4198-a523-68cdada8b073","timestamp":"2026-02-14T12:22:55.819Z"}
{"parentUuid":"cd0badfa-1e1a-4198-a523-68cdada8b073","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01K5M2P49AMx4kRUkcFRLXN4","toolUseID":"toolu_01K5M2P49AMx4kRUkcFRLXN4","timestamp":"2026-02-14T12:22:55.875Z","uuid":"993fcfd1-a50b-494e-bd90-d9e17cc688f7"}
{"parentUuid":"993fcfd1-a50b-494e-bd90-d9e17cc688f7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01K5M2P49AMx4kRUkcFRLXN4","toolUseID":"toolu_01K5M2P49AMx4kRUkcFRLXN4","timestamp":"2026-02-14T12:22:55.875Z","uuid":"a5370e52-e177-40d3-a095-00eb993b0442"}
{"parentUuid":"304a37d3-3af4-4cf1-ae20-12dab391fb1b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01K5M2P49AMx4kRUkcFRLXN4","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"f357d804-76e1-4de5-b272-3fc03b179f05","timestamp":"2026-02-14T12:22:55.874Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {","newString":"};\n\nprivate codeProducingStages = new Set([\n  \"Needs Implement\",\n  \"Needs Validate\",\n  \"Needs Oneshot\",\n]);\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. PromptLoader                      — depends_on: []\n3. TaskStatus enum + helpers         — depends_on: []\n4. SpecAgent (Phase 1)               — depends_on: [1, 2]\n5. Orchestrator refactor (Phase 3)   — depends_on: [2, 3]\n6. Test-Writer (Phase 5)             — depends_on: [5]\n7. Entry Point (Phase 4)             — depends_on: [4, 5]\n8. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #2 (PromptLoader), #3 (TaskStatus), #8 (Prompt adaptations)\n  Wave 2: #4 (SpecAgent), #5 (Orchestrator)  — #4 needs #1+#2, #5 needs #2+#3\n  Wave 3: #6 (Test-Writer), #7 (Entry Point) — #6 needs #5, #7 needs #4+#5\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #8 is pure markdown edits with no code dependencies — safe for wave 1\n- #4 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n- Merge agent is part of #5 (Orchestrator) — uses merge-auto.md fragment via PromptLoader\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status\n\n**Crash recovery (worker failure)**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.\n\n**Crash recovery (orchestrator failure)**: If the orchestrator process itself crashes while tickets are `* In Progress`, those tickets remain stuck — `isActionable()` only matches `Needs *` statuses. In v1, a human must manually reset orphaned `In Progress` tickets back to their `Needs *` counterpart to resume processing. A future version could add a startup sweep or timeout-based recovery.\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### Agent Runner Pattern\n\n`runWorkerAgent()`, `runTestWriterAgent()`, and `runMergeAgent()` all follow the same pattern inherited from the existing `executeClaudeCommand()`:\n\n1. Open a PTY session in the Daytona sandbox via the SDK\n2. Invoke `claude -p '<prompt>' --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n3. Stream stdout line-by-line, parse JSON events, log to file\n4. Extract structured output (WORK_RESULT / TEST_RESULT) from the `result` event\n5. Return parsed result\n\nThe only difference between the three is which prompt they receive and which output block they parse.\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox, checkout branch\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)\n  5. Return combined result (stage + test summary + merge status)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {{TICKET_CONTEXT}}\n**Branch diff vs main**: {{BRANCH_DIFF}}\n**Is terminal ticket**: {{IS_TERMINAL}}\n{{CHAIN_TICKETS}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n","structuredPatch":[{"oldStart":806,"oldLines":6,"newStart":806,"newLines":12,"lines":["   \"Needs Oneshot\":         \"agent2-worker-oneshot.md\","," };"," ","+private codeProducingStages = new Set([","+  \"Needs Implement\",","+  \"Needs Validate\",","+  \"Needs Oneshot\",","+]);","+"," async dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {","   const sandbox = await this.createSandbox(task);","   const originalStatus = task.status;  // capture before mutation"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"304a37d3-3af4-4cf1-ae20-12dab391fb1b"}
{"parentUuid":"f357d804-76e1-4de5-b272-3fc03b179f05","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01Gf29nkS83w2ZjgMrpy2qR8","type":"message","role":"assistant","content":[{"type":"text","text":"Done. Now Issue #3.\n\n### Issue 3: `inProgressStatus()` mapping not defined\n\nThe helper is called on line 813 but the mapping from `Needs *` → `* In Progress` is never spelled out."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":273,"cache_read_input_tokens":47477,"cache_creation":{"ephemeral_5m_input_tokens":273,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xJLG7TisWG8M6HRDCj","type":"assistant","uuid":"343d5f5e-1efa-4566-81b8-ec369b7b77f0","timestamp":"2026-02-14T12:22:58.708Z"}
{"parentUuid":"343d5f5e-1efa-4566-81b8-ec369b7b77f0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01Gf29nkS83w2ZjgMrpy2qR8","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SWTERGRabmiUPsZiQhG53o","name":"AskUserQuestion","input":{"questions":[{"question":"Where should the inProgressStatus() mapping be defined in the plan?","header":"Placement","options":[{"label":"In TaskStatus.ts section","description":"Add it alongside the enum definition and isActionable() in the Task Status Model section, since it's a status helper."},{"label":"Inline in dispatchStage","description":"Show the mapping right next to where it's called in the Phase 3 code block, keeping the context local."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":273,"cache_read_input_tokens":47477,"cache_creation":{"ephemeral_5m_input_tokens":273,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xJLG7TisWG8M6HRDCj","type":"assistant","uuid":"7e84fcb9-dcd2-4af2-a826-44d88c1c1d44","timestamp":"2026-02-14T12:23:01.810Z"}
{"parentUuid":"7e84fcb9-dcd2-4af2-a826-44d88c1c1d44","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01SWTERGRabmiUPsZiQhG53o","parentToolUseID":"toolu_01SWTERGRabmiUPsZiQhG53o","uuid":"9716e1fc-1d99-41e2-b4df-1b09d80f2ae7","timestamp":"2026-02-14T12:23:01.813Z"}
{"parentUuid":"9716e1fc-1d99-41e2-b4df-1b09d80f2ae7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01SWTERGRabmiUPsZiQhG53o","toolUseID":"toolu_01SWTERGRabmiUPsZiQhG53o","timestamp":"2026-02-14T12:23:12.036Z","uuid":"ec17cf67-9cb5-4469-b4ba-d4dceff70872"}
{"parentUuid":"7e84fcb9-dcd2-4af2-a826-44d88c1c1d44","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Where should the inProgressStatus() mapping be defined in the plan?\"=\"In TaskStatus.ts section\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01SWTERGRabmiUPsZiQhG53o"}]},"uuid":"56bf05f3-17f9-4fd7-80ea-fdc0640169a1","timestamp":"2026-02-14T12:23:12.033Z","toolUseResult":{"questions":[{"question":"Where should the inProgressStatus() mapping be defined in the plan?","header":"Placement","options":[{"label":"In TaskStatus.ts section","description":"Add it alongside the enum definition and isActionable() in the Task Status Model section, since it's a status helper."},{"label":"Inline in dispatchStage","description":"Show the mapping right next to where it's called in the Phase 3 code block, keeping the context local."}],"multiSelect":false}],"answers":{"Where should the inProgressStatus() mapping be defined in the plan?":"In TaskStatus.ts section"}},"sourceToolAssistantUUID":"7e84fcb9-dcd2-4af2-a826-44d88c1c1d44"}
{"parentUuid":"56bf05f3-17f9-4fd7-80ea-fdc0640169a1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_017C5es5Yhyn9H1aG2gsCiHe","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EmGETL2HzrfUwsGPPba4U4","name":"Read","input":{"file_path":"REDACTED.md","offset":1028,"limit":8},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":279,"cache_read_input_tokens":47750,"cache_creation":{"ephemeral_5m_input_tokens":279,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xKXV519Dmje6Pi5Er1","type":"assistant","uuid":"481134a3-9f91-4321-b7e0-d0bf570edc7d","timestamp":"2026-02-14T12:23:14.988Z"}
{"parentUuid":"481134a3-9f91-4321-b7e0-d0bf570edc7d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01EmGETL2HzrfUwsGPPba4U4","parentToolUseID":"toolu_01EmGETL2HzrfUwsGPPba4U4","uuid":"2efe23e0-6ba6-4b59-b95c-b2b5d89d269c","timestamp":"2026-02-14T12:23:14.990Z"}
{"parentUuid":"2efe23e0-6ba6-4b59-b95c-b2b5d89d269c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01EmGETL2HzrfUwsGPPba4U4","toolUseID":"toolu_01EmGETL2HzrfUwsGPPba4U4","timestamp":"2026-02-14T12:23:15.043Z","uuid":"41e0ca73-f241-4f6c-9595-a44a73c94333"}
{"parentUuid":"41e0ca73-f241-4f6c-9595-a44a73c94333","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01EmGETL2HzrfUwsGPPba4U4","toolUseID":"toolu_01EmGETL2HzrfUwsGPPba4U4","timestamp":"2026-02-14T12:23:15.043Z","uuid":"9a0e257d-4840-4db0-b45e-250184cc725b"}
{"parentUuid":"481134a3-9f91-4321-b7e0-d0bf570edc7d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EmGETL2HzrfUwsGPPba4U4","type":"tool_result","content":"  1028→For the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n  1029→\n  1030→---\n  1031→\n  1032→## Files\n  1033→\n  1034→| File | Change |\n  1035→|------|--------|"}]},"uuid":"130d68cf-a3e6-4017-ab23-b28e1c957e6d","timestamp":"2026-02-14T12:23:15.042Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"For the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|","numLines":8,"startLine":1028,"totalLines":1070}},"sourceToolAssistantUUID":"481134a3-9f91-4321-b7e0-d0bf570edc7d"}
{"parentUuid":"130d68cf-a3e6-4017-ab23-b28e1c957e6d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01H25SJ1t5Wo3N9xfP2HkTLC","type":"message","role":"assistant","content":[{"type":"text","text":"Let me find the right spot in the Task Status Model section — after `isActionable()`."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":221,"cache_read_input_tokens":48029,"cache_creation":{"ephemeral_5m_input_tokens":221,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xKk5MnPw5RCC2LJXny","type":"assistant","uuid":"e2d1d48e-5985-45f5-9bb3-df35e3b4c587","timestamp":"2026-02-14T12:23:17.899Z"}
{"parentUuid":"e2d1d48e-5985-45f5-9bb3-df35e3b4c587","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01H25SJ1t5Wo3N9xfP2HkTLC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012pN6ns9FbL5mpXUH9WspsC","name":"Read","input":{"file_path":"REDACTED.md","offset":888,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":221,"cache_read_input_tokens":48029,"cache_creation":{"ephemeral_5m_input_tokens":221,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xKk5MnPw5RCC2LJXny","type":"assistant","uuid":"08d4ecd5-c0d1-4aa3-80a4-44665097ab03","timestamp":"2026-02-14T12:23:18.472Z"}
{"parentUuid":"08d4ecd5-c0d1-4aa3-80a4-44665097ab03","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_012pN6ns9FbL5mpXUH9WspsC","parentToolUseID":"toolu_012pN6ns9FbL5mpXUH9WspsC","uuid":"13fd9d8c-9941-4eab-a517-aaa95ef2d342","timestamp":"2026-02-14T12:23:18.476Z"}
{"parentUuid":"13fd9d8c-9941-4eab-a517-aaa95ef2d342","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_012pN6ns9FbL5mpXUH9WspsC","toolUseID":"toolu_012pN6ns9FbL5mpXUH9WspsC","timestamp":"2026-02-14T12:23:18.535Z","uuid":"4004b47e-7e08-48e0-a5de-9508b950eb94"}
{"parentUuid":"4004b47e-7e08-48e0-a5de-9508b950eb94","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_012pN6ns9FbL5mpXUH9WspsC","toolUseID":"toolu_012pN6ns9FbL5mpXUH9WspsC","timestamp":"2026-02-14T12:23:18.535Z","uuid":"29782511-090a-457b-bf35-7b220399c59e"}
{"parentUuid":"08d4ecd5-c0d1-4aa3-80a4-44665097ab03","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012pN6ns9FbL5mpXUH9WspsC","type":"tool_result","content":"   888→```typescript\n   889→private isActionable(task: TaskRequest): boolean {\n   890→  return task.status.startsWith(\"Needs \") &&\n   891→    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n   892→}\n   893→```\n   894→\n   895→Tickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n   896→\n   897→### Single Task Loader\n   898→\n   899→**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n   900→\n   901→## Changes Required for Variant Support (vs. previous plan)\n   902→"}]},"uuid":"157fa3bb-e05c-4d3e-9020-5f714fe0d92b","timestamp":"2026-02-14T12:23:18.534Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n","numLines":15,"startLine":888,"totalLines":1070}},"sourceToolAssistantUUID":"08d4ecd5-c0d1-4aa3-80a4-44665097ab03"}
{"parentUuid":"157fa3bb-e05c-4d3e-9020-5f714fe0d92b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01RRZMp6gVrHxmYjfZWu3cwh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Ay1VXPLAYqRL3Q2KivVTa9","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"Tickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader","new_string":"Tickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `inProgressStatus()` — Status Transition Helper\n\nMaps each actionable `Needs *` status to its corresponding `* In Progress` status:\n\n```typescript\nconst inProgressMap: Record<string, TaskStatus> = {\n  [TaskStatus.NeedsResearch]:      TaskStatus.ResearchInProgress,\n  [TaskStatus.NeedsSpecification]: TaskStatus.SpecificationInProgress,\n  [TaskStatus.NeedsPlan]:          TaskStatus.PlanInProgress,\n  [TaskStatus.NeedsImplement]:     TaskStatus.ImplementInProgress,\n  [TaskStatus.NeedsValidate]:      TaskStatus.ValidateInProgress,\n  [TaskStatus.NeedsOneshot]:       TaskStatus.OneshotInProgress,\n};\n\nfunction inProgressStatus(status: TaskStatus): TaskStatus {\n  return inProgressMap[status] ?? status;\n}\n```\n\n### Single Task Loader"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":407,"cache_read_input_tokens":48250,"output_tokens":452,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":407},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7xL1ERuzGsZeoY9DLGy","type":"assistant","uuid":"a96f6bbd-582b-4b71-aa9f-af7593609c7c","timestamp":"2026-02-14T12:23:24.968Z"}
{"parentUuid":"a96f6bbd-582b-4b71-aa9f-af7593609c7c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01Ay1VXPLAYqRL3Q2KivVTa9","parentToolUseID":"toolu_01Ay1VXPLAYqRL3Q2KivVTa9","uuid":"6f742df4-e494-4e1b-a6ee-24d74e67e0ff","timestamp":"2026-02-14T12:23:24.971Z"}
{"parentUuid":"6f742df4-e494-4e1b-a6ee-24d74e67e0ff","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01Ay1VXPLAYqRL3Q2KivVTa9","toolUseID":"toolu_01Ay1VXPLAYqRL3Q2KivVTa9","timestamp":"2026-02-14T12:23:25.027Z","uuid":"ce7fc7d8-6835-4fed-8ad4-d28d1c08b593"}
{"parentUuid":"ce7fc7d8-6835-4fed-8ad4-d28d1c08b593","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01Ay1VXPLAYqRL3Q2KivVTa9","toolUseID":"toolu_01Ay1VXPLAYqRL3Q2KivVTa9","timestamp":"2026-02-14T12:23:25.027Z","uuid":"d59b7a6a-80cc-4988-9315-7380ec99d36f"}
{"parentUuid":"a96f6bbd-582b-4b71-aa9f-af7593609c7c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Ay1VXPLAYqRL3Q2KivVTa9","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"a8e7b42e-cd42-40a8-922d-57b6be1e60d1","timestamp":"2026-02-14T12:23:25.026Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"Tickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader","newString":"Tickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `inProgressStatus()` — Status Transition Helper\n\nMaps each actionable `Needs *` status to its corresponding `* In Progress` status:\n\n```typescript\nconst inProgressMap: Record<string, TaskStatus> = {\n  [TaskStatus.NeedsResearch]:      TaskStatus.ResearchInProgress,\n  [TaskStatus.NeedsSpecification]: TaskStatus.SpecificationInProgress,\n  [TaskStatus.NeedsPlan]:          TaskStatus.PlanInProgress,\n  [TaskStatus.NeedsImplement]:     TaskStatus.ImplementInProgress,\n  [TaskStatus.NeedsValidate]:      TaskStatus.ValidateInProgress,\n  [TaskStatus.NeedsOneshot]:       TaskStatus.OneshotInProgress,\n};\n\nfunction inProgressStatus(status: TaskStatus): TaskStatus {\n  return inProgressMap[status] ?? status;\n}\n```\n\n### Single Task Loader","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. PromptLoader                      — depends_on: []\n3. TaskStatus enum + helpers         — depends_on: []\n4. SpecAgent (Phase 1)               — depends_on: [1, 2]\n5. Orchestrator refactor (Phase 3)   — depends_on: [2, 3]\n6. Test-Writer (Phase 5)             — depends_on: [5]\n7. Entry Point (Phase 4)             — depends_on: [4, 5]\n8. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #2 (PromptLoader), #3 (TaskStatus), #8 (Prompt adaptations)\n  Wave 2: #4 (SpecAgent), #5 (Orchestrator)  — #4 needs #1+#2, #5 needs #2+#3\n  Wave 3: #6 (Test-Writer), #7 (Entry Point) — #6 needs #5, #7 needs #4+#5\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #8 is pure markdown edits with no code dependencies — safe for wave 1\n- #4 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n- Merge agent is part of #5 (Orchestrator) — uses merge-auto.md fragment via PromptLoader\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status\n\n**Crash recovery (worker failure)**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.\n\n**Crash recovery (orchestrator failure)**: If the orchestrator process itself crashes while tickets are `* In Progress`, those tickets remain stuck — `isActionable()` only matches `Needs *` statuses. In v1, a human must manually reset orphaned `In Progress` tickets back to their `Needs *` counterpart to resume processing. A future version could add a startup sweep or timeout-based recovery.\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### Agent Runner Pattern\n\n`runWorkerAgent()`, `runTestWriterAgent()`, and `runMergeAgent()` all follow the same pattern inherited from the existing `executeClaudeCommand()`:\n\n1. Open a PTY session in the Daytona sandbox via the SDK\n2. Invoke `claude -p '<prompt>' --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n3. Stream stdout line-by-line, parse JSON events, log to file\n4. Extract structured output (WORK_RESULT / TEST_RESULT) from the `result` event\n5. Return parsed result\n\nThe only difference between the three is which prompt they receive and which output block they parse.\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox, checkout branch\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)\n  5. Return combined result (stage + test summary + merge status)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {{TICKET_CONTEXT}}\n**Branch diff vs main**: {{BRANCH_DIFF}}\n**Is terminal ticket**: {{IS_TERMINAL}}\n{{CHAIN_TICKETS}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nprivate codeProducingStages = new Set([\n  \"Needs Implement\",\n  \"Needs Validate\",\n  \"Needs Oneshot\",\n]);\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n","structuredPatch":[{"oldStart":894,"oldLines":6,"newStart":894,"newLines":25,"lines":[" "," Tickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention."," ","+### `inProgressStatus()` — Status Transition Helper","+","+Maps each actionable `Needs *` status to its corresponding `* In Progress` status:","+","+```typescript","+const inProgressMap: Record<string, TaskStatus> = {","+  [TaskStatus.NeedsResearch]:      TaskStatus.ResearchInProgress,","+  [TaskStatus.NeedsSpecification]: TaskStatus.SpecificationInProgress,","+  [TaskStatus.NeedsPlan]:          TaskStatus.PlanInProgress,","+  [TaskStatus.NeedsImplement]:     TaskStatus.ImplementInProgress,","+  [TaskStatus.NeedsValidate]:      TaskStatus.ValidateInProgress,","+  [TaskStatus.NeedsOneshot]:       TaskStatus.OneshotInProgress,","+};","+","+function inProgressStatus(status: TaskStatus): TaskStatus {","+  return inProgressMap[status] ?? status;","+}","+```","+"," ### Single Task Loader"," "," **`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally."]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"a96f6bbd-582b-4b71-aa9f-af7593609c7c"}
{"parentUuid":"a8e7b42e-cd42-40a8-922d-57b6be1e60d1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01EwPhgMxKJs9UfV38EsjD7Y","type":"message","role":"assistant","content":[{"type":"text","text":"Done. Now Issue #4.\n\n### Issue 4: Merge fragment relationship is ambiguous\n\nThe plan references `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` but doesn't clarify how they relate. Are `merge-direct.md` and `merge-pr.md` sub-fragments that `merge-auto.md` delegates to, or are they independent override modes?"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":497,"cache_read_input_tokens":48657,"cache_creation":{"ephemeral_5m_input_tokens":497,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xLUprqrtuMnsaTT9TR","type":"assistant","uuid":"54aad714-a8f8-4b97-ad3c-13b7815505f2","timestamp":"2026-02-14T12:23:28.259Z"}
{"parentUuid":"54aad714-a8f8-4b97-ad3c-13b7815505f2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01EwPhgMxKJs9UfV38EsjD7Y","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01N45rwnV1rSdCLwusAB5pfK","name":"AskUserQuestion","input":{"questions":[{"question":"What's the relationship between the three merge fragments?","header":"Merge fragments","options":[{"label":"Auto delegates to sub-fragments","description":"merge-auto.md is the decision rubric. Once the merge agent decides 'direct' or 'PR', it follows the instructions in merge-direct.md or merge-pr.md respectively. All three are always loaded together."},{"label":"Three independent modes","description":"Each is a standalone mode. The orchestrator selects which one to load based on config (e.g., env var or per-ticket override). merge-auto.md is the default."},{"label":"Auto is self-contained","description":"merge-auto.md contains all the logic inline. merge-direct.md and merge-pr.md exist only for manual/forced override scenarios (e.g., human sets merge_mode: pr on a ticket)."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":497,"cache_read_input_tokens":48657,"cache_creation":{"ephemeral_5m_input_tokens":497,"ephemeral_1h_input_tokens":0},"output_tokens":7,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xLUprqrtuMnsaTT9TR","type":"assistant","uuid":"4f8df6dc-ebcc-4334-8fe1-374e6b1dffa1","timestamp":"2026-02-14T12:23:32.910Z"}
{"parentUuid":"4f8df6dc-ebcc-4334-8fe1-374e6b1dffa1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01N45rwnV1rSdCLwusAB5pfK","parentToolUseID":"toolu_01N45rwnV1rSdCLwusAB5pfK","uuid":"db3ed3b3-a4c5-44c8-95d2-22f268d0dba9","timestamp":"2026-02-14T12:23:32.912Z"}
{"parentUuid":"4f8df6dc-ebcc-4334-8fe1-374e6b1dffa1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). To tell you how to proceed, the user said:\nThe user wants to clarify these questions.\n    This means they may have additional information, context or questions for you.\n    Take their response into account and then reformulate the questions if appropriate.\n    Start by asking them what they would like to clarify.\n\n    Questions asked:\n- \"What's the relationship between the three merge fragments?\"\n  (No answer provided)","is_error":true,"tool_use_id":"toolu_01N45rwnV1rSdCLwusAB5pfK"}]},"uuid":"57d19a06-d2b2-4b2a-b639-815bef436183","timestamp":"2026-02-14T12:24:08.098Z","toolUseResult":"Error: The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). To tell you how to proceed, the user said:\nThe user wants to clarify these questions.\n    This means they may have additional information, context or questions for you.\n    Take their response into account and then reformulate the questions if appropriate.\n    Start by asking them what they would like to clarify.\n\n    Questions asked:\n- \"What's the relationship between the three merge fragments?\"\n  (No answer provided)","sourceToolAssistantUUID":"4f8df6dc-ebcc-4334-8fe1-374e6b1dffa1"}
{"parentUuid":"57d19a06-d2b2-4b2a-b639-815bef436183","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01NFkmYBUN6hZb1926CA4E7n","type":"message","role":"assistant","content":[{"type":"text","text":"What would you like to clarify about the merge fragment relationship? Let me know your thinking and I'll adjust the question or just make the change directly."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":622,"cache_read_input_tokens":49154,"cache_creation":{"ephemeral_5m_input_tokens":622,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xPehm31J3JmRNyXBZe","type":"assistant","uuid":"56bb947f-0ac2-408e-82cb-3a762c3edafd","timestamp":"2026-02-14T12:24:10.841Z"}
{"parentUuid":"56bb947f-0ac2-408e-82cb-3a762c3edafd","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"6974a38d-db4e-47da-b09e-8345a548c407","toolUseID":"6974a38d-db4e-47da-b09e-8345a548c407","timestamp":"2026-02-14T12:24:10.872Z","uuid":"565bb070-e7be-4105-9516-bd0d793e57ea"}
{"parentUuid":"565bb070-e7be-4105-9516-bd0d793e57ea","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"6974a38d-db4e-47da-b09e-8345a548c407","toolUseID":"6974a38d-db4e-47da-b09e-8345a548c407","timestamp":"2026-02-14T12:24:10.872Z","uuid":"1f4fed21-3ffb-417d-808e-81dd43bad4ef"}
{"parentUuid":"1f4fed21-3ffb-417d-808e-81dd43bad4ef","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T12:24:11.265Z","uuid":"af8e7fcf-d6ba-4edd-a756-45e4b3a99698","toolUseID":"6974a38d-db4e-47da-b09e-8345a548c407"}
{"parentUuid":"af8e7fcf-d6ba-4edd-a756-45e4b3a99698","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"system","subtype":"turn_duration","durationMs":64061,"timestamp":"2026-02-14T12:24:11.266Z","uuid":"cc7d1a78-51b8-4dc3-ba04-145a0b86dc01","isMeta":false}
{"type":"file-history-snapshot","messageId":"c05a84b6-e8d9-415a-8f5b-6705e82c2335","snapshot":{"messageId":"c05a84b6-e8d9-415a-8f5b-6705e82c2335","trackedFileBackups":{"IMPLEMENTATION_PLAN.md":{"backupFileName":"7cb5415938e35d8f@v2","version":2,"backupTime":"2026-02-14T12:24:29.156Z"}},"timestamp":"2026-02-14T12:24:29.156Z"},"isSnapshotUpdate":false}
{"parentUuid":"cc7d1a78-51b8-4dc3-ba04-145a0b86dc01","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":"Analyze how Horizon Agent implements merge-auto to determine their relationship."},"uuid":"c05a84b6-e8d9-415a-8f5b-6705e82c2335","timestamp":"2026-02-14T12:24:28.803Z","thinkingMetadata":{"maxThinkingTokens":31999},"todos":[],"permissionMode":"acceptEdits"}
{"parentUuid":"c05a84b6-e8d9-415a-8f5b-6705e82c2335","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01Dmvdw7ay2DDaXK3tdLT3jP","type":"message","role":"assistant","content":[{"type":"text","text":"\n\n"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":39,"cache_read_input_tokens":49808,"cache_creation":{"ephemeral_5m_input_tokens":39,"ephemeral_1h_input_tokens":0},"output_tokens":14,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xRCuY4ZUMnCZ1DGmWJ","type":"assistant","uuid":"12d07377-758d-46b8-b64f-866a2b148aa6","timestamp":"2026-02-14T12:24:31.015Z"}
{"parentUuid":"12d07377-758d-46b8-b64f-866a2b148aa6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01Dmvdw7ay2DDaXK3tdLT3jP","type":"message","role":"assistant","content":[{"type":"thinking","thinking":"The user wants me to look at the Horizon CLI Agent repo to understand how the merge fragments work together. Let me explore the Horizon repo's merge-related files.","signature":"EswCCkYICxgCKkD0yl4OHf5GTmIbPLT839PnWrBQI/jZ6Fe2zhFNQViVKhc+Qn3wTX2Ze/TgwlBsH+gxFalEqd46+9dbb9yzf/UaEgyJgOVoObSnxDATiFUaDD9xVnFrCSmY0Q+6XCIw+wQOhgUdLcF2Jkxyw1cNxuX+Ohcn5H4k7eoytSV9b9Uoz7iTL2Gr8jezs55ixOhFKrMBBtScqS757yd2aFOftXvmgMCBn2UvLP98WxgXQiknnzIZKdrUdDjvbB+urlQlkWt3W0JzXrXM4CXkYPwWZPYP5ShD/jZgTvhQ1bGd9aGc1auT2JSeb3v7KU0k+nlJyeOhr/eiITl5BKbAvBkN+X54BCWl8Ykj6kj9UIxFritM+LX0SP3MqHJ3hDCPR23phAF+DxQAF31aHgp6O7DZsZaUhBMJaO63MXka9k5LuIQKakB0l8YYAQ=="}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":39,"cache_read_input_tokens":49808,"cache_creation":{"ephemeral_5m_input_tokens":39,"ephemeral_1h_input_tokens":0},"output_tokens":14,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xRCuY4ZUMnCZ1DGmWJ","type":"assistant","uuid":"8b2af5ba-d250-403e-98ca-4c42862bf40d","timestamp":"2026-02-14T12:24:32.180Z"}
{"parentUuid":"8b2af5ba-d250-403e-98ca-4c42862bf40d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01Dmvdw7ay2DDaXK3tdLT3jP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JJp4Z34irSreptXtiFCexc","name":"Task","input":{"description":"Analyze Horizon merge fragments","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","subagent_type":"Explore"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":39,"cache_read_input_tokens":49808,"cache_creation":{"ephemeral_5m_input_tokens":39,"ephemeral_1h_input_tokens":0},"output_tokens":14,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xRCuY4ZUMnCZ1DGmWJ","type":"assistant","uuid":"a05c6fac-c6ca-4926-9372-5348f11a0e2d","timestamp":"2026-02-14T12:24:37.311Z"}
{"parentUuid":"a05c6fac-c6ca-4926-9372-5348f11a0e2d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Task","command":"entire hooks claude-code pre-task"},"toolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"f2d1a069-c4b5-41ae-8178-a96f3b9ba0d4","timestamp":"2026-02-14T12:24:37.314Z"}
{"parentUuid":"f2d1a069-c4b5-41ae-8178-a96f3b9ba0d4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Task","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"b5cdc340-0f93-4da9-9d21-35203bd33fd3","timestamp":"2026-02-14T12:24:37.314Z"}
{"parentUuid":"b5cdc340-0f93-4da9-9d21-35203bd33fd3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"type":"text","text":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection."}]},"uuid":"32f0b1f4-cd46-4cb5-a277-ed77fbae34eb","timestamp":"2026-02-14T12:24:37.558Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"e96df1dd-5382-4d09-b7e5-45c42301630f","timestamp":"2026-02-14T12:24:37.558Z"}
{"parentUuid":"e96df1dd-5382-4d09-b7e5-45c42301630f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:24:38.907Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013137QG8J2JNsn9XHM3XpKx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01UWmmrVaK22WnQhs4mHhbi3","name":"Read","input":{"file_path":"/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-auto.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":13814,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":13814,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7xRpbdNs71notvcPcpY","uuid":"a4f355b6-923e-4d3f-8832-944b8683f276"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"b62244e8-4f6e-43c6-9994-7b9cb436f993","timestamp":"2026-02-14T12:24:38.908Z"}
{"parentUuid":"b62244e8-4f6e-43c6-9994-7b9cb436f993","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:24:39.165Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013137QG8J2JNsn9XHM3XpKx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VdCF4tskFHoTP31BESpccs","name":"Read","input":{"file_path":"/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-direct.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":13814,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":13814,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7xRpbdNs71notvcPcpY","uuid":"5c4fffd8-a40d-4523-94cd-b88110b69292"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"c9816dbf-d734-4f43-9c9e-a6c616f96137","timestamp":"2026-02-14T12:24:39.165Z"}
{"parentUuid":"c9816dbf-d734-4f43-9c9e-a6c616f96137","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:24:39.335Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_013137QG8J2JNsn9XHM3XpKx","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Pxrq3hdNuiJMDNXN51iu86","name":"Read","input":{"file_path":"/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-pr.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":13814,"cache_read_input_tokens":0,"cache_creation":{"ephemeral_5m_input_tokens":13814,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7xRpbdNs71notvcPcpY","uuid":"44008be0-8a0c-44f0-b354-398c9c70e49d"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"15b79ae5-e770-4cf1-94a2-fd3963c54abf","timestamp":"2026-02-14T12:24:39.335Z"}
{"parentUuid":"15b79ae5-e770-4cf1-94a2-fd3963c54abf","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01UWmmrVaK22WnQhs4mHhbi3","type":"tool_result","content":"     1→## Merge Mode: `auto` (choose the safest path)\n     2→\n     3→You must choose **exactly one** of the following options:\n     4→\n     5→- **Option A: Merge directly to `main`**\n     6→- **Option B: Create a PR for review**\n     7→\n     8→### Decision Rubric (read first)\n     9→\n    10→Prefer **Option B (PR)** when:\n    11→- The changes include **significant business logic updates**\n    12→- You are **unsure** about correctness, scope, or product intent\n    13→- You had to make assumptions, or you want review for safety\n    14→- There are potential edge cases, migrations, or higher-risk changes\n    15→\n    16→Prefer **Option A (direct merge)** only when:\n    17→- The changes are **small, clearly safe**, and well-understood\n    18→- All checks pass and there are no open questions\n    19→\n    20→---\n    21→\n    22→# Option A: Merge directly to `main`\n    23→\n    24→## A1: Get Repository URL\n    25→\n    26→Before merging, get the repository URL for Agent 3:\n    27→\n    28→```bash\n    29→git remote get-url origin\n    30→```\n    31→\n    32→Include this as `repo_url` in WORK_RESULT.\n    33→\n    34→## A2: Merge to Main\n    35→\n    36→After all checks pass, merge the feature branch to main:\n    37→\n    38→```bash\n    39→# Switch to main and update\n    40→git checkout main\n    41→git pull origin main\n    42→\n    43→# Attempt merge with no-ff to preserve branch history\n    44→git merge horizon/{identifier} --no-ff -m \"Merge horizon/{identifier}: {issue_title}\"\n    45→```\n    46→\n    47→**Handle the merge result:**\n    48→\n    49→1. **Clean merge (no conflicts)**: Push to main, delete feature branch\n    50→   ```bash\n    51→   git push origin main\n    52→   git branch -d horizon/{identifier}\n    53→   git push origin --delete horizon/{identifier}\n    54→   ```\n    55→   Set `merge_status: success` in WORK_RESULT.\n    56→\n    57→2. **Simple conflicts** (imports, whitespace, non-overlapping): Resolve them if obvious\n    58→   - Conflicts are purely mechanical (imports, formatting)\n    59→   - Changes don't overlap in business logic\n    60→   - Resolution is obvious and doesn't require product decisions\n    61→\n    62→   After resolving:\n    63→   ```bash\n    64→   git add .\n    65→   git commit -m \"Merge horizon/{identifier}: {issue_title}\"\n    66→   git push origin main\n    67→   git branch -d horizon/{identifier}\n    68→   git push origin --delete horizon/{identifier}\n    69→   ```\n    70→   Set `merge_status: success` in WORK_RESULT.\n    71→\n    72→3. **Complex conflicts** (business logic, requires judgment): Abort and mark blocked\n    73→   - Conflicts touch core business logic\n    74→   - Multiple approaches are possible\n    75→   - Resolution requires broader context\n    76→\n    77→   ```bash\n    78→   git merge --abort\n    79→   git checkout horizon/{identifier}\n    80→   ```\n    81→   Set `merge_status: blocked` and `merge_conflict_files: [list of files]` in WORK_RESULT.\n    82→\n    83→### WORK_RESULT (Option A)\n    84→\n    85→Use this output format when you chose **Option A (direct merge)**.\n    86→\n    87→After completing your work and merge succeeds:\n    88→\n    89→```\n    90→WORK_RESULT:\n    91→  success: true\n    92→  stage_completed: {{STAGE}}\n    93→  workflow: {{WORKFLOW}}\n    94→  branch_name: horizon/{identifier}\n    95→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n    96→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n    97→  commit_hash: {merge commit hash on main}\n    98→  merge_status: success\n    99→  next_status: \"∞ Done\"\n   100→  summary: |\n   101→    {Brief description of what was done}\n   102→    Files changed: {list}\n   103→    All checks pass. Merged to main.\n   104→```\n   105→\n   106→If work completes but merge is blocked:\n   107→\n   108→```\n   109→WORK_RESULT:\n   110→  success: true\n   111→  stage_completed: {{STAGE}}\n   112→  workflow: {{WORKFLOW}}\n   113→  branch_name: horizon/{identifier}\n   114→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   115→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n   116→  commit_hash: {short hash on feature branch}\n   117→  merge_status: blocked\n   118→  merge_conflict_files: [file1.ts, file2.ts]\n   119→  next_status: \"∞ Blocked\"\n   120→  summary: |\n   121→    {Brief description of what was done}\n   122→    Merge conflicts require human resolution.\n   123→    Conflicts in: {list of files}\n   124→```\n   125→\n   126→If you encounter an error:\n   127→\n   128→```\n   129→WORK_RESULT:\n   130→  success: false\n   131→  stage_completed: {{STAGE}}\n   132→  workflow: {{WORKFLOW}}\n   133→  branch_name: horizon/{identifier}\n   134→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   135→  error: |\n   136→    {What went wrong and why it couldn't be fixed}\n   137→```\n   138→\n   139→---\n   140→\n   141→# Option B: Create PR for review\n   142→\n   143→## B1: Get Repository URL\n   144→\n   145→Before creating the PR, get the repository URL:\n   146→\n   147→```bash\n   148→git remote get-url origin\n   149→```\n   150→\n   151→Include this as `repo_url` in WORK_RESULT.\n   152→\n   153→## B2: Create PR Description Document\n   154→\n   155→Before creating the PR, write a comprehensive PR description document to `horizon-docs/prs/{identifier}.md`:\n   156→\n   157→```markdown\n   158→# PR: {issue_identifier} - {issue_title}\n   159→\n   160→**Branch**: `horizon/{identifier}`\n   161→**Linear Issue**: {issue_identifier}\n   162→**Date**: {YYYY-MM-DD}\n   163→\n   164→## Summary\n   165→\n   166→{2-3 sentence description of what this PR accomplishes and why}\n   167→\n   168→## Problem\n   169→\n   170→{What problem does this solve? What was the user pain point or technical need?}\n   171→\n   172→## Solution\n   173→\n   174→{How does this PR solve the problem? Describe the approach taken.}\n   175→\n   176→## Changes\n   177→\n   178→{List the key changes made, organized by category if helpful}\n   179→\n   180→### Files Changed\n   181→- `path/to/file.ts` - {brief description of change}\n   182→- `path/to/other.ts` - {brief description of change}\n   183→\n   184→## Testing\n   185→\n   186→{How were the changes verified?}\n   187→\n   188→### Automated\n   189→- [ ] Tests pass (`npm test`)\n   190→- [ ] TypeScript compiles (`npm run typecheck`)\n   191→- [ ] Lint passes (`npm run lint`)\n   192→\n   193→### Manual Verification\n   194→{Any manual testing performed or recommended}\n   195→\n   196→## Breaking Changes\n   197→\n   198→{List any breaking changes, or \"None\" if backward compatible}\n   199→\n   200→## Migration Notes\n   201→\n   202→{Any steps needed for users upgrading, or \"None\" if not applicable}\n   203→\n   204→## Screenshots\n   205→\n   206→{If UI changes, include before/after screenshots, or \"N/A\" for non-UI changes}\n   207→\n   208→---\n   209→🤖 Created by [Horizon](https://github.com/ob1-sg/horizon) with {{PROVIDER_LINK}}\n   210→```\n   211→\n   212→Commit and push this document:\n   213→```bash\n   214→git add horizon-docs/prs/\n   215→git commit -m \"docs({identifier}): add PR description\"\n   216→git push origin horizon/{identifier}\n   217→```\n   218→\n   219→## B3: Create Pull Request\n   220→\n   221→Create the pull request using the description document:\n   222→\n   223→```bash\n   224→# Create the pull request with the description file\n   225→gh pr create \\\n   226→  --title \"{issue_identifier}: {issue_title}\" \\\n   227→  --body-file horizon-docs/prs/{identifier}.md \\\n   228→  --base main \\\n   229→  --head horizon/{identifier}\n   230→```\n   231→\n   232→Replace the placeholders:\n   233→- `{issue_identifier}`: The issue ID (e.g., RSK-123)\n   234→- `{issue_title}`: The issue title\n   235→- `{identifier}`: The issue identifier for branch naming\n   236→\n   237→**Handle the PR creation result:**\n   238→\n   239→1. **PR created successfully**: Capture the PR URL from the output\n   240→   Set `merge_status: pr_created` and `pr_url: {URL}` in WORK_RESULT.\n   241→\n   242→2. **PR creation failed**: Include the error\n   243→   Set `merge_status: pr_failed` and include error details in WORK_RESULT.\n   244→\n   245→### WORK_RESULT (Option B)\n   246→\n   247→Use this output format when you chose **Option B (PR)**.\n   248→\n   249→After completing your work and PR is created:\n   250→\n   251→```\n   252→WORK_RESULT:\n   253→  success: true\n   254→  stage_completed: {{STAGE}}\n   255→  workflow: {{WORKFLOW}}\n   256→  branch_name: horizon/{identifier}\n   257→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   258→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n   259→  pr_description_path: horizon-docs/prs/{identifier}.md\n   260→  commit_hash: {short hash on feature branch}\n   261→  merge_status: pr_created\n   262→  pr_url: {GitHub PR URL}\n   263→  next_status: \"∞ Awaiting Merge\"\n   264→  summary: |\n   265→    {Brief description of what was done}\n   266→    Files changed: {list}\n   267→    All checks pass. PR created for review.\n   268→    PR: {pr_url}\n   269→```\n   270→\n   271→If PR creation fails:\n   272→\n   273→```\n   274→WORK_RESULT:\n   275→  success: true\n   276→  stage_completed: {{STAGE}}\n   277→  workflow: {{WORKFLOW}}\n   278→  branch_name: horizon/{identifier}\n   279→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   280→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n   281→  commit_hash: {short hash on feature branch}\n   282→  merge_status: pr_failed\n   283→  next_status: \"∞ Blocked\"\n   284→  summary: |\n   285→    {Brief description of what was done}\n   286→    PR creation failed: {error message}\n   287→```\n   288→\n   289→If you encounter an error during implementation:\n   290→\n   291→```\n   292→WORK_RESULT:\n   293→  success: false\n   294→  stage_completed: {{STAGE}}\n   295→  workflow: {{WORKFLOW}}\n   296→  branch_name: horizon/{identifier}\n   297→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   298→  error: |\n   299→    {What went wrong and why it couldn't be fixed}\n   300→```\n   301→"}]},"uuid":"1a083664-a8b7-44a9-9b0e-2eddd5154b1a","timestamp":"2026-02-14T12:24:42.634Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"02116a26-03b9-4718-9600-37df5eb9e008","timestamp":"2026-02-14T12:24:42.681Z"}
{"parentUuid":"02116a26-03b9-4718-9600-37df5eb9e008","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Pxrq3hdNuiJMDNXN51iu86","type":"tool_result","content":"     1→### Step 7: Get Repository URL\n     2→\n     3→Before creating the PR, get the repository URL:\n     4→\n     5→```bash\n     6→git remote get-url origin\n     7→```\n     8→\n     9→Include this as `repo_url` in WORK_RESULT.\n    10→\n    11→### Step 8: Create PR Description Document\n    12→\n    13→Before creating the PR, write a comprehensive PR description document to `horizon-docs/prs/{identifier}.md`:\n    14→\n    15→```markdown\n    16→# PR: {issue_identifier} - {issue_title}\n    17→\n    18→**Branch**: `horizon/{identifier}`\n    19→**Linear Issue**: {issue_identifier}\n    20→**Date**: {YYYY-MM-DD}\n    21→\n    22→## Summary\n    23→\n    24→{2-3 sentence description of what this PR accomplishes and why}\n    25→\n    26→## Problem\n    27→\n    28→{What problem does this solve? What was the user pain point or technical need?}\n    29→\n    30→## Solution\n    31→\n    32→{How does this PR solve the problem? Describe the approach taken.}\n    33→\n    34→## Changes\n    35→\n    36→{List the key changes made, organized by category if helpful}\n    37→\n    38→### Files Changed\n    39→- `path/to/file.ts` - {brief description of change}\n    40→- `path/to/other.ts` - {brief description of change}\n    41→\n    42→## Testing\n    43→\n    44→{How were the changes verified?}\n    45→\n    46→### Automated\n    47→- [ ] Tests pass (`npm test`)\n    48→- [ ] TypeScript compiles (`npm run typecheck`)\n    49→- [ ] Lint passes (`npm run lint`)\n    50→\n    51→### Manual Verification\n    52→{Any manual testing performed or recommended}\n    53→\n    54→## Breaking Changes\n    55→\n    56→{List any breaking changes, or \"None\" if backward compatible}\n    57→\n    58→## Migration Notes\n    59→\n    60→{Any steps needed for users upgrading, or \"None\" if not applicable}\n    61→\n    62→## Screenshots\n    63→\n    64→{If UI changes, include before/after screenshots, or \"N/A\" for non-UI changes}\n    65→\n    66→---\n    67→🤖 Created by [Horizon](https://github.com/ob1-sg/horizon) with {{PROVIDER_LINK}}\n    68→```\n    69→\n    70→Commit and push this document:\n    71→```bash\n    72→git add horizon-docs/prs/\n    73→git commit -m \"docs({identifier}): add PR description\"\n    74→git push origin horizon/{identifier}\n    75→```\n    76→\n    77→### Step 9: Create Pull Request\n    78→\n    79→Create the pull request using the description document:\n    80→\n    81→```bash\n    82→# Create the pull request with the description file\n    83→gh pr create \\\n    84→  --title \"{issue_identifier}: {issue_title}\" \\\n    85→  --body-file horizon-docs/prs/{identifier}.md \\\n    86→  --base main \\\n    87→  --head horizon/{identifier}\n    88→```\n    89→\n    90→Replace the placeholders:\n    91→- `{issue_identifier}`: The issue ID (e.g., RSK-123)\n    92→- `{issue_title}`: The issue title\n    93→- `{identifier}`: The issue identifier for branch naming\n    94→\n    95→**Handle the PR creation result:**\n    96→\n    97→1. **PR created successfully**: Capture the PR URL from the output\n    98→   Set `merge_status: pr_created` and `pr_url: {URL}` in WORK_RESULT.\n    99→\n   100→2. **PR creation failed**: Include the error\n   101→   Set `merge_status: pr_failed` and include error details in WORK_RESULT.\n   102→\n   103→## Output Format\n   104→\n   105→After completing your work and PR is created:\n   106→\n   107→```\n   108→WORK_RESULT:\n   109→  success: true\n   110→  stage_completed: {{STAGE}}\n   111→  workflow: {{WORKFLOW}}\n   112→  branch_name: horizon/{identifier}\n   113→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   114→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n   115→  pr_description_path: horizon-docs/prs/{identifier}.md\n   116→  commit_hash: {short hash on feature branch}\n   117→  merge_status: pr_created\n   118→  pr_url: {GitHub PR URL}\n   119→  next_status: \"∞ Awaiting Merge\"\n   120→  summary: |\n   121→    {Brief description of what was done}\n   122→    Files changed: {list}\n   123→    All checks pass. PR created for review.\n   124→    PR: {pr_url}\n   125→```\n   126→\n   127→If PR creation fails:\n   128→\n   129→```\n   130→WORK_RESULT:\n   131→  success: true\n   132→  stage_completed: {{STAGE}}\n   133→  workflow: {{WORKFLOW}}\n   134→  branch_name: horizon/{identifier}\n   135→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   136→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n   137→  commit_hash: {short hash on feature branch}\n   138→  merge_status: pr_failed\n   139→  next_status: \"∞ Blocked\"\n   140→  summary: |\n   141→    {Brief description of what was done}\n   142→    PR creation failed: {error message}\n   143→```\n   144→\n   145→If you encounter an error during implementation:\n   146→\n   147→```\n   148→WORK_RESULT:\n   149→  success: false\n   150→  stage_completed: {{STAGE}}\n   151→  workflow: {{WORKFLOW}}\n   152→  branch_name: horizon/{identifier}\n   153→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   154→  error: |\n   155→    {What went wrong and why it couldn't be fixed}\n   156→```\n   157→"}]},"uuid":"f897e3fc-d7ca-491a-a528-3294ecce99a7","timestamp":"2026-02-14T12:24:42.661Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"aae43001-3c74-426b-8d83-a8acab03353e","timestamp":"2026-02-14T12:24:42.703Z"}
{"parentUuid":"aae43001-3c74-426b-8d83-a8acab03353e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VdCF4tskFHoTP31BESpccs","type":"tool_result","content":"     1→### Step 7: Get Repository URL\n     2→\n     3→Before merging, get the repository URL for Agent 3:\n     4→\n     5→```bash\n     6→git remote get-url origin\n     7→```\n     8→\n     9→Include this as `repo_url` in WORK_RESULT.\n    10→\n    11→### Step 8: Merge to Main\n    12→\n    13→After all checks pass, merge the feature branch to main:\n    14→\n    15→```bash\n    16→# Switch to main and update\n    17→git checkout main\n    18→git pull origin main\n    19→\n    20→# Attempt merge with no-ff to preserve branch history\n    21→git merge horizon/{identifier} --no-ff -m \"Merge horizon/{identifier}: {issue_title}\"\n    22→```\n    23→\n    24→**Handle the merge result:**\n    25→\n    26→1. **Clean merge (no conflicts)**: Push to main, delete feature branch\n    27→   ```bash\n    28→   git push origin main\n    29→   git branch -d horizon/{identifier}\n    30→   git push origin --delete horizon/{identifier}\n    31→   ```\n    32→   Set `merge_status: success` in WORK_RESULT.\n    33→\n    34→2. **Simple conflicts** (imports, whitespace, non-overlapping): Resolve them if obvious\n    35→   - Conflicts are purely mechanical (imports, formatting)\n    36→   - Changes don't overlap in business logic\n    37→   - Resolution is obvious and doesn't require product decisions\n    38→\n    39→   After resolving:\n    40→   ```bash\n    41→   git add .\n    42→   git commit -m \"Merge horizon/{identifier}: {issue_title}\"\n    43→   git push origin main\n    44→   git branch -d horizon/{identifier}\n    45→   git push origin --delete horizon/{identifier}\n    46→   ```\n    47→   Set `merge_status: success` in WORK_RESULT.\n    48→\n    49→3. **Complex conflicts** (business logic, requires judgment): Abort and mark blocked\n    50→   - Conflicts touch core business logic\n    51→   - Multiple approaches are possible\n    52→   - Resolution requires broader context\n    53→\n    54→   ```bash\n    55→   git merge --abort\n    56→   git checkout horizon/{identifier}\n    57→   ```\n    58→   Set `merge_status: blocked` and `merge_conflict_files: [list of files]` in WORK_RESULT.\n    59→\n    60→## Output Format\n    61→\n    62→After completing your work and merge succeeds:\n    63→\n    64→```\n    65→WORK_RESULT:\n    66→  success: true\n    67→  stage_completed: {{STAGE}}\n    68→  workflow: {{WORKFLOW}}\n    69→  branch_name: horizon/{identifier}\n    70→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n    71→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n    72→  commit_hash: {merge commit hash on main}\n    73→  merge_status: success\n    74→  next_status: \"∞ Done\"\n    75→  summary: |\n    76→    {Brief description of what was done}\n    77→    Files changed: {list}\n    78→    All checks pass. Merged to main.\n    79→```\n    80→\n    81→If work completes but merge is blocked:\n    82→\n    83→```\n    84→WORK_RESULT:\n    85→  success: true\n    86→  stage_completed: {{STAGE}}\n    87→  workflow: {{WORKFLOW}}\n    88→  branch_name: horizon/{identifier}\n    89→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n    90→  artifact_path: horizon-docs/{{ARTIFACT_DIR}}/YYYY-MM-DD-{identifier}-{slug}.md\n    91→  commit_hash: {short hash on feature branch}\n    92→  merge_status: blocked\n    93→  merge_conflict_files: [file1.ts, file2.ts]\n    94→  next_status: \"∞ Blocked\"\n    95→  summary: |\n    96→    {Brief description of what was done}\n    97→    Merge conflicts require human resolution.\n    98→    Conflicts in: {list of files}\n    99→```\n   100→\n   101→If you encounter an error:\n   102→\n   103→```\n   104→WORK_RESULT:\n   105→  success: false\n   106→  stage_completed: {{STAGE}}\n   107→  workflow: {{WORKFLOW}}\n   108→  branch_name: horizon/{identifier}\n   109→  repo_url: {git remote URL, e.g., https://github.com/owner/repo.git}\n   110→  error: |\n   111→    {What went wrong and why it couldn't be fixed}\n   112→```\n   113→"}]},"uuid":"3e97024f-241a-4f25-9b87-c1091f4f420e","timestamp":"2026-02-14T12:24:42.664Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"db0db31a-fb7a-4d01-8ce3-27c8797023fc","timestamp":"2026-02-14T12:24:42.704Z"}
{"parentUuid":"db0db31a-fb7a-4d01-8ce3-27c8797023fc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:24:44.602Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01QCTRw4V5sznGhQbtqzYdca","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JpZPckswAGYcGTMbqHCwM4","name":"Grep","input":{"pattern":"merge-auto|merge-direct|merge-pr","path":"/Users/ob1/projects/startup/horizon-cli-agent/src"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1728,"cache_creation_input_tokens":4922,"cache_read_input_tokens":13814,"cache_creation":{"ephemeral_5m_input_tokens":4922,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7xSChfa6ywpUq9ZmeNV","uuid":"070377f3-6d16-45a9-90c6-1ff6fed6cc8b"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"0e8a50e0-feb4-423a-9616-f648e9cbcc56","timestamp":"2026-02-14T12:24:44.602Z"}
{"parentUuid":"0e8a50e0-feb4-423a-9616-f648e9cbcc56","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:24:45.071Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01QCTRw4V5sznGhQbtqzYdca","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01ByDspg4ft2gB7s15W9U3iV","name":"Grep","input":{"pattern":"\"merge\"|merge","path":"/Users/ob1/projects/startup/horizon-cli-agent/src/lib","type":"ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1728,"cache_creation_input_tokens":4922,"cache_read_input_tokens":13814,"cache_creation":{"ephemeral_5m_input_tokens":4922,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7xSChfa6ywpUq9ZmeNV","uuid":"060f1d9c-61f5-4690-ab8b-f3852eb631ba"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"2ff54bb9-1a64-49ee-818c-209e1e2a21cc","timestamp":"2026-02-14T12:24:45.072Z"}
{"parentUuid":"2ff54bb9-1a64-49ee-818c-209e1e2a21cc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JpZPckswAGYcGTMbqHCwM4","type":"tool_result","content":"Found 3 files\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/setup.ts\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/prompts.ts\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/prompts.test.ts"}]},"uuid":"52c99095-5058-4cd6-b4ba-5f82f460655b","timestamp":"2026-02-14T12:24:47.202Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"c904edb4-6b3e-4b0b-bc9f-d5547550073b","timestamp":"2026-02-14T12:24:47.234Z"}
{"parentUuid":"c904edb4-6b3e-4b0b-bc9f-d5547550073b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01ByDspg4ft2gB7s15W9U3iV","type":"tool_result","content":"Found 6 files\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/setup.ts\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/prompts.ts\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/init-project.ts\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/linear-api.ts\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/prompts.test.ts"}]},"uuid":"9aa2c314-a596-48d5-934b-bdc0766f45c7","timestamp":"2026-02-14T12:24:47.307Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"1464e9a0-3047-4818-a6e0-f77499180a89","timestamp":"2026-02-14T12:24:47.338Z"}
{"parentUuid":"1464e9a0-3047-4818-a6e0-f77499180a89","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:24:48.627Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018Bjd3SRVWkBxm2HnTGDbUm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KKZHF33GB3imiHyMJtZrHu","name":"Read","input":{"file_path":"/Users/ob1/projects/startup/horizon-cli-agent/src/lib/prompts.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2268,"cache_read_input_tokens":18736,"cache_creation":{"ephemeral_5m_input_tokens":2268,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7xSYQ5fdZn2XGT2ezKk","uuid":"7a9c4597-571f-4267-bc2f-71639a5dc4d2"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"96214076-d60d-451b-b7ac-0826b674690e","timestamp":"2026-02-14T12:24:48.628Z"}
{"parentUuid":"96214076-d60d-451b-b7ac-0826b674690e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KKZHF33GB3imiHyMJtZrHu","type":"tool_result","content":"     1→import { readFileSync, existsSync } from 'fs';\n     2→import { join, dirname } from 'path';\n     3→import { fileURLToPath } from 'url';\n     4→import { getRepoRoot } from '../config.js';\n     5→\n     6→// Get the package directory for fallback prompts\n     7→const __filename = fileURLToPath(import.meta.url);\n     8→const __dirname = dirname(__filename);\n     9→const PACKAGE_ROOT = join(__dirname, '../..');\n    10→\n    11→/**\n    12→ * Loads a prompt from .horizon/prompts/ (preferred) or package prompts/ (fallback).\n    13→ * Supports template variables in the format {{VARIABLE_NAME}}.\n    14→ *\n    15→ * @param name - Prompt name without .md extension\n    16→ * @param variables - Optional object of variable names to values for template substitution\n    17→ * @returns The prompt content with variables substituted\n    18→ */\n    19→export function loadPrompt(name: string, variables?: Record<string, string>): string {\n    20→  // Try .horizon/prompts/ first (project-local)\n    21→  const projectPromptPath = join(getRepoRoot(), '.horizon', 'prompts', `${name}.md`);\n    22→\n    23→  // Fallback to package prompts/\n    24→  const packagePromptPath = join(PACKAGE_ROOT, 'prompts', `${name}.md`);\n    25→\n    26→  let promptPath: string;\n    27→  if (existsSync(projectPromptPath)) {\n    28→    promptPath = projectPromptPath;\n    29→  } else if (existsSync(packagePromptPath)) {\n    30→    promptPath = packagePromptPath;\n    31→  } else {\n    32→    throw new Error(`Prompt not found: ${name}`);\n    33→  }\n    34→\n    35→  let content = readFileSync(promptPath, 'utf-8');\n    36→\n    37→  // Substitute template variables\n    38→  if (variables) {\n    39→    for (const [key, value] of Object.entries(variables)) {\n    40→      const placeholder = `{{${key}}}`;\n    41→      content = content.replace(new RegExp(placeholder.replace(/[{}]/g, '\\\\$&'), 'g'), value);\n    42→    }\n    43→  }\n    44→\n    45→  return content;\n    46→}\n    47→\n    48→/**\n    49→ * Loads a prompt fragment from the fragments/ subdirectory.\n    50→ *\n    51→ * @param name - Fragment name without .md extension (e.g., 'merge-direct')\n    52→ * @returns The fragment content\n    53→ */\n    54→export function loadPromptFragment(name: string): string {\n    55→  // Try .horizon/prompts/fragments/ first\n    56→  const projectFragmentPath = join(getRepoRoot(), '.horizon', 'prompts', 'fragments', `${name}.md`);\n    57→\n    58→  // Fallback to package prompts/fragments/\n    59→  const packageFragmentPath = join(PACKAGE_ROOT, 'prompts', 'fragments', `${name}.md`);\n    60→\n    61→  let fragmentPath: string;\n    62→  if (existsSync(projectFragmentPath)) {\n    63→    fragmentPath = projectFragmentPath;\n    64→  } else if (existsSync(packageFragmentPath)) {\n    65→    fragmentPath = packageFragmentPath;\n    66→  } else {\n    67→    throw new Error(`Prompt fragment not found: ${name}`);\n    68→  }\n    69→\n    70→  return readFileSync(fragmentPath, 'utf-8');\n    71→}\n    72→"}]},"uuid":"4642cc26-c0fb-4402-a584-c10d79c98250","timestamp":"2026-02-14T12:24:48.691Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"b4d1da91-b16c-4185-aa80-40dc936d341e","timestamp":"2026-02-14T12:24:48.832Z"}
{"parentUuid":"b4d1da91-b16c-4185-aa80-40dc936d341e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:24:48.833Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_018Bjd3SRVWkBxm2HnTGDbUm","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LMdkwzcXaQSrtgGefwciLC","name":"Read","input":{"file_path":"/Users/ob1/projects/startup/horizon-cli-agent/src/lib/setup.ts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":2268,"cache_read_input_tokens":18736,"cache_creation":{"ephemeral_5m_input_tokens":2268,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7xSYQ5fdZn2XGT2ezKk","uuid":"bfd077bd-7f47-4af7-8667-318b4b5869a2"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"b0d37532-7b49-4686-a01d-77fccf524bf5","timestamp":"2026-02-14T12:24:48.833Z"}
{"parentUuid":"b0d37532-7b49-4686-a01d-77fccf524bf5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LMdkwzcXaQSrtgGefwciLC","type":"tool_result","content":"     1→/**\n     2→ * Shared setup module for Horizon configuration.\n     3→ * Used by both `horizon` (main loop) and `horizon config` commands.\n     4→ */\n     5→\n     6→import {\n     7→  existsSync,\n     8→  mkdirSync,\n     9→  readFileSync,\n    10→  writeFileSync,\n    11→  appendFileSync,\n    12→  copyFileSync,\n    13→  readdirSync,\n    14→} from 'fs';\n    15→import { join, dirname } from 'path';\n    16→import { fileURLToPath } from 'url';\n    17→import { createInterface } from 'readline';\n    18→import { getRepoRoot } from '../config.js';\n    19→import {\n    20→  createLinearClient,\n    21→  validateApiKey,\n    22→  getTeamByKeyOrId,\n    23→  checkHorizonStatusesExist,\n    24→  ensureHorizonStatuses,\n    25→  HORIZON_STATUS_PREFIX,\n    26→} from './linear-api.js';\n    27→import { isClaudeCliInstalled, isCodexCliInstalled, hasAnyCli, CliAvailability } from './cli-detection.js';\n    28→import { ProviderName, ClaudeModel, CodexReasoningEffort, InitResult, MergeMode } from '../types.js';\n    29→\n    30→// Get the package directory (where Horizon is installed)\n    31→const __filename = fileURLToPath(import.meta.url);\n    32→const __dirname = dirname(__filename);\n    33→const PACKAGE_ROOT = join(__dirname, '../..');\n    34→\n    35→// Team info for display\n    36→export interface TeamInfo {\n    37→  id: string;\n    38→  key: string;\n    39→  name: string;\n    40→}\n    41→\n    42→// Loaded configuration from .horizon/env\n    43→export interface LoadedConfig {\n    44→  linearApiKey?: string;\n    45→  linearTeamKey?: string;\n    46→  provider?: ProviderName;\n    47→  claudeModel?: ClaudeModel;\n    48→  codexModel?: string;\n    49→  codexReasoningEffort?: CodexReasoningEffort;\n    50→  maxIterations?: number;\n    51→  mergeMode?: MergeMode;\n    52→}\n    53→\n    54→// MCP configuration interface\n    55→interface McpConfig {\n    56→  mcpServers: {\n    57→    [key: string]: {\n    58→      type: string;\n    59→      url: string;\n    60→      headers: {\n    61→        [key: string]: string;\n    62→      };\n    63→    };\n    64→  };\n    65→}\n    66→\n    67→// ════════════════════════════════════════════════════════════════════════════\n    68→// Directory Setup\n    69→// ════════════════════════════════════════════════════════════════════════════\n    70→\n    71→/**\n    72→ * Ensures .horizon/ directory exists.\n    73→ * Returns the path to the directory.\n    74→ */\n    75→export function ensureHorizonDir(): string {\n    76→  const horizonDir = join(getRepoRoot(), '.horizon');\n    77→  if (!existsSync(horizonDir)) {\n    78→    mkdirSync(horizonDir, { recursive: true });\n    79→  }\n    80→  return horizonDir;\n    81→}\n    82→\n    83→/**\n    84→ * Ensures horizon-docs/ directory exists with README.\n    85→ */\n    86→export function ensureHorizonDocsDir(): void {\n    87→  const docsDir = join(getRepoRoot(), 'horizon-docs');\n    88→  if (!existsSync(docsDir)) {\n    89→    mkdirSync(docsDir, { recursive: true });\n    90→  }\n    91→\n    92→  // Create README if it doesn't exist\n    93→  const readmePath = join(docsDir, 'README.md');\n    94→  if (!existsSync(readmePath)) {\n    95→    const readme = `# Horizon Documentation\n    96→\n    97→This directory contains documentation automatically generated by [Horizon](https://www.npmjs.com/package/@ob1-sg/horizon), an autonomous product development system.\n    98→\n    99→## Contents\n   100→\n   101→- \\`research/\\` - Research documents for tickets\n   102→- \\`plans/\\` - Implementation plans\n   103→- \\`specifications/\\` - Technical specifications\n   104→- \\`validation/\\` - Validation reports\n   105→- \\`oneshot/\\` - Quick implementation notes\n   106→- \\`shared/\\` - Shared context between sessions\n   107→\n   108→## Note for Developers\n   109→\n   110→These files are **intended to be committed** to version control. They provide context and history for AI-assisted development work.\n   111→\n   112→While the content is AI-generated, it documents real decisions, research, and implementation details that are valuable for understanding the codebase evolution.\n   113→\n   114→Learn more: https://www.npmjs.com/package/@ob1-sg/horizon\n   115→`;\n   116→    writeFileSync(readmePath, readme);\n   117→  }\n   118→}\n   119→\n   120→/**\n   121→ * Ensures .horizon/ is in .gitignore.\n   122→ */\n   123→export function ensureGitignore(): void {\n   124→  const gitignorePath = join(getRepoRoot(), '.gitignore');\n   125→  const entry = '.horizon/';\n   126→\n   127→  let content = '';\n   128→  if (existsSync(gitignorePath)) {\n   129→    content = readFileSync(gitignorePath, 'utf-8');\n   130→  }\n   131→\n   132→  // Check if already ignored\n   133→  const lines = content.split('\\n');\n   134→  const alreadyIgnored = lines.some(\n   135→    (line) => line.trim() === entry || line.trim() === '.horizon'\n   136→  );\n   137→\n   138→  if (alreadyIgnored) {\n   139→    return;\n   140→  }\n   141→\n   142→  // Append to .gitignore\n   143→  const newContent = content.endsWith('\\n') || content === ''\n   144→    ? content + `# Horizon runtime data\\n${entry}\\n`\n   145→    : content + `\\n# Horizon runtime data\\n${entry}\\n`;\n   146→\n   147→  writeFileSync(gitignorePath, newContent, 'utf-8');\n   148→}\n   149→\n   150→// ════════════════════════════════════════════════════════════════════════════\n   151→// Config Loading/Saving\n   152→// ════════════════════════════════════════════════════════════════════════════\n   153→\n   154→/**\n   155→ * Loads existing configuration from .horizon/env file.\n   156→ */\n   157→export function loadExistingConfig(): LoadedConfig {\n   158→  const envPath = join(getRepoRoot(), '.horizon', 'env');\n   159→\n   160→  if (!existsSync(envPath)) {\n   161→    return {};\n   162→  }\n   163→\n   164→  const content = readFileSync(envPath, 'utf-8');\n   165→\n   166→  const getValue = (key: string): string | undefined => {\n   167→    const match = content.match(new RegExp(`^${key}=(.+)$`, 'm'));\n   168→    return match ? match[1].trim() : undefined;\n   169→  };\n   170→\n   171→  const config: LoadedConfig = {};\n   172→\n   173→  const apiKey = getValue('LINEAR_API_KEY');\n   174→  if (apiKey) config.linearApiKey = apiKey;\n   175→\n   176→  const teamKey = getValue('LINEAR_TEAM_KEY');\n   177→  if (teamKey) config.linearTeamKey = teamKey;\n   178→\n   179→  const provider = getValue('HORIZON_PROVIDER');\n   180→  if (provider === 'claude' || provider === 'codex') {\n   181→    config.provider = provider;\n   182→  }\n   183→\n   184→  const claudeModel = getValue('HORIZON_CLAUDE_MODEL');\n   185→  if (claudeModel === 'opus' || claudeModel === 'sonnet' || claudeModel === 'haiku') {\n   186→    config.claudeModel = claudeModel;\n   187→  }\n   188→\n   189→  const codexModel = getValue('CODEX_MODEL');\n   190→  if (codexModel) config.codexModel = codexModel;\n   191→\n   192→  const codexEffort = getValue('CODEX_REASONING_EFFORT');\n   193→  if (codexEffort === 'low' || codexEffort === 'medium' || codexEffort === 'high' || codexEffort === 'extra_high') {\n   194→    config.codexReasoningEffort = codexEffort;\n   195→  }\n   196→\n   197→  const maxIterations = getValue('HORIZON_MAX_ITERATIONS');\n   198→  if (maxIterations !== undefined) {\n   199→    const parsed = parseInt(maxIterations, 10);\n   200→    if (!isNaN(parsed)) config.maxIterations = parsed;\n   201→  }\n   202→\n   203→  const mergeMode = getValue('HORIZON_MERGE_MODE');\n   204→  if (mergeMode === 'auto' || mergeMode === 'merge' || mergeMode === 'pr') {\n   205→    config.mergeMode = mergeMode;\n   206→  }\n   207→\n   208→  return config;\n   209→}\n   210→\n   211→/**\n   212→ * Saves configuration to .horizon/env file.\n   213→ */\n   214→export function saveEnvConfig(config: LoadedConfig): void {\n   215→  const envPath = join(ensureHorizonDir(), 'env');\n   216→\n   217→  const lines: string[] = [\n   218→    '# Horizon Configuration',\n   219→    '# Generated by horizon config',\n   220→    '',\n   221→    '# Linear (required)',\n   222→  ];\n   223→\n   224→  if (config.linearApiKey) {\n   225→    lines.push(`LINEAR_API_KEY=${config.linearApiKey}`);\n   226→  }\n   227→  if (config.linearTeamKey) {\n   228→    lines.push(`LINEAR_TEAM_KEY=${config.linearTeamKey}`);\n   229→  }\n   230→\n   231→  lines.push('');\n   232→  lines.push('# Provider: \"claude\" or \"codex\"');\n   233→  lines.push(`HORIZON_PROVIDER=${config.provider || 'claude'}`);\n   234→\n   235→  lines.push('');\n   236→  lines.push('# Claude options');\n   237→  lines.push(`HORIZON_CLAUDE_MODEL=${config.claudeModel || 'opus'}`);\n   238→\n   239→  lines.push('');\n   240→  lines.push('# Codex options');\n   241→  lines.push(`CODEX_MODEL=${config.codexModel || 'gpt-5.2'}`);\n   242→  lines.push(`CODEX_REASONING_EFFORT=${config.codexReasoningEffort || 'high'}`);\n   243→\n   244→  lines.push('');\n   245→  lines.push('# Loop options (0 = unlimited)');\n   246→  lines.push(`HORIZON_MAX_ITERATIONS=${config.maxIterations ?? 0}`);\n   247→\n   248→  lines.push('');\n   249→  lines.push('# Merge mode: \"auto\" (agent decides), \"merge\" (direct to main), or \"pr\" (create pull request)');\n   250→  lines.push(`HORIZON_MERGE_MODE=${config.mergeMode || 'auto'}`);\n   251→\n   252→  lines.push(''); // Trailing newline\n   253→\n   254→  writeFileSync(envPath, lines.join('\\n'), 'utf-8');\n   255→}\n   256→\n   257→/**\n   258→ * Saves MCP configuration with Linear API key.\n   259→ */\n   260→export function saveMcpConfig(apiKey: string): void {\n   261→  const mcpPath = join(ensureHorizonDir(), 'mcp.json');\n   262→\n   263→  let config: McpConfig = { mcpServers: {} };\n   264→\n   265→  // Read existing config if it exists\n   266→  if (existsSync(mcpPath)) {\n   267→    try {\n   268→      const existing = readFileSync(mcpPath, 'utf-8');\n   269→      config = JSON.parse(existing);\n   270→      if (!config.mcpServers) {\n   271→        config.mcpServers = {};\n   272→      }\n   273→    } catch {\n   274→      config = { mcpServers: {} };\n   275→    }\n   276→  }\n   277→\n   278→  // Add or update Linear MCP server\n   279→  config.mcpServers.linear = {\n   280→    type: 'http',\n   281→    url: 'https://mcp.linear.app/mcp',\n   282→    headers: {\n   283→      Authorization: `Bearer ${apiKey}`,\n   284→    },\n   285→  };\n   286→\n   287→  writeFileSync(mcpPath, JSON.stringify(config, null, 2) + '\\n', 'utf-8');\n   288→}\n   289→\n   290→/**\n   291→ * Saves Codex MCP configuration to global ~/.codex/config.toml.\n   292→ * Uses bearer_token_env_var so the actual API key stays in .horizon/env.\n   293→ */\n   294→export function saveCodexMcpConfig(): void {\n   295→  const homeDir = process.env.HOME || process.env.USERPROFILE || '';\n   296→  const codexDir = join(homeDir, '.codex');\n   297→  const configPath = join(codexDir, 'config.toml');\n   298→\n   299→  // Ensure ~/.codex directory exists\n   300→  if (!existsSync(codexDir)) {\n   301→    mkdirSync(codexDir, { recursive: true });\n   302→  }\n   303→\n   304→  // Read existing config if it exists\n   305→  let existingContent = '';\n   306→  if (existsSync(configPath)) {\n   307→    existingContent = readFileSync(configPath, 'utf-8');\n   308→  }\n   309→\n   310→  // Check if [mcp_servers.linear] section already exists\n   311→  if (existingContent.includes('[mcp_servers.linear]')) {\n   312→    // Update the existing section - find and replace\n   313→    const linearSectionRegex = /\\[mcp_servers\\.linear\\][^\\[]*(?=\\[|$)/s;\n   314→    const newSection = `[mcp_servers.linear]\n   315→url = \"https://mcp.linear.app/mcp\"\n   316→bearer_token_env_var = \"LINEAR_API_KEY\"\n   317→\n   318→`;\n   319→    existingContent = existingContent.replace(linearSectionRegex, newSection);\n   320→  } else {\n   321→    // Append the new section\n   322→    const newSection = `\n   323→[mcp_servers.linear]\n   324→url = \"https://mcp.linear.app/mcp\"\n   325→bearer_token_env_var = \"LINEAR_API_KEY\"\n   326→`;\n   327→    existingContent = existingContent.trimEnd() + '\\n' + newSection;\n   328→  }\n   329→\n   330→  writeFileSync(configPath, existingContent, 'utf-8');\n   331→}\n   332→\n   333→// ════════════════════════════════════════════════════════════════════════════\n   334→// CLI Detection\n   335→// ════════════════════════════════════════════════════════════════════════════\n   336→\n   337→/**\n   338→ * Checks which CLIs are available and displays results one-by-one.\n   339→ * Provides real-time feedback as each check completes.\n   340→ * Returns availability, or undefined if neither is installed.\n   341→ */\n   342→export function checkAndDisplayCliAvailability(): CliAvailability | undefined {\n   343→  const claudeAvailable = isClaudeCliInstalled();\n   344→  const codexAvailable = isCodexCliInstalled();\n   345→\n   346→  const availability: CliAvailability = {\n   347→    claude: claudeAvailable,\n   348→    codex: codexAvailable,\n   349→  };\n   350→\n   351→  if (!hasAnyCli(availability)) {\n   352→    console.log('❌ Error: No coding CLI found');\n   353→    console.log('');\n   354→    console.log('   Horizon requires at least one of the following:');\n   355→    console.log('');\n   356→    console.log('   Claude Code CLI:');\n   357→    console.log('     npm install -g @anthropic-ai/claude-code');\n   358→    console.log('');\n   359→    console.log('   Codex CLI:');\n   360→    console.log('     npm install -g @openai/codex');\n   361→    console.log('');\n   362→    return undefined;\n   363→  }\n   364→\n   365→  return availability;\n   366→}\n   367→\n   368→/**\n   369→ * Auto-selects provider based on CLI availability.\n   370→ * Prefers Claude if both are available.\n   371→ */\n   372→export function autoSelectProvider(availability: CliAvailability): ProviderName {\n   373→  if (availability.claude) return 'claude';\n   374→  return 'codex';\n   375→}\n   376→\n   377→// ════════════════════════════════════════════════════════════════════════════\n   378→// Linear Setup\n   379→// ════════════════════════════════════════════════════════════════════════════\n   380→\n   381→/**\n   382→ * Validates a Linear API key.\n   383→ */\n   384→export async function validateLinearKey(apiKey: string): Promise<boolean> {\n   385→  const client = createLinearClient(apiKey);\n   386→  return await validateApiKey(client);\n   387→}\n   388→\n   389→/**\n   390→ * Fetches available teams from Linear.\n   391→ */\n   392→export async function fetchLinearTeams(apiKey: string): Promise<TeamInfo[]> {\n   393→  const client = createLinearClient(apiKey);\n   394→  const teamsResult = await client.teams();\n   395→  return teamsResult.nodes.map((t) => ({\n   396→    id: t.id,\n   397→    key: t.key,\n   398→    name: t.name,\n   399→  }));\n   400→}\n   401→\n   402→/**\n   403→ * Checks if Linear ∞ statuses exist.\n   404→ */\n   405→export async function checkLinearStatuses(apiKey: string, teamKey: string): Promise<boolean> {\n   406→  const client = createLinearClient(apiKey);\n   407→  const team = await getTeamByKeyOrId(client, teamKey);\n   408→  if (!team) return false;\n   409→  return await checkHorizonStatusesExist(client, team.id);\n   410→}\n   411→\n   412→/**\n   413→ * Creates Linear ∞ statuses.\n   414→ * Returns result with created/existing/errors counts.\n   415→ */\n   416→export async function createLinearStatuses(apiKey: string, teamKey: string): Promise<InitResult> {\n   417→  const client = createLinearClient(apiKey);\n   418→  const team = await getTeamByKeyOrId(client, teamKey);\n   419→\n   420→  if (!team) {\n   421→    return {\n   422→      success: false,\n   423→      created: [],\n   424→      existing: [],\n   425→      errors: [`Team \"${teamKey}\" not found`],\n   426→    };\n   427→  }\n   428→\n   429→  return await ensureHorizonStatuses(client, team.id);\n   430→}\n   431→\n   432→// ════════════════════════════════════════════════════════════════════════════\n   433→// File Operations\n   434→// ════════════════════════════════════════════════════════════════════════════\n   435→\n   436→/**\n   437→ * Copies prompts from package to .horizon/prompts/.\n   438→ * Assembles prompts with merge fragment based on current config.\n   439→ */\n   440→export function copyPromptsToProject(): { copied: number; mergeMode: string } {\n   441→  const sourceDir = join(PACKAGE_ROOT, 'prompts');\n   442→  const fragmentsDir = join(sourceDir, 'fragments');\n   443→  const destDir = join(ensureHorizonDir(), 'prompts');\n   444→\n   445→  if (!existsSync(destDir)) {\n   446→    mkdirSync(destDir, { recursive: true });\n   447→  }\n   448→\n   449→  if (!existsSync(sourceDir)) {\n   450→    console.log('Warning: Prompts directory not found in package.');\n   451→    return { copied: 0, mergeMode: 'auto' };\n   452→  }\n   453→\n   454→  // Load current config to determine merge mode\n   455→  const config = loadExistingConfig();\n   456→  const mergeMode = config.mergeMode || 'auto';\n   457→  const provider = config.provider || 'claude';\n   458→\n   459→  // Always use PR merge mode (worktrees don't support direct merge to main)\n   460→  const fragmentName = 'merge-pr.md';\n   461→  const fragmentPath = join(fragmentsDir, fragmentName);\n   462→  let mergeFragment = '';\n   463→  if (existsSync(fragmentPath)) {\n   464→    mergeFragment = readFileSync(fragmentPath, 'utf-8');\n   465→\n   466→    // Substitute provider link in fragment\n   467→    const providerLink = provider === 'codex'\n   468→      ? '[Codex](https://openai.com/codex)'\n   469→      : '[Claude Code](https://claude.ai/claude-code)';\n   470→    mergeFragment = mergeFragment.replace(/\\{\\{PROVIDER_LINK\\}\\}/g, providerLink);\n   471→  }\n   472→\n   473→  const files = readdirSync(sourceDir).filter((f) => f.endsWith('.md'));\n   474→  let copied = 0;\n   475→\n   476→  for (const file of files) {\n   477→    let content = readFileSync(join(sourceDir, file), 'utf-8');\n   478→\n   479→    // For worker prompts, substitute merge instructions and stage-specific placeholders\n   480→    if (file === 'agent2-worker-oneshot.md') {\n   481→      content = content.replace('{{MERGE_INSTRUCTIONS}}',\n   482→        mergeFragment\n   483→          .replace(/\\{\\{STAGE\\}\\}/g, 'oneshot')\n   484→          .replace(/\\{\\{WORKFLOW\\}\\}/g, 'oneshot')\n   485→          .replace(/\\{\\{ARTIFACT_DIR\\}\\}/g, 'oneshot')\n   486→      );\n   487→    } else if (file === 'agent2-worker-validate.md') {\n   488→      content = content.replace('{{MERGE_INSTRUCTIONS}}',\n   489→        mergeFragment\n   490→          .replace(/\\{\\{STAGE\\}\\}/g, 'validate')\n   491→          .replace(/\\{\\{WORKFLOW\\}\\}/g, 'staged')\n   492→          .replace(/\\{\\{ARTIFACT_DIR\\}\\}/g, 'validation')\n   493→      );\n   494→    }\n   495→\n   496→    writeFileSync(join(destDir, file), content);\n   497→    copied++;\n   498→  }\n   499→\n   500→  return { copied, mergeMode: 'pr (worktree)' };\n   501→}\n   502→\n   503→// ════════════════════════════════════════════════════════════════════════════\n   504→// Prompt Helpers\n   505→// ════════════════════════════════════════════════════════════════════════════\n   506→\n   507→/**\n   508→ * Creates a readline interface for prompting.\n   509→ */\n   510→export function createPromptInterface(): ReturnType<typeof createInterface> {\n   511→  return createInterface({ input: process.stdin, output: process.stdout });\n   512→}\n   513→\n   514→/**\n   515→ * Prompts for input with optional default value.\n   516→ */\n   517→export async function promptWithDefault(\n   518→  rl: ReturnType<typeof createInterface>,\n   519→  question: string,\n   520→  defaultValue?: string\n   521→): Promise<string> {\n   522→  return new Promise((resolve) => {\n   523→    const displayDefault = defaultValue ? ` [${defaultValue}]` : '';\n   524→    rl.question(`${question}${displayDefault}: `, (answer) => {\n   525→      resolve(answer.trim() || defaultValue || '');\n   526→    });\n   527→  });\n   528→}\n   529→\n   530→/**\n   531→ * Prompts for a secret value (doesn't show default).\n   532→ */\n   533→export async function promptSecret(\n   534→  rl: ReturnType<typeof createInterface>,\n   535→  question: string\n   536→): Promise<string> {\n   537→  return new Promise((resolve) => {\n   538→    rl.question(`${question}: `, (answer) => {\n   539→      resolve(answer.trim());\n   540→    });\n   541→  });\n   542→}\n   543→\n   544→/**\n   545→ * Prompts for yes/no confirmation.\n   546→ */\n   547→export async function promptConfirm(\n   548→  rl: ReturnType<typeof createInterface>,\n   549→  question: string,\n   550→  defaultYes = true\n   551→): Promise<boolean> {\n   552→  return new Promise((resolve) => {\n   553→    const hint = defaultYes ? '[Y/n]' : '[y/N]';\n   554→    rl.question(`${question} ${hint}: `, (answer) => {\n   555→      const trimmed = answer.trim().toLowerCase();\n   556→      if (trimmed === '') {\n   557→        resolve(defaultYes);\n   558→      } else {\n   559→        resolve(trimmed === 'y' || trimmed === 'yes');\n   560→      }\n   561→    });\n   562→  });\n   563→}\n   564→\n   565→/**\n   566→ * Option for numbered selection prompts.\n   567→ */\n   568→export interface SelectOption<T> {\n   569→  value: T;\n   570→  label: string;\n   571→  description?: string;\n   572→}\n   573→\n   574→/**\n   575→ * Prompts user to select from a numbered list.\n   576→ * Shows options as numbered list and accepts number input.\n   577→ * Returns the selected option's value.\n   578→ */\n   579→export async function promptSelect<T>(\n   580→  rl: ReturnType<typeof createInterface>,\n   581→  options: SelectOption<T>[],\n   582→  defaultIndex = 0\n   583→): Promise<T> {\n   584→  return new Promise((resolve) => {\n   585→    // Display numbered options\n   586→    options.forEach((opt, i) => {\n   587→      const desc = opt.description ? ` - ${opt.description}` : '';\n   588→      console.log(`  ${i + 1}. ${opt.label}${desc}`);\n   589→    });\n   590→    console.log('');\n   591→\n   592→    rl.question(`Choice [default=${defaultIndex + 1}]: `, (answer) => {\n   593→      const trimmed = answer.trim();\n   594→\n   595→      // Empty input = use default\n   596→      if (trimmed === '') {\n   597→        resolve(options[defaultIndex].value);\n   598→        return;\n   599→      }\n   600→\n   601→      // Parse number\n   602→      const num = parseInt(trimmed, 10);\n   603→      if (!isNaN(num) && num >= 1 && num <= options.length) {\n   604→        resolve(options[num - 1].value);\n   605→        return;\n   606→      }\n   607→\n   608→      // Invalid input, use default\n   609→      console.log(`Invalid choice, using default (${defaultIndex + 1})`);\n   610→      resolve(options[defaultIndex].value);\n   611→    });\n   612→  });\n   613→}\n   614→\n   615→/**\n   616→ * Masks an API key for display (shows last 4 chars).\n   617→ */\n   618→export function maskApiKey(apiKey: string): string {\n   619→  if (apiKey.length <= 4) return '****';\n   620→  return '****' + apiKey.slice(-4);\n   621→}\n   622→\n   623→// ════════════════════════════════════════════════════════════════════════════\n   624→// Codex MCP Check\n   625→// ════════════════════════════════════════════════════════════════════════════\n   626→\n   627→export { checkCodexLinearMcpConfigured as checkCodexLinearMcp } from './codex.js';\n   628→\n   629→// Re-export for convenience\n   630→export { HORIZON_STATUS_PREFIX } from './linear-api.js';\n   631→export { CliAvailability } from './cli-detection.js';\n   632→"}]},"uuid":"296b164a-35b4-4f78-867b-cd95704c8dca","timestamp":"2026-02-14T12:24:48.877Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"3c4fdd1b-649b-4b31-8248-e2f48833031f","timestamp":"2026-02-14T12:24:48.910Z"}
{"parentUuid":"3c4fdd1b-649b-4b31-8248-e2f48833031f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:24:51.552Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01SAdEiLi4YzGYVkcr4Lg4dG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017PNt8JD7Sat2MSSwrvHxRb","name":"Grep","input":{"pattern":"mergeMode|MERGE_MODE|merge_status","path":"/Users/ob1/projects/startup/horizon-cli-agent/src/lib","output_mode":"content"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9265,"cache_read_input_tokens":21004,"cache_creation":{"ephemeral_5m_input_tokens":9265,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7xSf7QDGFtv9x85Kfvg","uuid":"2e89ef50-58fb-4bf8-8df3-c4bec29a3793"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"6fc3e73d-4ac3-4a8d-a1e5-920749993435","timestamp":"2026-02-14T12:24:51.552Z"}
{"parentUuid":"6fc3e73d-4ac3-4a8d-a1e5-920749993435","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:24:51.862Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01SAdEiLi4YzGYVkcr4Lg4dG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XdjSQccMXgj14S46UJf57V","name":"Glob","input":{"pattern":"/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/*.md"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":9265,"cache_read_input_tokens":21004,"cache_creation":{"ephemeral_5m_input_tokens":9265,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7xSf7QDGFtv9x85Kfvg","uuid":"d07b63c8-5a9d-46ba-8939-991401df7508"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"d2f49fe8-2520-495e-b1c1-4aa5e97b4ae7","timestamp":"2026-02-14T12:24:51.862Z"}
{"parentUuid":"d2f49fe8-2520-495e-b1c1-4aa5e97b4ae7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017PNt8JD7Sat2MSSwrvHxRb","type":"tool_result","content":"/Users/ob1/projects/startup/horizon-cli-agent/src/lib/init-project.ts:244:    const currentMergeMode: MergeMode = existingConfig.mergeMode || 'auto';\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/init-project.ts:246:    const mergeModeOptions: SelectOption<MergeMode>[] = [\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/init-project.ts:251:    const defaultMergeIndex = mergeModeOptions.findIndex((m) => m.value === currentMergeMode);\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/init-project.ts:254:    const mergeMode = await promptSelect(rl, mergeModeOptions, defaultMergeIndex >= 0 ? defaultMergeIndex : 0);\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/init-project.ts:264:    console.log(`  Merge: ${mergeMode}`);\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/init-project.ts:280:      mergeMode,\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/setup.ts:51:  mergeMode?: MergeMode;\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/setup.ts:203:  const mergeMode = getValue('HORIZON_MERGE_MODE');\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/setup.ts:204:  if (mergeMode === 'auto' || mergeMode === 'merge' || mergeMode === 'pr') {\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/setup.ts:205:    config.mergeMode = mergeMode;\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/setup.ts:250:  lines.push(`HORIZON_MERGE_MODE=${config.mergeMode || 'auto'}`);\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/setup.ts:440:export function copyPromptsToProject(): { copied: number; mergeMode: string } {\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/setup.ts:451:    return { copied: 0, mergeMode: 'auto' };\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/setup.ts:456:  const mergeMode = config.mergeMode || 'auto';\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/setup.ts:500:  return { copied, mergeMode: 'pr (worktree)' };\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts:263:    it('returns \"auto\" when HORIZON_MERGE_MODE=auto', async () => {\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts:264:      process.env.HORIZON_MERGE_MODE = 'auto';\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts:268:      expect(config.mergeMode).toBe('auto');\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts:271:    it('returns \"auto\" when HORIZON_MERGE_MODE=AUTO (case insensitive)', async () => {\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts:272:      process.env.HORIZON_MERGE_MODE = 'AUTO';\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts:276:      expect(config.mergeMode).toBe('auto');\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts:281:      process.env.HORIZON_MERGE_MODE = 'merge';\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts:285:      expect(config.mergeMode).toBe('merge');\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts:288:    it('returns \"pr\" when HORIZON_MERGE_MODE=pr', async () => {\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts:289:      process.env.HORIZON_MERGE_MODE = 'pr';\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts:293:      expect(config.mergeMode).toBe('pr');\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts:296:    it('returns \"pr\" when HORIZON_MERGE_MODE=PR (case insensitive)', async () => {\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts:297:      process.env.HORIZON_MERGE_MODE = 'PR';\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts:301:      expect(config.mergeMode).toBe('pr');\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts:305:      process.env.HORIZON_MERGE_MODE = 'invalid';\n/Users/ob1/projects/startup/horizon-cli-agent/src/lib/__tests__/config.test.ts:309:      expect(config.mergeMode).toBe('auto');"}]},"uuid":"e4e13c6a-d95f-4749-a315-16e22645d452","timestamp":"2026-02-14T12:24:51.857Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"51b616f3-ef80-49db-892a-97d426d185b9","timestamp":"2026-02-14T12:24:51.905Z"}
{"parentUuid":"51b616f3-ef80-49db-892a-97d426d185b9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XdjSQccMXgj14S46UJf57V","type":"tool_result","content":"/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-auto.md\n/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-direct.md\n/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-pr.md"}]},"uuid":"61a59bc4-9549-4c49-9a1f-9ef296466093","timestamp":"2026-02-14T12:24:52.113Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"eddcb2f4-775b-4b05-af60-2d4aee8f4542","timestamp":"2026-02-14T12:24:52.155Z"}
{"parentUuid":"eddcb2f4-775b-4b05-af60-2d4aee8f4542","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:24:53.627Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_0191TKeTx71gRypCavjN2KLC","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Kcvwj3YaDd99eVEhHSVBDy","name":"Grep","input":{"pattern":"MergeMode","path":"/Users/ob1/projects/startup/horizon-cli-agent/src/types.ts","output_mode":"content","context":5},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":7,"cache_creation_input_tokens":1875,"cache_read_input_tokens":30269,"cache_creation":{"ephemeral_5m_input_tokens":1875,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7xStzaTBpZPy6SGRCc4","uuid":"7f6a87e8-2518-4794-a7cf-b7a6154eb4f6"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"e5c8295c-8b67-4923-8748-b4538b95cdfd","timestamp":"2026-02-14T12:24:53.627Z"}
{"parentUuid":"e5c8295c-8b67-4923-8748-b4538b95cdfd","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Kcvwj3YaDd99eVEhHSVBDy","type":"tool_result","content":"1-// Provider types\n2-\n3-export type ProviderName = 'claude' | 'codex';\n4-export type ClaudeModel = 'opus' | 'sonnet' | 'haiku';\n5-export type CodexReasoningEffort = 'low' | 'medium' | 'high' | 'extra_high';\n6:export type MergeMode = 'auto' | 'merge' | 'pr';\n7-\n8-// Claude CLI types\n9-\n10-export interface ClaudeOptions {\n11-  prompt: string;\n--\n105-  // Quick check configuration\n106-  quickCheckIntervalMinutes: number;\n107-  fullCheckIntervalMinutes: number;\n108-\n109-  // Merge mode configuration\n110:  mergeMode: MergeMode;\n111-}\n112-\n113-// Quick check result\n114-export interface QuickCheckResult {\n115-  hasWork: boolean;"}]},"uuid":"cc4b0e7e-a88c-40f0-9281-2951cfc0317d","timestamp":"2026-02-14T12:24:53.922Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"f7ac243d-4de3-4587-8b08-e3da7e83d421","timestamp":"2026-02-14T12:24:53.968Z"}
{"parentUuid":"f7ac243d-4de3-4587-8b08-e3da7e83d421","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:24:55.709Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01CFiD7MFKTADRgwzZkNq7ZZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WL91zMMUM5mZYnrudpnXzm","name":"Read","input":{"file_path":"/Users/ob1/projects/startup/horizon-cli-agent/src/lib/init-project.ts","offset":240,"limit":30},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":5,"cache_creation_input_tokens":431,"cache_read_input_tokens":32144,"cache_creation":{"ephemeral_5m_input_tokens":431,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7xT2zY6UWSW7m4cYdSW","uuid":"e8489cc9-db0a-4829-9abe-da592b774cc0"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"7187cb4a-6041-499b-aad1-f21d24fd2d8e","timestamp":"2026-02-14T12:24:55.710Z"}
{"parentUuid":"7187cb4a-6041-499b-aad1-f21d24fd2d8e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WL91zMMUM5mZYnrudpnXzm","type":"tool_result","content":"   240→    // Merge Mode Configuration\n   241→    // ═══════════════════════════════════════════════════════════════════════════\n   242→    console.log('─── Merge Mode ───\\n');\n   243→\n   244→    const currentMergeMode: MergeMode = existingConfig.mergeMode || 'auto';\n   245→\n   246→    const mergeModeOptions: SelectOption<MergeMode>[] = [\n   247→      { value: 'auto', label: 'auto', description: 'Agent decides: merge directly or create PR (recommended)' },\n   248→      { value: 'merge', label: 'merge', description: 'Merge directly to main' },\n   249→      { value: 'pr', label: 'pr', description: 'Create PR for review' },\n   250→    ];\n   251→    const defaultMergeIndex = mergeModeOptions.findIndex((m) => m.value === currentMergeMode);\n   252→\n   253→    console.log('When work completes:');\n   254→    const mergeMode = await promptSelect(rl, mergeModeOptions, defaultMergeIndex >= 0 ? defaultMergeIndex : 0);\n   255→\n   256→    console.log('');\n   257→\n   258→    // ═══════════════════════════════════════════════════════════════════════════\n   259→    // Summary\n   260→    // ═══════════════════════════════════════════════════════════════════════════\n   261→    console.log('─── Summary ───\\n');\n   262→    console.log(`  Team: ${selectedTeam.name} (${selectedTeam.key})`);\n   263→    console.log(`  Provider: ${provider}${provider === 'claude' ? ` (${claudeModel})` : ` (${codexModel})`}`);\n   264→    console.log(`  Merge: ${mergeMode}`);\n   265→    console.log(`  Max iterations: ${maxIterations === 0 ? 'unlimited' : maxIterations}`);\n   266→    console.log('');\n   267→\n   268→    // ═══════════════════════════════════════════════════════════════════════════\n   269→    // Save Configuration"}]},"uuid":"596ef10c-1370-49fe-afef-37658981ce00","timestamp":"2026-02-14T12:24:55.771Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"b4953b82-7235-4de3-b26e-16e010ace2e6","timestamp":"2026-02-14T12:24:55.805Z"}
{"parentUuid":"b4953b82-7235-4de3-b26e-16e010ace2e6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:24:57.628Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01GWYMjCJyERcWNPWQVo5wZs","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QaKd9KJURFwUdhJEubBkaH","name":"Bash","input":{"command":"cd /Users/ob1/projects/startup/horizon-cli-agent && grep -r \"merge-auto\\|merge-direct\\|merge-pr\\|loadPromptFragment.*merge\" src/ --include=\"*.ts\" 2>/dev/null || echo \"No matches found\"","description":"Search for references to merge fragment files in source code"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":4,"cache_creation_input_tokens":751,"cache_read_input_tokens":32575,"cache_creation":{"ephemeral_5m_input_tokens":751,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7xTAbwGRryaub3H4pvx","uuid":"374617fe-e72a-4789-80ae-7c7cf4ffe14b"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"4eb61e4b-7d62-464f-8c70-fc1c19d52103","timestamp":"2026-02-14T12:24:57.628Z"}
{"parentUuid":"4eb61e4b-7d62-464f-8c70-fc1c19d52103","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QaKd9KJURFwUdhJEubBkaH","type":"tool_result","content":"src/lib/setup.ts:  const fragmentName = 'merge-pr.md';\nsrc/lib/prompts.ts: * @param name - Fragment name without .md extension (e.g., 'merge-direct')\nsrc/lib/__tests__/prompts.test.ts:    const result = loadPromptFragment('merge-direct');","is_error":false}]},"uuid":"e1863ac8-1eaa-4c18-8b12-2196b17d13b4","timestamp":"2026-02-14T12:24:58.091Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"b8115cd3-b0d5-4d48-a667-d4a82a38c55b","timestamp":"2026-02-14T12:24:58.122Z"}
{"parentUuid":"b8115cd3-b0d5-4d48-a667-d4a82a38c55b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:24:59.587Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01XZLzMYSfDkE3uKgYg9xS4d","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KDzXArSUou5dLXaLayx8GR","name":"Bash","input":{"command":"cd /Users/ob1/projects/startup/horizon-cli-agent && grep -r \"MERGE_INSTRUCTIONS\" prompts/ --include=\"*.md\" | head -20","description":"Find where MERGE_INSTRUCTIONS is used in prompts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":298,"cache_read_input_tokens":33326,"cache_creation":{"ephemeral_5m_input_tokens":298,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7xTLWEypUT2mg5noJax","uuid":"333105a0-b958-44b4-8845-e9b1b1bf8aa1"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"62d9be04-5c26-4733-9864-424d5de7749b","timestamp":"2026-02-14T12:24:59.587Z"}
{"parentUuid":"62d9be04-5c26-4733-9864-424d5de7749b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KDzXArSUou5dLXaLayx8GR","type":"tool_result","content":"prompts/agent2-worker-oneshot.md:{{MERGE_INSTRUCTIONS}}\nprompts/agent2-worker-validate.md:{{MERGE_INSTRUCTIONS}}","is_error":false}]},"uuid":"f96c28ba-02fc-40d3-8805-b6f9c71c3afc","timestamp":"2026-02-14T12:24:59.704Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"cff06570-a200-4ef7-a640-7465e5ee4fc5","timestamp":"2026-02-14T12:24:59.736Z"}
{"parentUuid":"cff06570-a200-4ef7-a640-7465e5ee4fc5","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"assistant","timestamp":"2026-02-14T12:25:01.832Z","message":{"model":"claude-haiku-4-5-20251001","id":"msg_01Gh1rnf25i25b3vFLxPZynZ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01CtRJMZpm4gpcAzzfpDHnrF","name":"Bash","input":{"command":"cd /Users/ob1/projects/startup/horizon-cli-agent && grep -B5 -A5 \"MERGE_INSTRUCTIONS\" prompts/agent2-worker-oneshot.md | head -20","description":"Context around MERGE_INSTRUCTIONS in worker prompts"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":2,"cache_creation_input_tokens":342,"cache_read_input_tokens":33624,"cache_creation":{"ephemeral_5m_input_tokens":342,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"not_available"},"context_management":null},"requestId":"req_011CY7xTTXR2n8Esq9JHMizt","uuid":"4716bcd8-9396-48af-b8db-1434adbdc361"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"d016be5a-a967-41ba-bd97-f41af821dfcc","timestamp":"2026-02-14T12:25:01.832Z"}
{"parentUuid":"d016be5a-a967-41ba-bd97-f41af821dfcc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"message":{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01CtRJMZpm4gpcAzzfpDHnrF","type":"tool_result","content":"# or \"chore({identifier}): ...\" for chores\n# or \"feat({identifier}): ...\" for small features\ngit push origin horizon/{identifier}\n```\n\n{{MERGE_INSTRUCTIONS}}\n\n## Important Notes\n\n- Oneshot means ONE session - don't over-think it\n- If the task is more complex than expected, complete what you can and note it","is_error":false}]},"uuid":"0e0b8cdc-3861-473d-b4fb-97dc591c37d3","timestamp":"2026-02-14T12:25:01.926Z"},"normalizedMessages":[],"type":"agent_progress","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525"},"toolUseID":"agent_msg_01Dmvdw7ay2DDaXK3tdLT3jP","parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","uuid":"be73bb3a-2e69-4097-9dd6-373742742b16","timestamp":"2026-02-14T12:25:01.957Z"}
{"parentUuid":"be73bb3a-2e69-4097-9dd6-373742742b16","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Task","command":"entire hooks claude-code post-task"},"parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","toolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","timestamp":"2026-02-14T12:25:14.265Z","uuid":"05ae481d-cabd-4a56-abfa-68e79a1be43b"}
{"parentUuid":"05ae481d-cabd-4a56-abfa-68e79a1be43b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Task","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","toolUseID":"toolu_01JJp4Z34irSreptXtiFCexc","timestamp":"2026-02-14T12:25:14.265Z","uuid":"deb54b46-8189-4fed-b9fb-1cda7984db20"}
{"parentUuid":"a05c6fac-c6ca-4926-9372-5348f11a0e2d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JJp4Z34irSreptXtiFCexc","type":"tool_result","content":[{"type":"text","text":"Excellent! Now I have all the information I need. Let me create a comprehensive summary:\n\n## Summary: Merge Fragment Relationship Analysis\n\n### File Contents Overview\n\nThe three merge fragment files follow a **clear hierarchical structure**:\n\n#### 1. **merge-auto.md** (decision dispatcher)\n- Presents a **decision rubric** at the top with guidance on when to choose each approach\n- Prefers **Option B (PR)** for significant changes, uncertainties, and higher-risk updates\n- Prefers **Option A (direct merge)** for small, clearly safe, well-understood changes\n- Contains the **full implementation** for both Option A and Option B\n- Provides complete WORK_RESULT output formats for all scenarios (success, blocked, error)\n\n#### 2. **merge-direct.md** (focused implementation)\n- Contains **only Steps 7-8** of the merge process (repository URL and merge to main)\n- Covers merge result handling (clean merge, simple conflicts, complex conflicts)\n- Provides one output format for the WORK_RESULT\n- Does NOT include decision logic or introduction\n\n#### 3. **merge-pr.md** (focused implementation)\n- Contains **only Steps 7-9** of the PR creation process (repository URL, PR description, PR creation)\n- Covers PR result handling (success, failure)\n- Provides one output format for the WORK_RESULT\n- Does NOT include decision logic or introduction\n\n---\n\n### Relationship & Architecture\n\n**merge-auto.md does NOT delegate to the other two as sub-fragments.** Instead, it presents a **complete, standalone implementation** containing:\n- The decision rubric\n- All code from merge-direct.md (re-implemented as \"Option A\")\n- All code from merge-pr.md (re-implemented as \"Option B\")\n\nThe three files serve **different use cases**:\n- **merge-auto.md**: Used when the agent needs to decide at runtime which merge strategy to use\n- **merge-direct.md**: Used when a worker is configured to always merge directly to main\n- **merge-pr.md**: Used when a worker is configured to always create PRs\n\n---\n\n### Selection Mechanism\n\nThe selection happens in **`src/lib/setup.ts`** (lines 440-501):\n\n```typescript\nexport function copyPromptsToProject(): { copied: number; mergeMode: string } {\n  const config = loadExistingConfig();\n  const mergeMode = config.mergeMode || 'auto';\n  \n  // Line 460: Always hardcoded to PR for worktrees\n  const fragmentName = 'merge-pr.md';  // <-- Selection logic\n  let mergeFragment = '';\n  if (existsSync(fragmentPath)) {\n    mergeFragment = readFileSync(fragmentPath, 'utf-8');\n    // Substitute {{PROVIDER_LINK}} variable\n    mergeFragment = mergeFragment.replace(/\\{\\{PROVIDER_LINK\\}\\}/g, providerLink);\n  }\n  \n  // Lines 480-493: Inject fragment into worker prompts\n  if (file === 'agent2-worker-oneshot.md') {\n    content = content.replace('{{MERGE_INSTRUCTIONS}}', mergeFragment\n      .replace(/\\{\\{STAGE\\}\\}/g, 'oneshot')\n      .replace(/\\{\\{WORKFLOW\\}\\}/g, 'oneshot')\n      .replace(/\\{\\{ARTIFACT_DIR\\}\\}/g, 'oneshot')\n    );\n  } else if (file === 'agent2-worker-validate.md') {\n    content = content.replace('{{MERGE_INSTRUCTIONS}}', mergeFragment\n      .replace(/\\{\\{STAGE\\}\\}/g, 'validate')\n      // ...\n    );\n  }\n}\n```\n\n---\n\n### Key Findings\n\n1. **Current Implementation**: The code **hardcodes `merge-pr.md`** at line 460 with the comment \"Always use PR merge mode (worktrees don't support direct merge to main)\"\n\n2. **Config Not Used**: While `mergeMode` is loaded from config and offers three choices ('auto', 'merge', 'pr'), it's **read but never actually used** to select between the three fragments\n\n3. **Substitution Pattern**: The selected fragment has stage-specific template variables replaced:\n   - `{{STAGE}}` → 'oneshot' or 'validate'\n   - `{{WORKFLOW}}` → 'oneshot' or 'staged'\n   - `{{ARTIFACT_DIR}}` → 'oneshot' or 'validation'\n   - `{{PROVIDER_LINK}}` → Claude Code or Codex link\n\n4. **Injection Points**: The merge fragment is injected into worker prompts at the `{{MERGE_INSTRUCTIONS}}` placeholder, which appears near the end of the implementation steps\n\n---\n\n### Absolute File Paths\n\n- `/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-auto.md`\n- `/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-direct.md`\n- `/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-pr.md`\n- `/Users/ob1/projects/startup/horizon-cli-agent/src/lib/setup.ts` (selection logic)\n- `/Users/ob1/projects/startup/horizon-cli-agent/src/lib/init-project.ts` (user configuration)\n- `/Users/ob1/projects/startup/horizon-cli-agent/src/types.ts` (MergeMode type definition)"},{"type":"text","text":"agentId: ab21525 (for resuming to continue this agent's work if needed)\n<usage>total_tokens: 35560\ntool_uses: 14\nduration_ms: 36705</usage>"}]}]},"uuid":"1969a13a-ef96-4780-9e3f-a786a54bf598","timestamp":"2026-02-14T12:25:14.263Z","toolUseResult":{"status":"completed","prompt":"Analyze the merge fragment files in the Horizon CLI Agent repo at `/Users/ob1/projects/startup/horizon-cli-agent` to understand how `merge-auto.md`, `merge-direct.md`, and `merge-pr.md` relate to each other.\n\nSpecifically:\n1. Read all three files: `prompts/fragments/merge-auto.md`, `prompts/fragments/merge-direct.md`, `prompts/fragments/merge-pr.md`\n2. Check how they're loaded/referenced in the codebase (search for \"merge-auto\", \"merge-direct\", \"merge-pr\", \"merge\" in `src/lib/` files)\n3. Determine: Does merge-auto.md delegate to the other two as sub-fragments? Are they independent modes? How does the code select which one to use?\n\nReturn a clear summary of the relationship and the mechanism for selection.","agentId":"ab21525","content":[{"type":"text","text":"Excellent! Now I have all the information I need. Let me create a comprehensive summary:\n\n## Summary: Merge Fragment Relationship Analysis\n\n### File Contents Overview\n\nThe three merge fragment files follow a **clear hierarchical structure**:\n\n#### 1. **merge-auto.md** (decision dispatcher)\n- Presents a **decision rubric** at the top with guidance on when to choose each approach\n- Prefers **Option B (PR)** for significant changes, uncertainties, and higher-risk updates\n- Prefers **Option A (direct merge)** for small, clearly safe, well-understood changes\n- Contains the **full implementation** for both Option A and Option B\n- Provides complete WORK_RESULT output formats for all scenarios (success, blocked, error)\n\n#### 2. **merge-direct.md** (focused implementation)\n- Contains **only Steps 7-8** of the merge process (repository URL and merge to main)\n- Covers merge result handling (clean merge, simple conflicts, complex conflicts)\n- Provides one output format for the WORK_RESULT\n- Does NOT include decision logic or introduction\n\n#### 3. **merge-pr.md** (focused implementation)\n- Contains **only Steps 7-9** of the PR creation process (repository URL, PR description, PR creation)\n- Covers PR result handling (success, failure)\n- Provides one output format for the WORK_RESULT\n- Does NOT include decision logic or introduction\n\n---\n\n### Relationship & Architecture\n\n**merge-auto.md does NOT delegate to the other two as sub-fragments.** Instead, it presents a **complete, standalone implementation** containing:\n- The decision rubric\n- All code from merge-direct.md (re-implemented as \"Option A\")\n- All code from merge-pr.md (re-implemented as \"Option B\")\n\nThe three files serve **different use cases**:\n- **merge-auto.md**: Used when the agent needs to decide at runtime which merge strategy to use\n- **merge-direct.md**: Used when a worker is configured to always merge directly to main\n- **merge-pr.md**: Used when a worker is configured to always create PRs\n\n---\n\n### Selection Mechanism\n\nThe selection happens in **`src/lib/setup.ts`** (lines 440-501):\n\n```typescript\nexport function copyPromptsToProject(): { copied: number; mergeMode: string } {\n  const config = loadExistingConfig();\n  const mergeMode = config.mergeMode || 'auto';\n  \n  // Line 460: Always hardcoded to PR for worktrees\n  const fragmentName = 'merge-pr.md';  // <-- Selection logic\n  let mergeFragment = '';\n  if (existsSync(fragmentPath)) {\n    mergeFragment = readFileSync(fragmentPath, 'utf-8');\n    // Substitute {{PROVIDER_LINK}} variable\n    mergeFragment = mergeFragment.replace(/\\{\\{PROVIDER_LINK\\}\\}/g, providerLink);\n  }\n  \n  // Lines 480-493: Inject fragment into worker prompts\n  if (file === 'agent2-worker-oneshot.md') {\n    content = content.replace('{{MERGE_INSTRUCTIONS}}', mergeFragment\n      .replace(/\\{\\{STAGE\\}\\}/g, 'oneshot')\n      .replace(/\\{\\{WORKFLOW\\}\\}/g, 'oneshot')\n      .replace(/\\{\\{ARTIFACT_DIR\\}\\}/g, 'oneshot')\n    );\n  } else if (file === 'agent2-worker-validate.md') {\n    content = content.replace('{{MERGE_INSTRUCTIONS}}', mergeFragment\n      .replace(/\\{\\{STAGE\\}\\}/g, 'validate')\n      // ...\n    );\n  }\n}\n```\n\n---\n\n### Key Findings\n\n1. **Current Implementation**: The code **hardcodes `merge-pr.md`** at line 460 with the comment \"Always use PR merge mode (worktrees don't support direct merge to main)\"\n\n2. **Config Not Used**: While `mergeMode` is loaded from config and offers three choices ('auto', 'merge', 'pr'), it's **read but never actually used** to select between the three fragments\n\n3. **Substitution Pattern**: The selected fragment has stage-specific template variables replaced:\n   - `{{STAGE}}` → 'oneshot' or 'validate'\n   - `{{WORKFLOW}}` → 'oneshot' or 'staged'\n   - `{{ARTIFACT_DIR}}` → 'oneshot' or 'validation'\n   - `{{PROVIDER_LINK}}` → Claude Code or Codex link\n\n4. **Injection Points**: The merge fragment is injected into worker prompts at the `{{MERGE_INSTRUCTIONS}}` placeholder, which appears near the end of the implementation steps\n\n---\n\n### Absolute File Paths\n\n- `/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-auto.md`\n- `/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-direct.md`\n- `/Users/ob1/projects/startup/horizon-cli-agent/prompts/fragments/merge-pr.md`\n- `/Users/ob1/projects/startup/horizon-cli-agent/src/lib/setup.ts` (selection logic)\n- `/Users/ob1/projects/startup/horizon-cli-agent/src/lib/init-project.ts` (user configuration)\n- `/Users/ob1/projects/startup/horizon-cli-agent/src/types.ts` (MergeMode type definition)"}],"totalDurationMs":36705,"totalTokens":35560,"totalToolUseCount":14,"usage":{"input_tokens":1,"cache_creation_input_tokens":271,"cache_read_input_tokens":33966,"output_tokens":1322,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":271},"inference_geo":"","iterations":[],"speed":"standard"}},"sourceToolAssistantUUID":"a05c6fac-c6ca-4926-9372-5348f11a0e2d"}
{"parentUuid":"1969a13a-ef96-4780-9e3f-a786a54bf598","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_016YJ3ij5psztH6RtdvR8ytG","type":"message","role":"assistant","content":[{"type":"text","text":"Here's what Horizon actually does:\n\n**The three fragments are independent, mutually exclusive modes** — not a parent/sub-fragment hierarchy:\n\n- **`merge-auto.md`** — self-contained decision rubric + full implementation of both direct merge and PR paths inline\n- **`merge-direct.md`** — standalone direct-merge-only instructions\n- **`merge-pr.md`** — standalone PR-only instructions\n\nHorizon's `setup.ts` selects **one** fragment based on a `mergeMode` config (`'auto' | 'merge' | 'pr'`), then injects it into worker prompts at the `{{MERGE_INSTRUCTIONS}}` placeholder. In practice, Horizon currently hardcodes `merge-pr.md` because worktrees don't support direct merge to main.\n\nKey detail: the fragment is injected into **worker prompts** (`agent2-worker-oneshot.md`, `agent2-worker-validate.md`), not used by a separate merge agent.\n\nNow, this reveals a **design divergence** in the napoli-matcha plan: the plan introduces a separate merge agent that runs after the worker, whereas Horizon embeds merge instructions directly in the worker prompt."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1731,"cache_read_input_tokens":49847,"cache_creation":{"ephemeral_5m_input_tokens":1731,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xUZ2qkp78RtqknSyuB","type":"assistant","uuid":"a639524b-c064-48a1-b699-77b82a342a25","timestamp":"2026-02-14T12:25:22.742Z"}
{"parentUuid":"a639524b-c064-48a1-b699-77b82a342a25","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_016YJ3ij5psztH6RtdvR8ytG","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AaxYeZHdiHoM6mtGr4FZED","name":"AskUserQuestion","input":{"questions":[{"question":"Given Horizon's pattern, how should napoli-matcha handle merge fragments?","header":"Merge design","options":[{"label":"Keep separate merge agent","description":"Keep the plan's design: merge agent runs after worker+test-writer in the same sandbox. Select one of the three fragments based on a mergeMode config (default: 'auto'). The fragment becomes the merge agent's prompt."},{"label":"Embed in worker prompts","description":"Match Horizon's pattern: inject the selected merge fragment into worker-oneshot.md and worker-validate.md via {{MERGE_INSTRUCTIONS}}. No separate merge agent — the worker handles merge as its final step."},{"label":"Hybrid approach","description":"Use {{MERGE_INSTRUCTIONS}} in worker prompts for oneshot (simple tasks), but use a separate merge agent for terminal staged tickets (more complex, benefit from isolated merge decision)."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1731,"cache_read_input_tokens":49847,"cache_creation":{"ephemeral_5m_input_tokens":1731,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xUZ2qkp78RtqknSyuB","type":"assistant","uuid":"c6002289-02aa-465e-bc07-6963b287ba8c","timestamp":"2026-02-14T12:25:27.912Z"}
{"parentUuid":"c6002289-02aa-465e-bc07-6963b287ba8c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01AaxYeZHdiHoM6mtGr4FZED","parentToolUseID":"toolu_01AaxYeZHdiHoM6mtGr4FZED","uuid":"76bbb4c1-8a25-4df4-bcf2-7c8691f659dd","timestamp":"2026-02-14T12:25:27.914Z"}
{"parentUuid":"76bbb4c1-8a25-4df4-bcf2-7c8691f659dd","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01AaxYeZHdiHoM6mtGr4FZED","toolUseID":"toolu_01AaxYeZHdiHoM6mtGr4FZED","timestamp":"2026-02-14T12:26:03.592Z","uuid":"bcc09516-9b1f-4b96-bb19-c4f156e62fd3"}
{"parentUuid":"c6002289-02aa-465e-bc07-6963b287ba8c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Given Horizon's pattern, how should napoli-matcha handle merge fragments?\"=\"Keep separate merge agent\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01AaxYeZHdiHoM6mtGr4FZED"}]},"uuid":"43e508c9-327e-40c2-873c-c76e71699be7","timestamp":"2026-02-14T12:26:03.589Z","toolUseResult":{"questions":[{"question":"Given Horizon's pattern, how should napoli-matcha handle merge fragments?","header":"Merge design","options":[{"label":"Keep separate merge agent","description":"Keep the plan's design: merge agent runs after worker+test-writer in the same sandbox. Select one of the three fragments based on a mergeMode config (default: 'auto'). The fragment becomes the merge agent's prompt."},{"label":"Embed in worker prompts","description":"Match Horizon's pattern: inject the selected merge fragment into worker-oneshot.md and worker-validate.md via {{MERGE_INSTRUCTIONS}}. No separate merge agent — the worker handles merge as its final step."},{"label":"Hybrid approach","description":"Use {{MERGE_INSTRUCTIONS}} in worker prompts for oneshot (simple tasks), but use a separate merge agent for terminal staged tickets (more complex, benefit from isolated merge decision)."}],"multiSelect":false}],"answers":{"Given Horizon's pattern, how should napoli-matcha handle merge fragments?":"Keep separate merge agent"}},"sourceToolAssistantUUID":"c6002289-02aa-465e-bc07-6963b287ba8c"}
{"parentUuid":"43e508c9-327e-40c2-873c-c76e71699be7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01MYxnGqSDS76yPsLcngnSSR","type":"message","role":"assistant","content":[{"type":"text","text":"Good — keeping the separate merge agent. Now let me clarify the fragment relationship in the plan: three independent modes, selected by config, used as the merge agent's prompt."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":609,"cache_read_input_tokens":51578,"cache_creation":{"ephemeral_5m_input_tokens":609,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xYAnyom5NBkFU36tgR","type":"assistant","uuid":"d533adbb-d9eb-4265-846c-43f459d42d8a","timestamp":"2026-02-14T12:26:06.860Z"}
{"parentUuid":"d533adbb-d9eb-4265-846c-43f459d42d8a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01MYxnGqSDS76yPsLcngnSSR","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Gcg8gu4DK7Doet3Vwcc3cG","name":"Read","input":{"file_path":"REDACTED.md","offset":590,"limit":20},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":609,"cache_read_input_tokens":51578,"cache_creation":{"ephemeral_5m_input_tokens":609,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xYAnyom5NBkFU36tgR","type":"assistant","uuid":"b01564e8-6adf-4f84-acbf-66a490524601","timestamp":"2026-02-14T12:26:07.500Z"}
{"parentUuid":"b01564e8-6adf-4f84-acbf-66a490524601","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01Gcg8gu4DK7Doet3Vwcc3cG","parentToolUseID":"toolu_01Gcg8gu4DK7Doet3Vwcc3cG","uuid":"ebdcc4d0-ea36-4282-a86b-72bdb199a851","timestamp":"2026-02-14T12:26:07.504Z"}
{"parentUuid":"ebdcc4d0-ea36-4282-a86b-72bdb199a851","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01Gcg8gu4DK7Doet3Vwcc3cG","toolUseID":"toolu_01Gcg8gu4DK7Doet3Vwcc3cG","timestamp":"2026-02-14T12:26:07.581Z","uuid":"8fa4be37-8925-4f4c-8560-820cb5b4b47d"}
{"parentUuid":"8fa4be37-8925-4f4c-8560-820cb5b4b47d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01Gcg8gu4DK7Doet3Vwcc3cG","toolUseID":"toolu_01Gcg8gu4DK7Doet3Vwcc3cG","timestamp":"2026-02-14T12:26:07.581Z","uuid":"4f422f25-b6ab-4094-bbd7-456a70e8fbaf"}
{"parentUuid":"b01564e8-6adf-4f84-acbf-66a490524601","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Gcg8gu4DK7Doet3Vwcc3cG","type":"tool_result","content":"   590→Merging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n   591→\n   592→The merge agent:\n   593→1. Runs in the same sandbox (has full repo state, branch, test results)\n   594→2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n   595→3. Executes `git merge --no-ff` or `gh pr create` accordingly\n   596→4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n   597→\n   598→The orchestrator maps `merge_status` to the final ticket status:\n   599→- `success` → `Done`\n   600→- `pr_created` → `Awaiting Merge`\n   601→- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n   602→\n   603→For non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n   604→\n   605→---\n   606→\n   607→## Phase 4: Entry Point (`src/index.ts`)\n   608→\n   609→Two modes of operation:"}]},"uuid":"d61745ac-b572-4e7c-9a9c-b5a09e66f1fe","timestamp":"2026-02-14T12:26:07.580Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"Merging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:","numLines":20,"startLine":590,"totalLines":1089}},"sourceToolAssistantUUID":"b01564e8-6adf-4f84-acbf-66a490524601"}
{"parentUuid":"d61745ac-b572-4e7c-9a9c-b5a09e66f1fe","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01JzvQMvzQjFxUaB3fM7o1ZN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018cY4qgFneHUGjo5k2LXQGC","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"The merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`","new_string":"The merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Receives one of three merge fragment prompts (selected by `mergeMode` config):\n   - **`merge-auto.md`** (default) — self-contained decision rubric that evaluates the change and chooses direct merge or PR at runtime\n   - **`merge-direct.md`** — always merge directly to main (for trusted, low-risk pipelines)\n   - **`merge-pr.md`** — always create a PR (for repos requiring review)\n3. Executes `git merge --no-ff` or `gh pr create` based on the selected mode's instructions\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe three fragments are **independent, mutually exclusive modes** (ported from Horizon). Each is a complete standalone prompt — `merge-auto.md` does not delegate to the other two. The orchestrator selects which fragment to load via a `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`)."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":495,"cache_read_input_tokens":52187,"cache_creation":{"ephemeral_5m_input_tokens":495,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xYTekPpLSKzeRfVEfM","type":"assistant","uuid":"52e9d6a9-0c03-4b7a-8c4f-797657f6670e","timestamp":"2026-02-14T12:26:15.147Z"}
{"parentUuid":"52e9d6a9-0c03-4b7a-8c4f-797657f6670e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_018cY4qgFneHUGjo5k2LXQGC","parentToolUseID":"toolu_018cY4qgFneHUGjo5k2LXQGC","uuid":"9c2fde25-c443-4cd1-b906-5b28821a079e","timestamp":"2026-02-14T12:26:15.149Z"}
{"parentUuid":"9c2fde25-c443-4cd1-b906-5b28821a079e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_018cY4qgFneHUGjo5k2LXQGC","toolUseID":"toolu_018cY4qgFneHUGjo5k2LXQGC","timestamp":"2026-02-14T12:26:15.194Z","uuid":"37612eef-8d26-4705-b5d0-73da57976b99"}
{"parentUuid":"37612eef-8d26-4705-b5d0-73da57976b99","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_018cY4qgFneHUGjo5k2LXQGC","toolUseID":"toolu_018cY4qgFneHUGjo5k2LXQGC","timestamp":"2026-02-14T12:26:15.194Z","uuid":"608fdb98-c2ca-40b0-a0e8-abf8a61db4cb"}
{"parentUuid":"52e9d6a9-0c03-4b7a-8c4f-797657f6670e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018cY4qgFneHUGjo5k2LXQGC","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"611430ed-12c3-4788-afeb-ac58aad8c773","timestamp":"2026-02-14T12:26:15.193Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"The merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`","newString":"The merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Receives one of three merge fragment prompts (selected by `mergeMode` config):\n   - **`merge-auto.md`** (default) — self-contained decision rubric that evaluates the change and chooses direct merge or PR at runtime\n   - **`merge-direct.md`** — always merge directly to main (for trusted, low-risk pipelines)\n   - **`merge-pr.md`** — always create a PR (for repos requiring review)\n3. Executes `git merge --no-ff` or `gh pr create` based on the selected mode's instructions\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe three fragments are **independent, mutually exclusive modes** (ported from Horizon). Each is a complete standalone prompt — `merge-auto.md` does not delegate to the other two. The orchestrator selects which fragment to load via a `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`).","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. PromptLoader                      — depends_on: []\n3. TaskStatus enum + helpers         — depends_on: []\n4. SpecAgent (Phase 1)               — depends_on: [1, 2]\n5. Orchestrator refactor (Phase 3)   — depends_on: [2, 3]\n6. Test-Writer (Phase 5)             — depends_on: [5]\n7. Entry Point (Phase 4)             — depends_on: [4, 5]\n8. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #2 (PromptLoader), #3 (TaskStatus), #8 (Prompt adaptations)\n  Wave 2: #4 (SpecAgent), #5 (Orchestrator)  — #4 needs #1+#2, #5 needs #2+#3\n  Wave 3: #6 (Test-Writer), #7 (Entry Point) — #6 needs #5, #7 needs #4+#5\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #8 is pure markdown edits with no code dependencies — safe for wave 1\n- #4 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n- Merge agent is part of #5 (Orchestrator) — uses merge-auto.md fragment via PromptLoader\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status\n\n**Crash recovery (worker failure)**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.\n\n**Crash recovery (orchestrator failure)**: If the orchestrator process itself crashes while tickets are `* In Progress`, those tickets remain stuck — `isActionable()` only matches `Needs *` statuses. In v1, a human must manually reset orphaned `In Progress` tickets back to their `Needs *` counterpart to resume processing. A future version could add a startup sweep or timeout-based recovery.\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### Agent Runner Pattern\n\n`runWorkerAgent()`, `runTestWriterAgent()`, and `runMergeAgent()` all follow the same pattern inherited from the existing `executeClaudeCommand()`:\n\n1. Open a PTY session in the Daytona sandbox via the SDK\n2. Invoke `claude -p '<prompt>' --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n3. Stream stdout line-by-line, parse JSON events, log to file\n4. Extract structured output (WORK_RESULT / TEST_RESULT) from the `result` event\n5. Return parsed result\n\nThe only difference between the three is which prompt they receive and which output block they parse.\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR\n3. Executes `git merge --no-ff` or `gh pr create` accordingly\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox, checkout branch\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)\n  5. Return combined result (stage + test summary + merge status)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {{TICKET_CONTEXT}}\n**Branch diff vs main**: {{BRANCH_DIFF}}\n**Is terminal ticket**: {{IS_TERMINAL}}\n{{CHAIN_TICKETS}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nprivate codeProducingStages = new Set([\n  \"Needs Implement\",\n  \"Needs Validate\",\n  \"Needs Oneshot\",\n]);\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `inProgressStatus()` — Status Transition Helper\n\nMaps each actionable `Needs *` status to its corresponding `* In Progress` status:\n\n```typescript\nconst inProgressMap: Record<string, TaskStatus> = {\n  [TaskStatus.NeedsResearch]:      TaskStatus.ResearchInProgress,\n  [TaskStatus.NeedsSpecification]: TaskStatus.SpecificationInProgress,\n  [TaskStatus.NeedsPlan]:          TaskStatus.PlanInProgress,\n  [TaskStatus.NeedsImplement]:     TaskStatus.ImplementInProgress,\n  [TaskStatus.NeedsValidate]:      TaskStatus.ValidateInProgress,\n  [TaskStatus.NeedsOneshot]:       TaskStatus.OneshotInProgress,\n};\n\nfunction inProgressStatus(status: TaskStatus): TaskStatus {\n  return inProgressMap[status] ?? status;\n}\n```\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n","structuredPatch":[{"oldStart":591,"oldLines":10,"newStart":591,"newLines":15,"lines":[" "," The merge agent:"," 1. Runs in the same sandbox (has full repo state, branch, test results)","-2. Uses the `merge-auto.md` rubric to decide: direct merge vs PR","-3. Executes `git merge --no-ff` or `gh pr create` accordingly","+2. Receives one of three merge fragment prompts (selected by `mergeMode` config):","+   - **`merge-auto.md`** (default) — self-contained decision rubric that evaluates the change and chooses direct merge or PR at runtime","+   - **`merge-direct.md`** — always merge directly to main (for trusted, low-risk pipelines)","+   - **`merge-pr.md`** — always create a PR (for repos requiring review)","+3. Executes `git merge --no-ff` or `gh pr create` based on the selected mode's instructions"," 4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`"," ","+The three fragments are **independent, mutually exclusive modes** (ported from Horizon). Each is a complete standalone prompt — `merge-auto.md` does not delegate to the other two. The orchestrator selects which fragment to load via a `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`).","+"," The orchestrator maps `merge_status` to the final ticket status:"," - `success` → `Done`"," - `pr_created` → `Awaiting Merge`"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"52e9d6a9-0c03-4b7a-8c4f-797657f6670e"}
{"parentUuid":"611430ed-12c3-4788-afeb-ac58aad8c773","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01YYopr5VTbhnuD2veeUvov2","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me also update the Files table and the PromptLoader section to be consistent."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":543,"cache_read_input_tokens":52682,"cache_creation":{"ephemeral_5m_input_tokens":543,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xZ2CaeLvigbR9R8tZu","type":"assistant","uuid":"bb9e0aa2-e61d-49b1-8dbd-7b964b8c727f","timestamp":"2026-02-14T12:26:17.874Z"}
{"parentUuid":"bb9e0aa2-e61d-49b1-8dbd-7b964b8c727f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01YYopr5VTbhnuD2veeUvov2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011uq8eEGaJT95ZCKSpZg4yy","name":"Read","input":{"file_path":"REDACTED.md","offset":1038,"limit":12},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":543,"cache_read_input_tokens":52682,"cache_creation":{"ephemeral_5m_input_tokens":543,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xZ2CaeLvigbR9R8tZu","type":"assistant","uuid":"ac06dea2-c71f-4867-95d7-ab8309ecaf77","timestamp":"2026-02-14T12:26:18.652Z"}
{"parentUuid":"ac06dea2-c71f-4867-95d7-ab8309ecaf77","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_011uq8eEGaJT95ZCKSpZg4yy","parentToolUseID":"toolu_011uq8eEGaJT95ZCKSpZg4yy","uuid":"72d8d9c9-9905-419d-a894-8bcc80730914","timestamp":"2026-02-14T12:26:18.655Z"}
{"parentUuid":"72d8d9c9-9905-419d-a894-8bcc80730914","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_011uq8eEGaJT95ZCKSpZg4yy","toolUseID":"toolu_011uq8eEGaJT95ZCKSpZg4yy","timestamp":"2026-02-14T12:26:18.723Z","uuid":"4098fb49-4576-48a1-b896-3bb91e5f5569"}
{"parentUuid":"4098fb49-4576-48a1-b896-3bb91e5f5569","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_011uq8eEGaJT95ZCKSpZg4yy","toolUseID":"toolu_011uq8eEGaJT95ZCKSpZg4yy","timestamp":"2026-02-14T12:26:18.723Z","uuid":"ffcf1f1e-a841-4737-b8ec-49bc300ddee0"}
{"parentUuid":"ac06dea2-c71f-4867-95d7-ab8309ecaf77","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_011uq8eEGaJT95ZCKSpZg4yy","type":"tool_result","content":"  1038→\n  1039→Each `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n  1040→\n  1041→```typescript\n  1042→// Example: buildTestWriterPrompt\n  1043→const template = loadPrompt(\"agent2-worker-test.md\");\n  1044→return fillTemplate(template, {\n  1045→  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  1046→  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  1047→  IS_TERMINAL: String(isTerminal),\n  1048→  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n  1049→});"}]},"uuid":"eb21ced8-ca94-4e52-b640-c1f50bb4fbcb","timestamp":"2026-02-14T12:26:18.722Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});","numLines":12,"startLine":1038,"totalLines":1094}},"sourceToolAssistantUUID":"ac06dea2-c71f-4867-95d7-ab8309ecaf77"}
{"parentUuid":"eb21ced8-ca94-4e52-b640-c1f50bb4fbcb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01CPhcMAvr8DwxNSyuLT8iMY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017e5KpUCxay9eFibZA2e6op","name":"Read","input":{"file_path":"REDACTED.md","offset":1049,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":450,"cache_read_input_tokens":53225,"cache_creation":{"ephemeral_5m_input_tokens":450,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xZHKAkbL3wQ9NEzJVe","type":"assistant","uuid":"7ad69fcc-e71a-4a6f-a919-50e9848ddaac","timestamp":"2026-02-14T12:26:21.894Z"}
{"parentUuid":"7ad69fcc-e71a-4a6f-a919-50e9848ddaac","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_017e5KpUCxay9eFibZA2e6op","parentToolUseID":"toolu_017e5KpUCxay9eFibZA2e6op","uuid":"451cd83a-2f8d-45a9-983f-cf26301d7d2d","timestamp":"2026-02-14T12:26:21.897Z"}
{"parentUuid":"451cd83a-2f8d-45a9-983f-cf26301d7d2d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_017e5KpUCxay9eFibZA2e6op","toolUseID":"toolu_017e5KpUCxay9eFibZA2e6op","timestamp":"2026-02-14T12:26:21.963Z","uuid":"f5cc11a5-bc86-4289-ab67-bdc05384cb71"}
{"parentUuid":"f5cc11a5-bc86-4289-ab67-bdc05384cb71","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_017e5KpUCxay9eFibZA2e6op","toolUseID":"toolu_017e5KpUCxay9eFibZA2e6op","timestamp":"2026-02-14T12:26:21.963Z","uuid":"a2c88ff9-4619-4ee1-b50f-c790152307ea"}
{"parentUuid":"7ad69fcc-e71a-4a6f-a919-50e9848ddaac","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017e5KpUCxay9eFibZA2e6op","type":"tool_result","content":"  1049→});\n  1050→```\n  1051→\n  1052→For the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n  1053→\n  1054→---\n  1055→\n  1056→## Files\n  1057→\n  1058→| File | Change |\n  1059→|------|--------|\n  1060→| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n  1061→| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n  1062→| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n  1063→| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |"}]},"uuid":"9f14f94a-e46d-44fe-812a-5a9330406e8e","timestamp":"2026-02-14T12:26:21.962Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"});\n```\n\nFor the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |","numLines":15,"startLine":1049,"totalLines":1094}},"sourceToolAssistantUUID":"7ad69fcc-e71a-4a6f-a919-50e9848ddaac"}
{"parentUuid":"9f14f94a-e46d-44fe-812a-5a9330406e8e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01KXCTLHJbPg9uw9Q95ef4Kd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LinFbcChsrz7eD1aSPbcL8","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"For the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.","new_string":"For the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n\n```typescript\n// Example: buildMergePrompt\nconst fragmentMap: Record<string, string> = {\n  auto:  \"fragments/merge-auto.md\",\n  merge: \"fragments/merge-direct.md\",\n  pr:    \"fragments/merge-pr.md\",\n};\nconst template = loadPrompt(fragmentMap[this.mergeMode]);\nreturn fillTemplate(template, {\n  BRANCH_NAME: this.branchName(task),\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n});\n```"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":417,"cache_read_input_tokens":53675,"output_tokens":378,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":417},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7xZX9cyD3Tnp7dbiE64","type":"assistant","uuid":"495b0d40-b08d-48af-97f7-fe48f1327255","timestamp":"2026-02-14T12:26:27.686Z"}
{"parentUuid":"495b0d40-b08d-48af-97f7-fe48f1327255","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01LinFbcChsrz7eD1aSPbcL8","parentToolUseID":"toolu_01LinFbcChsrz7eD1aSPbcL8","uuid":"7f81d463-1e0b-4534-8f68-c6708d6a0959","timestamp":"2026-02-14T12:26:27.690Z"}
{"parentUuid":"7f81d463-1e0b-4534-8f68-c6708d6a0959","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01LinFbcChsrz7eD1aSPbcL8","toolUseID":"toolu_01LinFbcChsrz7eD1aSPbcL8","timestamp":"2026-02-14T12:26:27.741Z","uuid":"0f70815d-6421-42b4-982a-aac991c7c713"}
{"parentUuid":"0f70815d-6421-42b4-982a-aac991c7c713","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01LinFbcChsrz7eD1aSPbcL8","toolUseID":"toolu_01LinFbcChsrz7eD1aSPbcL8","timestamp":"2026-02-14T12:26:27.741Z","uuid":"ab35057a-a6e7-4315-a3b3-bb36f57c3687"}
{"parentUuid":"495b0d40-b08d-48af-97f7-fe48f1327255","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LinFbcChsrz7eD1aSPbcL8","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"e6ab642a-a06e-4aa1-aae2-11576fa16838","timestamp":"2026-02-14T12:26:27.740Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"For the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.","newString":"For the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n\n```typescript\n// Example: buildMergePrompt\nconst fragmentMap: Record<string, string> = {\n  auto:  \"fragments/merge-auto.md\",\n  merge: \"fragments/merge-direct.md\",\n  pr:    \"fragments/merge-pr.md\",\n};\nconst template = loadPrompt(fragmentMap[this.mergeMode]);\nreturn fillTemplate(template, {\n  BRANCH_NAME: this.branchName(task),\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n});\n```","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. PromptLoader                      — depends_on: []\n3. TaskStatus enum + helpers         — depends_on: []\n4. SpecAgent (Phase 1)               — depends_on: [1, 2]\n5. Orchestrator refactor (Phase 3)   — depends_on: [2, 3]\n6. Test-Writer (Phase 5)             — depends_on: [5]\n7. Entry Point (Phase 4)             — depends_on: [4, 5]\n8. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #2 (PromptLoader), #3 (TaskStatus), #8 (Prompt adaptations)\n  Wave 2: #4 (SpecAgent), #5 (Orchestrator)  — #4 needs #1+#2, #5 needs #2+#3\n  Wave 3: #6 (Test-Writer), #7 (Entry Point) — #6 needs #5, #7 needs #4+#5\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #8 is pure markdown edits with no code dependencies — safe for wave 1\n- #4 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n- Merge agent is part of #5 (Orchestrator) — uses merge-auto.md fragment via PromptLoader\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status\n\n**Crash recovery (worker failure)**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.\n\n**Crash recovery (orchestrator failure)**: If the orchestrator process itself crashes while tickets are `* In Progress`, those tickets remain stuck — `isActionable()` only matches `Needs *` statuses. In v1, a human must manually reset orphaned `In Progress` tickets back to their `Needs *` counterpart to resume processing. A future version could add a startup sweep or timeout-based recovery.\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### Agent Runner Pattern\n\n`runWorkerAgent()`, `runTestWriterAgent()`, and `runMergeAgent()` all follow the same pattern inherited from the existing `executeClaudeCommand()`:\n\n1. Open a PTY session in the Daytona sandbox via the SDK\n2. Invoke `claude -p '<prompt>' --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n3. Stream stdout line-by-line, parse JSON events, log to file\n4. Extract structured output (WORK_RESULT / TEST_RESULT) from the `result` event\n5. Return parsed result\n\nThe only difference between the three is which prompt they receive and which output block they parse.\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Receives one of three merge fragment prompts (selected by `mergeMode` config):\n   - **`merge-auto.md`** (default) — self-contained decision rubric that evaluates the change and chooses direct merge or PR at runtime\n   - **`merge-direct.md`** — always merge directly to main (for trusted, low-risk pipelines)\n   - **`merge-pr.md`** — always create a PR (for repos requiring review)\n3. Executes `git merge --no-ff` or `gh pr create` based on the selected mode's instructions\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe three fragments are **independent, mutually exclusive modes** (ported from Horizon). Each is a complete standalone prompt — `merge-auto.md` does not delegate to the other two. The orchestrator selects which fragment to load via a `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`).\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox, checkout branch\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)\n  5. Return combined result (stage + test summary + merge status)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {{TICKET_CONTEXT}}\n**Branch diff vs main**: {{BRANCH_DIFF}}\n**Is terminal ticket**: {{IS_TERMINAL}}\n{{CHAIN_TICKETS}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nprivate codeProducingStages = new Set([\n  \"Needs Implement\",\n  \"Needs Validate\",\n  \"Needs Oneshot\",\n]);\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `inProgressStatus()` — Status Transition Helper\n\nMaps each actionable `Needs *` status to its corresponding `* In Progress` status:\n\n```typescript\nconst inProgressMap: Record<string, TaskStatus> = {\n  [TaskStatus.NeedsResearch]:      TaskStatus.ResearchInProgress,\n  [TaskStatus.NeedsSpecification]: TaskStatus.SpecificationInProgress,\n  [TaskStatus.NeedsPlan]:          TaskStatus.PlanInProgress,\n  [TaskStatus.NeedsImplement]:     TaskStatus.ImplementInProgress,\n  [TaskStatus.NeedsValidate]:      TaskStatus.ValidateInProgress,\n  [TaskStatus.NeedsOneshot]:       TaskStatus.OneshotInProgress,\n};\n\nfunction inProgressStatus(status: TaskStatus): TaskStatus {\n  return inProgressMap[status] ?? status;\n}\n```\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n","structuredPatch":[{"oldStart":1049,"oldLines":8,"newStart":1049,"newLines":23,"lines":[" });"," ```"," ","-For the merge agent, `buildMergePrompt()` loads the appropriate merge fragment (`merge-auto.md` by default) and fills in the branch name, ticket context, and test results.","+For the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):"," ","+```typescript","+// Example: buildMergePrompt","+const fragmentMap: Record<string, string> = {","+  auto:  \"fragments/merge-auto.md\",","+  merge: \"fragments/merge-direct.md\",","+  pr:    \"fragments/merge-pr.md\",","+};","+const template = loadPrompt(fragmentMap[this.mergeMode]);","+return fillTemplate(template, {","+  BRANCH_NAME: this.branchName(task),","+  TICKET_CONTEXT: `${task.title}\\n${task.description}`,","+  TEST_RESULTS: testResult?.summary ?? \"No tests run\",","+});","+```","+"," ---"," "," ## Files"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"495b0d40-b08d-48af-97f7-fe48f1327255"}
{"parentUuid":"e6ab642a-a06e-4aa1-aae2-11576fa16838","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01Dd1uLhtFHusjDT6o3g85xv","type":"message","role":"assistant","content":[{"type":"text","text":"Now update the Files table entries for the merge fragments."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":423,"cache_read_input_tokens":54092,"cache_creation":{"ephemeral_5m_input_tokens":423,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xZwrfk9zwyAdMYBdJh","type":"assistant","uuid":"e04d0c9f-d6ab-4b02-9923-500042f54c87","timestamp":"2026-02-14T12:26:30.208Z"}
{"parentUuid":"e04d0c9f-d6ab-4b02-9923-500042f54c87","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01Dd1uLhtFHusjDT6o3g85xv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Qtc9cJoZR28hqTqTDfzcu2","name":"Read","input":{"file_path":"REDACTED.md","offset":1072,"limit":10},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":423,"cache_read_input_tokens":54092,"cache_creation":{"ephemeral_5m_input_tokens":423,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xZwrfk9zwyAdMYBdJh","type":"assistant","uuid":"206ee199-f9f1-4e21-9a46-46c9b941fd8f","timestamp":"2026-02-14T12:26:30.830Z"}
{"parentUuid":"206ee199-f9f1-4e21-9a46-46c9b941fd8f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01Qtc9cJoZR28hqTqTDfzcu2","parentToolUseID":"toolu_01Qtc9cJoZR28hqTqTDfzcu2","uuid":"9d60e78b-2635-4397-843a-a9fcfcae5de1","timestamp":"2026-02-14T12:26:30.833Z"}
{"parentUuid":"9d60e78b-2635-4397-843a-a9fcfcae5de1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01Qtc9cJoZR28hqTqTDfzcu2","toolUseID":"toolu_01Qtc9cJoZR28hqTqTDfzcu2","timestamp":"2026-02-14T12:26:30.890Z","uuid":"953816ee-c210-4190-ba2f-f3b2ae0658b7"}
{"parentUuid":"953816ee-c210-4190-ba2f-f3b2ae0658b7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01Qtc9cJoZR28hqTqTDfzcu2","toolUseID":"toolu_01Qtc9cJoZR28hqTqTDfzcu2","timestamp":"2026-02-14T12:26:30.890Z","uuid":"3fee4e76-8de6-4f9e-bc2f-df61ea7c11ca"}
{"parentUuid":"206ee199-f9f1-4e21-9a46-46c9b941fd8f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Qtc9cJoZR28hqTqTDfzcu2","type":"tool_result","content":"  1072→\n  1073→| File | Change |\n  1074→|------|--------|\n  1075→| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n  1076→| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n  1077→| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n  1078→| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n  1079→| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n  1080→| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n  1081→| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |"}]},"uuid":"ea916ead-3a85-4137-a500-159ed299480f","timestamp":"2026-02-14T12:26:30.889Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |","numLines":10,"startLine":1072,"totalLines":1109}},"sourceToolAssistantUUID":"206ee199-f9f1-4e21-9a46-46c9b941fd8f"}
{"parentUuid":"ea916ead-3a85-4137-a500-159ed299480f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01CbWCUjU64GLoWNfCsaHqQt","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YaDkiN8c8P9HNm2hKXSKfr","name":"Read","input":{"file_path":"REDACTED.md","offset":1081,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":551,"cache_read_input_tokens":54515,"cache_creation":{"ephemeral_5m_input_tokens":551,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xaBL2tQdFosxSMdM3Y","type":"assistant","uuid":"a7af2f2d-1b0d-492f-b703-098ced01508e","timestamp":"2026-02-14T12:26:33.788Z"}
{"parentUuid":"a7af2f2d-1b0d-492f-b703-098ced01508e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01YaDkiN8c8P9HNm2hKXSKfr","parentToolUseID":"toolu_01YaDkiN8c8P9HNm2hKXSKfr","uuid":"63e3d123-9393-4288-a82b-5ac3dc112be9","timestamp":"2026-02-14T12:26:33.790Z"}
{"parentUuid":"63e3d123-9393-4288-a82b-5ac3dc112be9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01YaDkiN8c8P9HNm2hKXSKfr","toolUseID":"toolu_01YaDkiN8c8P9HNm2hKXSKfr","timestamp":"2026-02-14T12:26:33.846Z","uuid":"acc4294a-e0e1-47cc-98aa-424375377e96"}
{"parentUuid":"acc4294a-e0e1-47cc-98aa-424375377e96","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01YaDkiN8c8P9HNm2hKXSKfr","toolUseID":"toolu_01YaDkiN8c8P9HNm2hKXSKfr","timestamp":"2026-02-14T12:26:33.846Z","uuid":"c4cb3617-54ed-450e-9745-76fe2f514ef9"}
{"parentUuid":"a7af2f2d-1b0d-492f-b703-098ced01508e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YaDkiN8c8P9HNm2hKXSKfr","type":"tool_result","content":"  1081→| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n  1082→| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n  1083→| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n  1084→| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n  1085→| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n  1086→| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n  1087→| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n  1088→| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |\n  1089→\n  1090→---\n  1091→\n  1092→## Verification\n  1093→\n  1094→1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n  1095→2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups."}]},"uuid":"aef9cca8-8210-4e42-b2cc-b9acc840bba4","timestamp":"2026-02-14T12:26:33.845Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.","numLines":15,"startLine":1081,"totalLines":1109}},"sourceToolAssistantUUID":"a7af2f2d-1b0d-492f-b703-098ced01508e"}
{"parentUuid":"aef9cca8-8210-4e42-b2cc-b9acc840bba4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01B5jqy6UDACWT2AJA7WFsAJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LEmMFfYbq7LBPKyZ1v5hvT","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |","new_string":"| `prompts/fragments/merge-auto.md` | **Existing** — Self-contained merge agent prompt for `auto` mode. Evaluates the change at runtime and chooses direct merge or PR. Default `mergeMode`. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Standalone merge agent prompt for `merge` mode. Always merges directly to main. |\n| `prompts/fragments/merge-pr.md` | **Existing** — Standalone merge agent prompt for `pr` mode. Always creates a PR. |"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":606,"cache_read_input_tokens":55066,"cache_creation":{"ephemeral_5m_input_tokens":606,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xaPx4Ca54C3J2eNgkz","type":"assistant","uuid":"dce4ec2e-f0b2-4248-ac33-dc7f93c165c3","timestamp":"2026-02-14T12:26:39.493Z"}
{"parentUuid":"dce4ec2e-f0b2-4248-ac33-dc7f93c165c3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01LEmMFfYbq7LBPKyZ1v5hvT","parentToolUseID":"toolu_01LEmMFfYbq7LBPKyZ1v5hvT","uuid":"ba45f4e7-3799-4a08-bd2d-c5d8aff70ebc","timestamp":"2026-02-14T12:26:39.495Z"}
{"parentUuid":"ba45f4e7-3799-4a08-bd2d-c5d8aff70ebc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01LEmMFfYbq7LBPKyZ1v5hvT","toolUseID":"toolu_01LEmMFfYbq7LBPKyZ1v5hvT","timestamp":"2026-02-14T12:26:39.541Z","uuid":"18bc504b-3868-4906-b723-16083f846782"}
{"parentUuid":"18bc504b-3868-4906-b723-16083f846782","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01LEmMFfYbq7LBPKyZ1v5hvT","toolUseID":"toolu_01LEmMFfYbq7LBPKyZ1v5hvT","timestamp":"2026-02-14T12:26:39.541Z","uuid":"f1fad555-77ae-4cf5-93ff-0927b92f05ef"}
{"parentUuid":"dce4ec2e-f0b2-4248-ac33-dc7f93c165c3","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LEmMFfYbq7LBPKyZ1v5hvT","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"1fb5600c-6c20-432a-8fdf-b60cd07c64ed","timestamp":"2026-02-14T12:26:39.540Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |","newString":"| `prompts/fragments/merge-auto.md` | **Existing** — Self-contained merge agent prompt for `auto` mode. Evaluates the change at runtime and chooses direct merge or PR. Default `mergeMode`. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Standalone merge agent prompt for `merge` mode. Always merges directly to main. |\n| `prompts/fragments/merge-pr.md` | **Existing** — Standalone merge agent prompt for `pr` mode. Always creates a PR. |","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. PromptLoader                      — depends_on: []\n3. TaskStatus enum + helpers         — depends_on: []\n4. SpecAgent (Phase 1)               — depends_on: [1, 2]\n5. Orchestrator refactor (Phase 3)   — depends_on: [2, 3]\n6. Test-Writer (Phase 5)             — depends_on: [5]\n7. Entry Point (Phase 4)             — depends_on: [4, 5]\n8. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #2 (PromptLoader), #3 (TaskStatus), #8 (Prompt adaptations)\n  Wave 2: #4 (SpecAgent), #5 (Orchestrator)  — #4 needs #1+#2, #5 needs #2+#3\n  Wave 3: #6 (Test-Writer), #7 (Entry Point) — #6 needs #5, #7 needs #4+#5\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #8 is pure markdown edits with no code dependencies — safe for wave 1\n- #4 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n- Merge agent is part of #5 (Orchestrator) — uses merge-auto.md fragment via PromptLoader\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status\n\n**Crash recovery (worker failure)**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.\n\n**Crash recovery (orchestrator failure)**: If the orchestrator process itself crashes while tickets are `* In Progress`, those tickets remain stuck — `isActionable()` only matches `Needs *` statuses. In v1, a human must manually reset orphaned `In Progress` tickets back to their `Needs *` counterpart to resume processing. A future version could add a startup sweep or timeout-based recovery.\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### Agent Runner Pattern\n\n`runWorkerAgent()`, `runTestWriterAgent()`, and `runMergeAgent()` all follow the same pattern inherited from the existing `executeClaudeCommand()`:\n\n1. Open a PTY session in the Daytona sandbox via the SDK\n2. Invoke `claude -p '<prompt>' --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n3. Stream stdout line-by-line, parse JSON events, log to file\n4. Extract structured output (WORK_RESULT / TEST_RESULT) from the `result` event\n5. Return parsed result\n\nThe only difference between the three is which prompt they receive and which output block they parse.\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Receives one of three merge fragment prompts (selected by `mergeMode` config):\n   - **`merge-auto.md`** (default) — self-contained decision rubric that evaluates the change and chooses direct merge or PR at runtime\n   - **`merge-direct.md`** — always merge directly to main (for trusted, low-risk pipelines)\n   - **`merge-pr.md`** — always create a PR (for repos requiring review)\n3. Executes `git merge --no-ff` or `gh pr create` based on the selected mode's instructions\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe three fragments are **independent, mutually exclusive modes** (ported from Horizon). Each is a complete standalone prompt — `merge-auto.md` does not delegate to the other two. The orchestrator selects which fragment to load via a `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`).\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox, checkout branch\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)\n  5. Return combined result (stage + test summary + merge status)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {{TICKET_CONTEXT}}\n**Branch diff vs main**: {{BRANCH_DIFF}}\n**Is terminal ticket**: {{IS_TERMINAL}}\n{{CHAIN_TICKETS}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nprivate codeProducingStages = new Set([\n  \"Needs Implement\",\n  \"Needs Validate\",\n  \"Needs Oneshot\",\n]);\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `inProgressStatus()` — Status Transition Helper\n\nMaps each actionable `Needs *` status to its corresponding `* In Progress` status:\n\n```typescript\nconst inProgressMap: Record<string, TaskStatus> = {\n  [TaskStatus.NeedsResearch]:      TaskStatus.ResearchInProgress,\n  [TaskStatus.NeedsSpecification]: TaskStatus.SpecificationInProgress,\n  [TaskStatus.NeedsPlan]:          TaskStatus.PlanInProgress,\n  [TaskStatus.NeedsImplement]:     TaskStatus.ImplementInProgress,\n  [TaskStatus.NeedsValidate]:      TaskStatus.ValidateInProgress,\n  [TaskStatus.NeedsOneshot]:       TaskStatus.OneshotInProgress,\n};\n\nfunction inProgressStatus(status: TaskStatus): TaskStatus {\n  return inProgressMap[status] ?? status;\n}\n```\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n\n```typescript\n// Example: buildMergePrompt\nconst fragmentMap: Record<string, string> = {\n  auto:  \"fragments/merge-auto.md\",\n  merge: \"fragments/merge-direct.md\",\n  pr:    \"fragments/merge-pr.md\",\n};\nconst template = loadPrompt(fragmentMap[this.mergeMode]);\nreturn fillTemplate(template, {\n  BRANCH_NAME: this.branchName(task),\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n});\n```\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |\n| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n","structuredPatch":[{"oldStart":1083,"oldLines":9,"newStart":1083,"newLines":9,"lines":[" | `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |"," | `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |"," | `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |","-| `prompts/fragments/merge-auto.md` | **Existing** — Used by merge agent as the decision rubric (auto mode). Already ported from Horizon. |","-| `prompts/fragments/merge-direct.md` | **Existing** — Direct merge instructions. Available if merge mode is overridden to `merge`. |","-| `prompts/fragments/merge-pr.md` | **Existing** — PR-only instructions. Available if merge mode is overridden to `pr`. |","+| `prompts/fragments/merge-auto.md` | **Existing** — Self-contained merge agent prompt for `auto` mode. Evaluates the change at runtime and chooses direct merge or PR. Default `mergeMode`. |","+| `prompts/fragments/merge-direct.md` | **Existing** — Standalone merge agent prompt for `merge` mode. Always merges directly to main. |","+| `prompts/fragments/merge-pr.md` | **Existing** — Standalone merge agent prompt for `pr` mode. Always creates a PR. |"," "," ---"," "]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"dce4ec2e-f0b2-4248-ac33-dc7f93c165c3"}
{"parentUuid":"1fb5600c-6c20-432a-8fdf-b60cd07c64ed","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01HxSJwKu1fmaa6wZQpCwxQM","type":"message","role":"assistant","content":[{"type":"text","text":"Issue #4 done — merge fragments are now clearly documented as three independent, mutually exclusive modes selected by `mergeMode` config. Moving to Issue #5.\n\n### Issue 5: \"Changes vs. previous plan\" table may confuse fresh readers\n\nThe table at line ~917 (\"Changes Required for Variant Support vs. previous plan\") is a diff from an earlier version of this document."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":423,"cache_read_input_tokens":55672,"cache_creation":{"ephemeral_5m_input_tokens":423,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xapJmbpzNPTHFMEQYm","type":"assistant","uuid":"ce069b32-ccc2-4be3-8a5d-2dcc279f4e3b","timestamp":"2026-02-14T12:26:45.672Z"}
{"parentUuid":"ce069b32-ccc2-4be3-8a5d-2dcc279f4e3b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01HxSJwKu1fmaa6wZQpCwxQM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Nk1fmXqTwhfBze88HezgBn","name":"AskUserQuestion","input":{"questions":[{"question":"The 'Changes Required for Variant Support (vs. previous plan)' table references a plan version that no longer exists in the document. How should we handle it?","header":"Stale diff table","options":[{"label":"Remove entirely","description":"The current plan is self-contained without it. All the information in the table is already covered in the relevant sections above."},{"label":"Convert to Design Decisions","description":"Rewrite as a 'Design Decisions' or 'Architecture Notes' section explaining WHY these choices were made, rather than what changed from a previous version."},{"label":"Keep as-is","description":"It's useful reference for anyone who saw the earlier version. Leave it with a note that it's historical context."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":423,"cache_read_input_tokens":55672,"output_tokens":326,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":423},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7xapJmbpzNPTHFMEQYm","type":"assistant","uuid":"413f2307-d7e5-4125-8f4e-9829c7b098a6","timestamp":"2026-02-14T12:26:50.795Z"}
{"parentUuid":"413f2307-d7e5-4125-8f4e-9829c7b098a6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01Nk1fmXqTwhfBze88HezgBn","parentToolUseID":"toolu_01Nk1fmXqTwhfBze88HezgBn","uuid":"f8f705d4-d9ea-4dce-acae-f6e57e182f81","timestamp":"2026-02-14T12:26:50.801Z"}
{"parentUuid":"f8f705d4-d9ea-4dce-acae-f6e57e182f81","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01Nk1fmXqTwhfBze88HezgBn","toolUseID":"toolu_01Nk1fmXqTwhfBze88HezgBn","timestamp":"2026-02-14T12:27:41.538Z","uuid":"e285afee-9132-4206-93f0-3a6164067841"}
{"parentUuid":"413f2307-d7e5-4125-8f4e-9829c7b098a6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"The 'Changes Required for Variant Support (vs. previous plan)' table references a plan version that no longer exists in the document. How should we handle it?\"=\"Remove entirely\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01Nk1fmXqTwhfBze88HezgBn"}]},"uuid":"981e8ed0-845d-4105-9be4-da5bdb808c6e","timestamp":"2026-02-14T12:27:41.534Z","toolUseResult":{"questions":[{"question":"The 'Changes Required for Variant Support (vs. previous plan)' table references a plan version that no longer exists in the document. How should we handle it?","header":"Stale diff table","options":[{"label":"Remove entirely","description":"The current plan is self-contained without it. All the information in the table is already covered in the relevant sections above."},{"label":"Convert to Design Decisions","description":"Rewrite as a 'Design Decisions' or 'Architecture Notes' section explaining WHY these choices were made, rather than what changed from a previous version."},{"label":"Keep as-is","description":"It's useful reference for anyone who saw the earlier version. Leave it with a note that it's historical context."}],"multiSelect":false}],"answers":{"The 'Changes Required for Variant Support (vs. previous plan)' table references a plan version that no longer exists in the document. How should we handle it?":"Remove entirely"}},"sourceToolAssistantUUID":"413f2307-d7e5-4125-8f4e-9829c7b098a6"}
{"parentUuid":"981e8ed0-845d-4105-9be4-da5bdb808c6e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01K9uR8mWgYh7ns5XTHP4Ymq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017eaoE2qMmMgqg55WwvDuoX","name":"Read","input":{"file_path":"REDACTED.md","offset":915,"limit":40},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":395,"cache_read_input_tokens":56095,"cache_creation":{"ephemeral_5m_input_tokens":395,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xfPUfcSvWtpyReBscP","type":"assistant","uuid":"d309ba4c-b0d8-424e-9bda-066bab8c9dd8","timestamp":"2026-02-14T12:27:44.576Z"}
{"parentUuid":"d309ba4c-b0d8-424e-9bda-066bab8c9dd8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_017eaoE2qMmMgqg55WwvDuoX","parentToolUseID":"toolu_017eaoE2qMmMgqg55WwvDuoX","uuid":"15578fb4-3cc0-471f-9903-20be7a476d9e","timestamp":"2026-02-14T12:27:44.579Z"}
{"parentUuid":"15578fb4-3cc0-471f-9903-20be7a476d9e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_017eaoE2qMmMgqg55WwvDuoX","toolUseID":"toolu_017eaoE2qMmMgqg55WwvDuoX","timestamp":"2026-02-14T12:27:44.646Z","uuid":"3fe0cf66-3334-4782-8e09-c5c9e242f5b6"}
{"parentUuid":"3fe0cf66-3334-4782-8e09-c5c9e242f5b6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_017eaoE2qMmMgqg55WwvDuoX","toolUseID":"toolu_017eaoE2qMmMgqg55WwvDuoX","timestamp":"2026-02-14T12:27:44.646Z","uuid":"10a13155-d669-4f8f-8cb7-99d076257939"}
{"parentUuid":"d309ba4c-b0d8-424e-9bda-066bab8c9dd8","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017eaoE2qMmMgqg55WwvDuoX","type":"tool_result","content":"   915→\n   916→function inProgressStatus(status: TaskStatus): TaskStatus {\n   917→  return inProgressMap[status] ?? status;\n   918→}\n   919→```\n   920→\n   921→### Single Task Loader\n   922→\n   923→**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n   924→\n   925→## Changes Required for Variant Support (vs. previous plan)\n   926→\n   927→Summary of what the variant group feature specifically adds or changes:\n   928→\n   929→| Component | Previous Plan | Change for Variants |\n   930→|-----------|--------------|-------------------|\n   931→| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n   932→| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n   933→| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n   934→| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n   935→| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n   936→| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n   937→| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n   938→| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n   939→| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n   940→| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n   941→| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n   942→| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n   943→| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n   944→| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n   945→\n   946→---\n   947→\n   948→## Variant Example: End-to-End\n   949→\n   950→User: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n   951→\n   952→Spec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n   953→\n   954→```"}]},"uuid":"94b9e74b-7a19-487c-9003-b241848f73cb","timestamp":"2026-02-14T12:27:44.645Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"\nfunction inProgressStatus(status: TaskStatus): TaskStatus {\n  return inProgressMap[status] ?? status;\n}\n```\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```","numLines":40,"startLine":915,"totalLines":1109}},"sourceToolAssistantUUID":"d309ba4c-b0d8-424e-9bda-066bab8c9dd8"}
{"parentUuid":"94b9e74b-7a19-487c-9003-b241848f73cb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_019riUgqihcwMXPDvisottWD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019L2QQPjuhGs3vfCJFWXGZT","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End","new_string":"## Variant Example: End-to-End"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1023,"cache_read_input_tokens":56490,"cache_creation":{"ephemeral_5m_input_tokens":1023,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xfcfvXH1tuvitXmwYJ","type":"assistant","uuid":"1e586907-180b-47d7-abc4-d8dd0dfa773e","timestamp":"2026-02-14T12:27:51.947Z"}
{"parentUuid":"1e586907-180b-47d7-abc4-d8dd0dfa773e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_019L2QQPjuhGs3vfCJFWXGZT","parentToolUseID":"toolu_019L2QQPjuhGs3vfCJFWXGZT","uuid":"4512f8ee-f62a-47af-b093-a81653eb8cb6","timestamp":"2026-02-14T12:27:51.950Z"}
{"parentUuid":"4512f8ee-f62a-47af-b093-a81653eb8cb6","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_019L2QQPjuhGs3vfCJFWXGZT","toolUseID":"toolu_019L2QQPjuhGs3vfCJFWXGZT","timestamp":"2026-02-14T12:27:52.004Z","uuid":"b9ca0faf-3ebd-418a-b250-318ca005f16c"}
{"parentUuid":"b9ca0faf-3ebd-418a-b250-318ca005f16c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_019L2QQPjuhGs3vfCJFWXGZT","toolUseID":"toolu_019L2QQPjuhGs3vfCJFWXGZT","timestamp":"2026-02-14T12:27:52.004Z","uuid":"da015686-869f-4fee-92b7-f577624ba669"}
{"parentUuid":"1e586907-180b-47d7-abc4-d8dd0dfa773e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019L2QQPjuhGs3vfCJFWXGZT","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"318c2bee-0633-4a30-b983-f5cc68782277","timestamp":"2026-02-14T12:27:52.003Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End","newString":"## Variant Example: End-to-End","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. PromptLoader                      — depends_on: []\n3. TaskStatus enum + helpers         — depends_on: []\n4. SpecAgent (Phase 1)               — depends_on: [1, 2]\n5. Orchestrator refactor (Phase 3)   — depends_on: [2, 3]\n6. Test-Writer (Phase 5)             — depends_on: [5]\n7. Entry Point (Phase 4)             — depends_on: [4, 5]\n8. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #2 (PromptLoader), #3 (TaskStatus), #8 (Prompt adaptations)\n  Wave 2: #4 (SpecAgent), #5 (Orchestrator)  — #4 needs #1+#2, #5 needs #2+#3\n  Wave 3: #6 (Test-Writer), #7 (Entry Point) — #6 needs #5, #7 needs #4+#5\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #8 is pure markdown edits with no code dependencies — safe for wave 1\n- #4 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n- Merge agent is part of #5 (Orchestrator) — uses merge-auto.md fragment via PromptLoader\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status\n\n**Crash recovery (worker failure)**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.\n\n**Crash recovery (orchestrator failure)**: If the orchestrator process itself crashes while tickets are `* In Progress`, those tickets remain stuck — `isActionable()` only matches `Needs *` statuses. In v1, a human must manually reset orphaned `In Progress` tickets back to their `Needs *` counterpart to resume processing. A future version could add a startup sweep or timeout-based recovery.\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### Agent Runner Pattern\n\n`runWorkerAgent()`, `runTestWriterAgent()`, and `runMergeAgent()` all follow the same pattern inherited from the existing `executeClaudeCommand()`:\n\n1. Open a PTY session in the Daytona sandbox via the SDK\n2. Invoke `claude -p '<prompt>' --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n3. Stream stdout line-by-line, parse JSON events, log to file\n4. Extract structured output (WORK_RESULT / TEST_RESULT) from the `result` event\n5. Return parsed result\n\nThe only difference between the three is which prompt they receive and which output block they parse.\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Receives one of three merge fragment prompts (selected by `mergeMode` config):\n   - **`merge-auto.md`** (default) — self-contained decision rubric that evaluates the change and chooses direct merge or PR at runtime\n   - **`merge-direct.md`** — always merge directly to main (for trusted, low-risk pipelines)\n   - **`merge-pr.md`** — always create a PR (for repos requiring review)\n3. Executes `git merge --no-ff` or `gh pr create` based on the selected mode's instructions\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe three fragments are **independent, mutually exclusive modes** (ported from Horizon). Each is a complete standalone prompt — `merge-auto.md` does not delegate to the other two. The orchestrator selects which fragment to load via a `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`).\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox, checkout branch\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)\n  5. Return combined result (stage + test summary + merge status)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {{TICKET_CONTEXT}}\n**Branch diff vs main**: {{BRANCH_DIFF}}\n**Is terminal ticket**: {{IS_TERMINAL}}\n{{CHAIN_TICKETS}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nprivate codeProducingStages = new Set([\n  \"Needs Implement\",\n  \"Needs Validate\",\n  \"Needs Oneshot\",\n]);\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `inProgressStatus()` — Status Transition Helper\n\nMaps each actionable `Needs *` status to its corresponding `* In Progress` status:\n\n```typescript\nconst inProgressMap: Record<string, TaskStatus> = {\n  [TaskStatus.NeedsResearch]:      TaskStatus.ResearchInProgress,\n  [TaskStatus.NeedsSpecification]: TaskStatus.SpecificationInProgress,\n  [TaskStatus.NeedsPlan]:          TaskStatus.PlanInProgress,\n  [TaskStatus.NeedsImplement]:     TaskStatus.ImplementInProgress,\n  [TaskStatus.NeedsValidate]:      TaskStatus.ValidateInProgress,\n  [TaskStatus.NeedsOneshot]:       TaskStatus.OneshotInProgress,\n};\n\nfunction inProgressStatus(status: TaskStatus): TaskStatus {\n  return inProgressMap[status] ?? status;\n}\n```\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Changes Required for Variant Support (vs. previous plan)\n\nSummary of what the variant group feature specifically adds or changes:\n\n| Component | Previous Plan | Change for Variants |\n|-----------|--------------|-------------------|\n| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |\n| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |\n| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |\n| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |\n| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |\n| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |\n| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |\n| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |\n| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |\n| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |\n| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |\n| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |\n| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |\n| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |\n\n---\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n\n```typescript\n// Example: buildMergePrompt\nconst fragmentMap: Record<string, string> = {\n  auto:  \"fragments/merge-auto.md\",\n  merge: \"fragments/merge-direct.md\",\n  pr:    \"fragments/merge-pr.md\",\n};\nconst template = loadPrompt(fragmentMap[this.mergeMode]);\nreturn fillTemplate(template, {\n  BRANCH_NAME: this.branchName(task),\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n});\n```\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Self-contained merge agent prompt for `auto` mode. Evaluates the change at runtime and chooses direct merge or PR. Default `mergeMode`. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Standalone merge agent prompt for `merge` mode. Always merges directly to main. |\n| `prompts/fragments/merge-pr.md` | **Existing** — Standalone merge agent prompt for `pr` mode. Always creates a PR. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n","structuredPatch":[{"oldStart":922,"oldLines":29,"newStart":922,"newLines":6,"lines":[" "," **`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally."," ","-## Changes Required for Variant Support (vs. previous plan)","-","-Summary of what the variant group feature specifically adds or changes:","-","-| Component | Previous Plan | Change for Variants |","-|-----------|--------------|-------------------|","-| **Spec Agent prompt** | Produces flat ticket list | Detects \"N versions\" requests, duplicates full dependency chain N times with independent IDs, assigns `group` + `variant_hint` per chain |","-| **TaskRequest interface** | `dependsOn` field added | Also add `group?: string` and `variantHint?: string` |","-| **Worker branch name** | Always `feat/${task.id}` | `feat/${task.group}` if grouped, `feat/${task.id}` if standalone |","-| **Worker sandbox setup** | Clone repo, create new branch | If group branch exists on remote (prior chain ticket pushed to it), check it out instead of creating fresh |","-| **Worker PR creation** | Every ticket creates a PR | Only terminal tickets create PRs. Worker prompt includes `isTerminal` flag. |","-| **Worker prompt** | Task description only | Also includes `variant_hint` when present for design direction |","-| **Orchestrator `filterEligible`** | No change | No change — deps already handle cross-chain isolation |","-| **Orchestrator merge** | Merge after every completed ticket | Only merge terminal tickets (`isTerminal` check). Non-terminal grouped tickets just push to shared branch. |","-| **New method: `isTerminal()`** | Did not exist | Checks if any pending/active ticket depends on this one |","-| **New method: `branchName()`** | Did not exist | Returns `feat/${group}` or `feat/${id}` |","-| **MD result writing** | Branch was `feat/${id}` | Branch field uses `branchName(task)`, PR field only for terminal |","-| **`loadAllTasks()`** | Only loaded Backlog tasks | Reads all statuses from `feature_requests/**/AGI-*.md` — single loader for `filterEligible()`, `isTerminal()`, and dependency checks |","-| **`TaskStatus` enum** | Simple 4-status model | Full stage-aware statuses: `Needs Research` → `Research In Progress` → ... → `Done`, plus intervention statuses |","-| **Orchestrator dispatch** | Single-shot: one worker call per ticket | Stage-aware: one stage per dispatch, re-dispatches based on `nextStatus` from WORK_RESULT |","-","----","-"," ## Variant Example: End-to-End"," "," User: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"1e586907-180b-47d7-abc4-d8dd0dfa773e"}
{"parentUuid":"318c2bee-0633-4a30-b983-f5cc68782277","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01Vzm7URTuqj1C21qrSdeu3A","type":"message","role":"assistant","content":[{"type":"text","text":"Done. Now Issue #6.\n\n### Issue 6: `maxConcurrency`, `maxIterations`, `pollIntervalSeconds` mentioned but not configured\n\nThe `processQueue()` loop references these three config values but there's no discussion of how they're set."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":888,"cache_read_input_tokens":57513,"cache_creation":{"ephemeral_5m_input_tokens":888,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xgA8Ww8Gg7RZmKw3VD","type":"assistant","uuid":"ec3d7af2-a6fd-420b-b63d-f20160ff016c","timestamp":"2026-02-14T12:27:55.774Z"}
{"parentUuid":"ec3d7af2-a6fd-420b-b63d-f20160ff016c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01Vzm7URTuqj1C21qrSdeu3A","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012pPRkG6zjHzUsCHX41Pkgr","name":"AskUserQuestion","input":{"questions":[{"question":"How should maxConcurrency, maxIterations, and pollIntervalSeconds be configured?","header":"Config source","options":[{"label":"Constructor params with defaults","description":"Pass via constructor with sensible defaults (e.g., maxConcurrency=3, maxIterations=0 for infinite, pollInterval=30s). Keep it simple, no config file."},{"label":"Environment variables","description":"Read from env vars (NAPOLI_MAX_CONCURRENCY, etc.) with fallback defaults. Easy to override in different environments."},{"label":"Config object with env override","description":"Define a typed config interface passed to constructor, with a factory function that reads env vars as overrides. Most flexible."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":888,"cache_read_input_tokens":57513,"output_tokens":292,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":888},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7xgA8Ww8Gg7RZmKw3VD","type":"assistant","uuid":"4cd7e99e-45a5-4d80-a64a-9c46847b2b73","timestamp":"2026-02-14T12:27:59.667Z"}
{"parentUuid":"4cd7e99e-45a5-4d80-a64a-9c46847b2b73","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_012pPRkG6zjHzUsCHX41Pkgr","parentToolUseID":"toolu_012pPRkG6zjHzUsCHX41Pkgr","uuid":"1a9afe66-8c62-46a4-8c64-6d71a4fe43f4","timestamp":"2026-02-14T12:27:59.669Z"}
{"parentUuid":"1a9afe66-8c62-46a4-8c64-6d71a4fe43f4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_012pPRkG6zjHzUsCHX41Pkgr","toolUseID":"toolu_012pPRkG6zjHzUsCHX41Pkgr","timestamp":"2026-02-14T12:28:27.842Z","uuid":"9d063e68-a6eb-49d4-87c9-4ae3f42481b3"}
{"parentUuid":"4cd7e99e-45a5-4d80-a64a-9c46847b2b73","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"How should maxConcurrency, maxIterations, and pollIntervalSeconds be configured?\"=\"Environment variables\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_012pPRkG6zjHzUsCHX41Pkgr"}]},"uuid":"ee57fef8-a5ff-456f-986d-764b27444c7d","timestamp":"2026-02-14T12:28:27.839Z","toolUseResult":{"questions":[{"question":"How should maxConcurrency, maxIterations, and pollIntervalSeconds be configured?","header":"Config source","options":[{"label":"Constructor params with defaults","description":"Pass via constructor with sensible defaults (e.g., maxConcurrency=3, maxIterations=0 for infinite, pollInterval=30s). Keep it simple, no config file."},{"label":"Environment variables","description":"Read from env vars (NAPOLI_MAX_CONCURRENCY, etc.) with fallback defaults. Easy to override in different environments."},{"label":"Config object with env override","description":"Define a typed config interface passed to constructor, with a factory function that reads env vars as overrides. Most flexible."}],"multiSelect":false}],"answers":{"How should maxConcurrency, maxIterations, and pollIntervalSeconds be configured?":"Environment variables"}},"sourceToolAssistantUUID":"4cd7e99e-45a5-4d80-a64a-9c46847b2b73"}
{"parentUuid":"ee57fef8-a5ff-456f-986d-764b27444c7d","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01PaBzyLrnLGGLj93ZHYx6fy","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012VxoAWr2QCRmuWwAQEfcYN","name":"Read","input":{"file_path":"REDACTED.md","offset":388,"limit":8},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":345,"cache_read_input_tokens":58401,"cache_creation":{"ephemeral_5m_input_tokens":345,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xioT9bJCJ1CyY1zx2m","type":"assistant","uuid":"6c78a17c-68d3-4d63-ad6e-de0b5de27e79","timestamp":"2026-02-14T12:28:30.472Z"}
{"parentUuid":"6c78a17c-68d3-4d63-ad6e-de0b5de27e79","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_012VxoAWr2QCRmuWwAQEfcYN","parentToolUseID":"toolu_012VxoAWr2QCRmuWwAQEfcYN","uuid":"0e5a5cd4-0728-44e8-9306-c6d49087e263","timestamp":"2026-02-14T12:28:30.476Z"}
{"parentUuid":"0e5a5cd4-0728-44e8-9306-c6d49087e263","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_012VxoAWr2QCRmuWwAQEfcYN","toolUseID":"toolu_012VxoAWr2QCRmuWwAQEfcYN","timestamp":"2026-02-14T12:28:30.541Z","uuid":"977dd819-a88f-477b-b378-ca8cb2cd6fdb"}
{"parentUuid":"977dd819-a88f-477b-b378-ca8cb2cd6fdb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_012VxoAWr2QCRmuWwAQEfcYN","toolUseID":"toolu_012VxoAWr2QCRmuWwAQEfcYN","timestamp":"2026-02-14T12:28:30.541Z","uuid":"f53b9fe6-2326-4020-aa78-e4e87f3b27eb"}
{"parentUuid":"6c78a17c-68d3-4d63-ad6e-de0b5de27e79","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012VxoAWr2QCRmuWwAQEfcYN","type":"tool_result","content":"   388→  let iteration = 0;\n   389→  const active = new Map<string, Promise<void>>();\n   390→\n   391→  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n   392→    const allTasks = await this.loadAllTasks();  // every status\n   393→    const eligible = this.filterEligible(allTasks, active);\n   394→\n   395→    if (eligible.length === 0 && active.size === 0) {"}]},"uuid":"e9bc964d-6a17-4186-a450-49c9800bd4f4","timestamp":"2026-02-14T12:28:30.539Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {","numLines":8,"startLine":388,"totalLines":1086}},"sourceToolAssistantUUID":"6c78a17c-68d3-4d63-ad6e-de0b5de27e79"}
{"parentUuid":"e9bc964d-6a17-4186-a450-49c9800bd4f4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01FEdyLmfYHC7xjQ7gtRvweE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_015vUdgacdayYLd8ds65fQzt","name":"Read","input":{"file_path":"REDACTED.md","offset":382,"limit":6},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":253,"cache_read_input_tokens":58746,"output_tokens":113,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":253},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7xizvU22iWwLSs4SNZc","type":"assistant","uuid":"f653b278-7057-41c7-b215-04df1f97bd88","timestamp":"2026-02-14T12:28:33.193Z"}
{"parentUuid":"f653b278-7057-41c7-b215-04df1f97bd88","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_015vUdgacdayYLd8ds65fQzt","parentToolUseID":"toolu_015vUdgacdayYLd8ds65fQzt","uuid":"f5ace72b-2ca6-4004-9234-250cc615d870","timestamp":"2026-02-14T12:28:33.198Z"}
{"parentUuid":"f5ace72b-2ca6-4004-9234-250cc615d870","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_015vUdgacdayYLd8ds65fQzt","toolUseID":"toolu_015vUdgacdayYLd8ds65fQzt","timestamp":"2026-02-14T12:28:33.253Z","uuid":"f0306d81-c3d5-45ae-b28e-9789686c7028"}
{"parentUuid":"f0306d81-c3d5-45ae-b28e-9789686c7028","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_015vUdgacdayYLd8ds65fQzt","toolUseID":"toolu_015vUdgacdayYLd8ds65fQzt","timestamp":"2026-02-14T12:28:33.253Z","uuid":"7dcf721f-b0f9-4651-8e21-eb73a88c7eaa"}
{"parentUuid":"f653b278-7057-41c7-b215-04df1f97bd88","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_015vUdgacdayYLd8ds65fQzt","type":"tool_result","content":"   382→### Continuous Loop with Stage-Aware Dispatch\n   383→\n   384→Replace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n   385→\n   386→```typescript\n   387→async processQueue(): Promise<void> {"}]},"uuid":"38f15d89-d183-4edf-9e46-9360be4f2917","timestamp":"2026-02-14T12:28:33.252Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {","numLines":6,"startLine":382,"totalLines":1086}},"sourceToolAssistantUUID":"f653b278-7057-41c7-b215-04df1f97bd88"}
{"parentUuid":"38f15d89-d183-4edf-9e46-9360be4f2917","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_0158YUzXsQKmzWJeWveVqB3L","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_017DP5sTEVcA21VUxHj2aUSB","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"Replace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {","new_string":"Replace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n#### Configuration (environment variables with defaults)\n\n| Env Var | Default | Description |\n|---------|---------|-------------|\n| `NAPOLI_MAX_CONCURRENCY` | `3` | Maximum parallel worker sandboxes |\n| `NAPOLI_MAX_ITERATIONS` | `0` (infinite) | Total stage dispatches before exiting. `0` = run forever. |\n| `NAPOLI_POLL_INTERVAL` | `30` | Seconds to sleep when no tasks are eligible |\n| `NAPOLI_MERGE_MODE` | `auto` | Merge fragment selection: `auto`, `merge`, or `pr` |\n\n```typescript\nasync processQueue(): Promise<void> {"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":231,"cache_read_input_tokens":58999,"cache_creation":{"ephemeral_5m_input_tokens":231,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xjCVykYaDZJaxs5kVY","type":"assistant","uuid":"6d0c07d5-a0f3-437d-8ab9-2e60239cb8c4","timestamp":"2026-02-14T12:28:40.177Z"}
{"parentUuid":"6d0c07d5-a0f3-437d-8ab9-2e60239cb8c4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_017DP5sTEVcA21VUxHj2aUSB","parentToolUseID":"toolu_017DP5sTEVcA21VUxHj2aUSB","uuid":"2e7e9bd1-3e8e-4332-9fa4-3bb40d4c2202","timestamp":"2026-02-14T12:28:40.180Z"}
{"parentUuid":"2e7e9bd1-3e8e-4332-9fa4-3bb40d4c2202","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_017DP5sTEVcA21VUxHj2aUSB","toolUseID":"toolu_017DP5sTEVcA21VUxHj2aUSB","timestamp":"2026-02-14T12:28:40.228Z","uuid":"c9dac51a-aa24-4909-910c-852b37782d4e"}
{"parentUuid":"c9dac51a-aa24-4909-910c-852b37782d4e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_017DP5sTEVcA21VUxHj2aUSB","toolUseID":"toolu_017DP5sTEVcA21VUxHj2aUSB","timestamp":"2026-02-14T12:28:40.228Z","uuid":"90357496-e112-4010-83fa-66aa2d221060"}
{"parentUuid":"6d0c07d5-a0f3-437d-8ab9-2e60239cb8c4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_017DP5sTEVcA21VUxHj2aUSB","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"c013c99f-23fd-4e7e-a11f-a7a7a2113ccd","timestamp":"2026-02-14T12:28:40.227Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"Replace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {","newString":"Replace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n#### Configuration (environment variables with defaults)\n\n| Env Var | Default | Description |\n|---------|---------|-------------|\n| `NAPOLI_MAX_CONCURRENCY` | `3` | Maximum parallel worker sandboxes |\n| `NAPOLI_MAX_ITERATIONS` | `0` (infinite) | Total stage dispatches before exiting. `0` = run forever. |\n| `NAPOLI_POLL_INTERVAL` | `30` | Seconds to sleep when no tasks are eligible |\n| `NAPOLI_MERGE_MODE` | `auto` | Merge fragment selection: `auto`, `merge`, or `pr` |\n\n```typescript\nasync processQueue(): Promise<void> {","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. PromptLoader                      — depends_on: []\n3. TaskStatus enum + helpers         — depends_on: []\n4. SpecAgent (Phase 1)               — depends_on: [1, 2]\n5. Orchestrator refactor (Phase 3)   — depends_on: [2, 3]\n6. Test-Writer (Phase 5)             — depends_on: [5]\n7. Entry Point (Phase 4)             — depends_on: [4, 5]\n8. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #2 (PromptLoader), #3 (TaskStatus), #8 (Prompt adaptations)\n  Wave 2: #4 (SpecAgent), #5 (Orchestrator)  — #4 needs #1+#2, #5 needs #2+#3\n  Wave 3: #6 (Test-Writer), #7 (Entry Point) — #6 needs #5, #7 needs #4+#5\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #8 is pure markdown edits with no code dependencies — safe for wave 1\n- #4 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n- Merge agent is part of #5 (Orchestrator) — uses merge-auto.md fragment via PromptLoader\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status\n\n**Crash recovery (worker failure)**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.\n\n**Crash recovery (orchestrator failure)**: If the orchestrator process itself crashes while tickets are `* In Progress`, those tickets remain stuck — `isActionable()` only matches `Needs *` statuses. In v1, a human must manually reset orphaned `In Progress` tickets back to their `Needs *` counterpart to resume processing. A future version could add a startup sweep or timeout-based recovery.\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### Agent Runner Pattern\n\n`runWorkerAgent()`, `runTestWriterAgent()`, and `runMergeAgent()` all follow the same pattern inherited from the existing `executeClaudeCommand()`:\n\n1. Open a PTY session in the Daytona sandbox via the SDK\n2. Invoke `claude -p '<prompt>' --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n3. Stream stdout line-by-line, parse JSON events, log to file\n4. Extract structured output (WORK_RESULT / TEST_RESULT) from the `result` event\n5. Return parsed result\n\nThe only difference between the three is which prompt they receive and which output block they parse.\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Receives one of three merge fragment prompts (selected by `mergeMode` config):\n   - **`merge-auto.md`** (default) — self-contained decision rubric that evaluates the change and chooses direct merge or PR at runtime\n   - **`merge-direct.md`** — always merge directly to main (for trusted, low-risk pipelines)\n   - **`merge-pr.md`** — always create a PR (for repos requiring review)\n3. Executes `git merge --no-ff` or `gh pr create` based on the selected mode's instructions\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe three fragments are **independent, mutually exclusive modes** (ported from Horizon). Each is a complete standalone prompt — `merge-auto.md` does not delegate to the other two. The orchestrator selects which fragment to load via a `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`).\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox, checkout branch\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)\n  5. Return combined result (stage + test summary + merge status)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {{TICKET_CONTEXT}}\n**Branch diff vs main**: {{BRANCH_DIFF}}\n**Is terminal ticket**: {{IS_TERMINAL}}\n{{CHAIN_TICKETS}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nprivate codeProducingStages = new Set([\n  \"Needs Implement\",\n  \"Needs Validate\",\n  \"Needs Oneshot\",\n]);\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `inProgressStatus()` — Status Transition Helper\n\nMaps each actionable `Needs *` status to its corresponding `* In Progress` status:\n\n```typescript\nconst inProgressMap: Record<string, TaskStatus> = {\n  [TaskStatus.NeedsResearch]:      TaskStatus.ResearchInProgress,\n  [TaskStatus.NeedsSpecification]: TaskStatus.SpecificationInProgress,\n  [TaskStatus.NeedsPlan]:          TaskStatus.PlanInProgress,\n  [TaskStatus.NeedsImplement]:     TaskStatus.ImplementInProgress,\n  [TaskStatus.NeedsValidate]:      TaskStatus.ValidateInProgress,\n  [TaskStatus.NeedsOneshot]:       TaskStatus.OneshotInProgress,\n};\n\nfunction inProgressStatus(status: TaskStatus): TaskStatus {\n  return inProgressMap[status] ?? status;\n}\n```\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n\n```typescript\n// Example: buildMergePrompt\nconst fragmentMap: Record<string, string> = {\n  auto:  \"fragments/merge-auto.md\",\n  merge: \"fragments/merge-direct.md\",\n  pr:    \"fragments/merge-pr.md\",\n};\nconst template = loadPrompt(fragmentMap[this.mergeMode]);\nreturn fillTemplate(template, {\n  BRANCH_NAME: this.branchName(task),\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n});\n```\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Self-contained merge agent prompt for `auto` mode. Evaluates the change at runtime and chooses direct merge or PR. Default `mergeMode`. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Standalone merge agent prompt for `merge` mode. Always merges directly to main. |\n| `prompts/fragments/merge-pr.md` | **Existing** — Standalone merge agent prompt for `pr` mode. Always creates a PR. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n","structuredPatch":[{"oldStart":383,"oldLines":6,"newStart":383,"newLines":15,"lines":[" "," Replace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes."," ","+#### Configuration (environment variables with defaults)","+","+| Env Var | Default | Description |","+|---------|---------|-------------|","+| `NAPOLI_MAX_CONCURRENCY` | `3` | Maximum parallel worker sandboxes |","+| `NAPOLI_MAX_ITERATIONS` | `0` (infinite) | Total stage dispatches before exiting. `0` = run forever. |","+| `NAPOLI_POLL_INTERVAL` | `30` | Seconds to sleep when no tasks are eligible |","+| `NAPOLI_MERGE_MODE` | `auto` | Merge fragment selection: `auto`, `merge`, or `pr` |","+"," ```typescript"," async processQueue(): Promise<void> {","   let iteration = 0;"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"6d0c07d5-a0f3-437d-8ab9-2e60239cb8c4"}
{"parentUuid":"c013c99f-23fd-4e7e-a11f-a7a7a2113ccd","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01FSsTEgg17JxpHXeMGEuMG4","type":"message","role":"assistant","content":[{"type":"text","text":"Done. Now the three minor nits.\n\n### Minor Nit 1: PromptLoader placement\n\nPromptLoader is a Wave 1 component (no deps) but appears near the bottom of the document after Phases 4 and 5."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":477,"cache_read_input_tokens":59230,"cache_creation":{"ephemeral_5m_input_tokens":477,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xjiHsDjs2dBejVhpt3","type":"assistant","uuid":"3826ddb3-dd1e-4a5c-87f2-fb0068232879","timestamp":"2026-02-14T12:28:44.010Z"}
{"parentUuid":"3826ddb3-dd1e-4a5c-87f2-fb0068232879","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01FSsTEgg17JxpHXeMGEuMG4","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_011rWXG8rpqBJ9aRZTBgtqMM","name":"AskUserQuestion","input":{"questions":[{"question":"Should PromptLoader be moved earlier in the document to reflect its Wave 1 position (next to ClaudeSpawner), or keep it where it is?","header":"Doc ordering","options":[{"label":"Move before Phase 3","description":"Place it right after Phase 2 (ClaudeSpawner) since they're both Wave 1, no-dependency components. Readers encounter it before it's referenced."},{"label":"Keep at bottom","description":"It's a utility — readers understand the main architecture first, then see the helper. Current placement is fine."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":477,"cache_read_input_tokens":59230,"cache_creation":{"ephemeral_5m_input_tokens":477,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xjiHsDjs2dBejVhpt3","type":"assistant","uuid":"e067715f-e160-4802-b40b-278feda9ce35","timestamp":"2026-02-14T12:28:47.581Z"}
{"parentUuid":"e067715f-e160-4802-b40b-278feda9ce35","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_011rWXG8rpqBJ9aRZTBgtqMM","parentToolUseID":"toolu_011rWXG8rpqBJ9aRZTBgtqMM","uuid":"98d97a86-62a7-4552-804b-743cab14d6cd","timestamp":"2026-02-14T12:28:47.583Z"}
{"parentUuid":"98d97a86-62a7-4552-804b-743cab14d6cd","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_011rWXG8rpqBJ9aRZTBgtqMM","toolUseID":"toolu_011rWXG8rpqBJ9aRZTBgtqMM","timestamp":"2026-02-14T12:29:22.676Z","uuid":"ff97a635-f29d-40c3-863b-24c0309544dd"}
{"parentUuid":"e067715f-e160-4802-b40b-278feda9ce35","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Should PromptLoader be moved earlier in the document to reflect its Wave 1 position (next to ClaudeSpawner), or keep it where it is?\"=\"Move before Phase 3\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_011rWXG8rpqBJ9aRZTBgtqMM"}]},"uuid":"935b283b-6453-4897-a7c9-8d3bb36ff19f","timestamp":"2026-02-14T12:29:22.673Z","toolUseResult":{"questions":[{"question":"Should PromptLoader be moved earlier in the document to reflect its Wave 1 position (next to ClaudeSpawner), or keep it where it is?","header":"Doc ordering","options":[{"label":"Move before Phase 3","description":"Place it right after Phase 2 (ClaudeSpawner) since they're both Wave 1, no-dependency components. Readers encounter it before it's referenced."},{"label":"Keep at bottom","description":"It's a utility — readers understand the main architecture first, then see the helper. Current placement is fine."}],"multiSelect":false}],"answers":{"Should PromptLoader be moved earlier in the document to reflect its Wave 1 position (next to ClaudeSpawner), or keep it where it is?":"Move before Phase 3"}},"sourceToolAssistantUUID":"e067715f-e160-4802-b40b-278feda9ce35"}
{"parentUuid":"935b283b-6453-4897-a7c9-8d3bb36ff19f","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01DU8qp8NxAaeioFTqL3crhD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01JQBNRsY2Xm1FCYKPxEbA6d","name":"Read","input":{"file_path":"REDACTED.md","offset":375,"limit":10},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":337,"cache_read_input_tokens":59707,"cache_creation":{"ephemeral_5m_input_tokens":337,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xnqur1uaT6KfvXqDx6","type":"assistant","uuid":"4bbecf70-2cf4-455a-89dc-d00032b391db","timestamp":"2026-02-14T12:29:25.729Z"}
{"parentUuid":"4bbecf70-2cf4-455a-89dc-d00032b391db","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01JQBNRsY2Xm1FCYKPxEbA6d","parentToolUseID":"toolu_01JQBNRsY2Xm1FCYKPxEbA6d","uuid":"316bbbce-e8af-4f94-b234-c598e82590cf","timestamp":"2026-02-14T12:29:25.732Z"}
{"parentUuid":"316bbbce-e8af-4f94-b234-c598e82590cf","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01JQBNRsY2Xm1FCYKPxEbA6d","toolUseID":"toolu_01JQBNRsY2Xm1FCYKPxEbA6d","timestamp":"2026-02-14T12:29:25.789Z","uuid":"9ad88ee5-f38a-4a67-bf0a-2917b947a30b"}
{"parentUuid":"9ad88ee5-f38a-4a67-bf0a-2917b947a30b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01JQBNRsY2Xm1FCYKPxEbA6d","toolUseID":"toolu_01JQBNRsY2Xm1FCYKPxEbA6d","timestamp":"2026-02-14T12:29:25.789Z","uuid":"473f2ba4-4d51-41d0-955e-f5f9f7fcb176"}
{"parentUuid":"4bbecf70-2cf4-455a-89dc-d00032b391db","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01JQBNRsY2Xm1FCYKPxEbA6d","type":"tool_result","content":"   375→\n   376→Based on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n   377→\n   378→---\n   379→\n   380→## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n   381→\n   382→### Continuous Loop with Stage-Aware Dispatch\n   383→\n   384→Replace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes."}]},"uuid":"f45831f6-adca-42da-ac68-c3349e6d3c37","timestamp":"2026-02-14T12:29:25.788Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.","numLines":10,"startLine":375,"totalLines":1095}},"sourceToolAssistantUUID":"4bbecf70-2cf4-455a-89dc-d00032b391db"}
{"parentUuid":"f45831f6-adca-42da-ac68-c3349e6d3c37","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01M39NnWiJGKzRQffub4seBh","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me find and extract the PromptLoader section from its current location."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":289,"cache_read_input_tokens":60044,"cache_creation":{"ephemeral_5m_input_tokens":289,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xo59L6bK2tYcacv8pC","type":"assistant","uuid":"d5caf0a9-c564-4bbc-8344-c23333403b3c","timestamp":"2026-02-14T12:29:28.267Z"}
{"parentUuid":"d5caf0a9-c564-4bbc-8344-c23333403b3c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01M39NnWiJGKzRQffub4seBh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SN8mk1Q9txoMvyNWdgyogx","name":"Grep","input":{"pattern":"## Prompt Loading","path":"REDACTED.md","output_mode":"content","-n":true},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":289,"cache_read_input_tokens":60044,"cache_creation":{"ephemeral_5m_input_tokens":289,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xo59L6bK2tYcacv8pC","type":"assistant","uuid":"2293a144-6c3f-47ed-8270-6de3788a0387","timestamp":"2026-02-14T12:29:29.445Z"}
{"parentUuid":"2293a144-6c3f-47ed-8270-6de3788a0387","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01SN8mk1Q9txoMvyNWdgyogx","parentToolUseID":"toolu_01SN8mk1Q9txoMvyNWdgyogx","uuid":"8ba91022-1a38-4d77-867d-6790ae934cd2","timestamp":"2026-02-14T12:29:29.448Z"}
{"parentUuid":"8ba91022-1a38-4d77-867d-6790ae934cd2","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01SN8mk1Q9txoMvyNWdgyogx","toolUseID":"toolu_01SN8mk1Q9txoMvyNWdgyogx","timestamp":"2026-02-14T12:29:29.775Z","uuid":"389e53fa-d710-473c-b776-a2daa5f4051a"}
{"parentUuid":"389e53fa-d710-473c-b776-a2daa5f4051a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"callback"},"parentToolUseID":"toolu_01SN8mk1Q9txoMvyNWdgyogx","toolUseID":"toolu_01SN8mk1Q9txoMvyNWdgyogx","timestamp":"2026-02-14T12:29:29.775Z","uuid":"0dbc8709-886c-4796-b06c-bccc3c8f9292"}
{"parentUuid":"2293a144-6c3f-47ed-8270-6de3788a0387","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SN8mk1Q9txoMvyNWdgyogx","type":"tool_result","content":"1009:## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)"}]},"uuid":"0e52303a-ced7-4b56-9cfe-ea546bae93ee","timestamp":"2026-02-14T12:29:29.773Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"1009:## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)","numLines":1},"sourceToolAssistantUUID":"2293a144-6c3f-47ed-8270-6de3788a0387"}
{"parentUuid":"0e52303a-ced7-4b56-9cfe-ea546bae93ee","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01XcxtsN6J7RjDUpY6m8X8Pv","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01J5n3XzhysDeMPjMkNTmCA3","name":"Read","input":{"file_path":"REDACTED.md","offset":1009,"limit":62},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":297,"cache_read_input_tokens":60333,"cache_creation":{"ephemeral_5m_input_tokens":297,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xoNDF3ci2uPKb91HfC","type":"assistant","uuid":"2e7b717c-4931-4981-98c0-950c0808bb40","timestamp":"2026-02-14T12:29:32.464Z"}
{"parentUuid":"2e7b717c-4931-4981-98c0-950c0808bb40","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01J5n3XzhysDeMPjMkNTmCA3","parentToolUseID":"toolu_01J5n3XzhysDeMPjMkNTmCA3","uuid":"55e99b61-bca1-4996-8e18-1c8fbceced47","timestamp":"2026-02-14T12:29:32.468Z"}
{"parentUuid":"55e99b61-bca1-4996-8e18-1c8fbceced47","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01J5n3XzhysDeMPjMkNTmCA3","toolUseID":"toolu_01J5n3XzhysDeMPjMkNTmCA3","timestamp":"2026-02-14T12:29:32.526Z","uuid":"361a30e5-4df9-4560-869a-0d8a97f9e6d9"}
{"parentUuid":"361a30e5-4df9-4560-869a-0d8a97f9e6d9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01J5n3XzhysDeMPjMkNTmCA3","toolUseID":"toolu_01J5n3XzhysDeMPjMkNTmCA3","timestamp":"2026-02-14T12:29:32.526Z","uuid":"00d8324b-7f04-4ab2-80e4-401e838923a9"}
{"parentUuid":"2e7b717c-4931-4981-98c0-950c0808bb40","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01J5n3XzhysDeMPjMkNTmCA3","type":"tool_result","content":"  1009→## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n  1010→\n  1011→A simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n  1012→\n  1013→```typescript\n  1014→function loadPrompt(name: string): string {\n  1015→  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n  1016→}\n  1017→\n  1018→function fillTemplate(template: string, vars: Record<string, string>): string {\n  1019→  return Object.entries(vars).reduce(\n  1020→    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  1021→  );\n  1022→}\n  1023→```\n  1024→\n  1025→Each `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n  1026→\n  1027→```typescript\n  1028→// Example: buildTestWriterPrompt\n  1029→const template = loadPrompt(\"agent2-worker-test.md\");\n  1030→return fillTemplate(template, {\n  1031→  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  1032→  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  1033→  IS_TERMINAL: String(isTerminal),\n  1034→  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n  1035→});\n  1036→```\n  1037→\n  1038→For the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n  1039→\n  1040→```typescript\n  1041→// Example: buildMergePrompt\n  1042→const fragmentMap: Record<string, string> = {\n  1043→  auto:  \"fragments/merge-auto.md\",\n  1044→  merge: \"fragments/merge-direct.md\",\n  1045→  pr:    \"fragments/merge-pr.md\",\n  1046→};\n  1047→const template = loadPrompt(fragmentMap[this.mergeMode]);\n  1048→return fillTemplate(template, {\n  1049→  BRANCH_NAME: this.branchName(task),\n  1050→  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  1051→  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n  1052→});\n  1053→```\n  1054→\n  1055→---\n  1056→\n  1057→## Files\n  1058→\n  1059→| File | Change |\n  1060→|------|--------|\n  1061→| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n  1062→| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n  1063→| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n  1064→| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n  1065→| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n  1066→| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n  1067→| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n  1068→| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n  1069→| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n  1070→| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |"}]},"uuid":"67c28158-13d6-4dae-9e70-1bd981b4ff94","timestamp":"2026-02-14T12:29:32.525Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n\n```typescript\n// Example: buildMergePrompt\nconst fragmentMap: Record<string, string> = {\n  auto:  \"fragments/merge-auto.md\",\n  merge: \"fragments/merge-direct.md\",\n  pr:    \"fragments/merge-pr.md\",\n};\nconst template = loadPrompt(fragmentMap[this.mergeMode]);\nreturn fillTemplate(template, {\n  BRANCH_NAME: this.branchName(task),\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n});\n```\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |","numLines":62,"startLine":1009,"totalLines":1095}},"sourceToolAssistantUUID":"2e7b717c-4931-4981-98c0-950c0808bb40"}
{"parentUuid":"67c28158-13d6-4dae-9e70-1bd981b4ff94","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_011GMUqHBkE9xUgqWgRi8ZcP","type":"message","role":"assistant","content":[{"type":"text","text":"I need to: (1) copy the PromptLoader section to before Phase 3, (2) remove it from its current location. Let me do both."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1392,"cache_read_input_tokens":60630,"cache_creation":{"ephemeral_5m_input_tokens":1392,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xoZuwyNwqbbHAnDF2t","type":"assistant","uuid":"f62e19c6-af09-4e6c-80e5-2661f196efa1","timestamp":"2026-02-14T12:29:35.237Z"}
{"parentUuid":"f62e19c6-af09-4e6c-80e5-2661f196efa1","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_011GMUqHBkE9xUgqWgRi8ZcP","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0176o9LaMnEpNiQAwiX5HxA3","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)","new_string":"---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n\n```typescript\n// Example: buildMergePrompt\nconst fragmentMap: Record<string, string> = {\n  auto:  \"fragments/merge-auto.md\",\n  merge: \"fragments/merge-direct.md\",\n  pr:    \"fragments/merge-pr.md\",\n};\nconst template = loadPrompt(fragmentMap[this.mergeMode]);\nreturn fillTemplate(template, {\n  BRANCH_NAME: this.branchName(task),\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n});\n```\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1392,"cache_read_input_tokens":60630,"output_tokens":737,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":1392},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7xoZuwyNwqbbHAnDF2t","type":"assistant","uuid":"0fec1aec-9e3b-44fe-b448-d20a28015959","timestamp":"2026-02-14T12:29:40.730Z"}
{"parentUuid":"0fec1aec-9e3b-44fe-b448-d20a28015959","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_0176o9LaMnEpNiQAwiX5HxA3","parentToolUseID":"toolu_0176o9LaMnEpNiQAwiX5HxA3","uuid":"a1f4a38b-30d9-4baa-9933-88e4fc538b83","timestamp":"2026-02-14T12:29:40.733Z"}
{"parentUuid":"a1f4a38b-30d9-4baa-9933-88e4fc538b83","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_0176o9LaMnEpNiQAwiX5HxA3","toolUseID":"toolu_0176o9LaMnEpNiQAwiX5HxA3","timestamp":"2026-02-14T12:29:40.789Z","uuid":"994f8109-c8b7-4729-92ea-6122e76d83fe"}
{"parentUuid":"994f8109-c8b7-4729-92ea-6122e76d83fe","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_0176o9LaMnEpNiQAwiX5HxA3","toolUseID":"toolu_0176o9LaMnEpNiQAwiX5HxA3","timestamp":"2026-02-14T12:29:40.789Z","uuid":"7897cc98-f821-4f07-86a7-5dea89a4ad74"}
{"parentUuid":"0fec1aec-9e3b-44fe-b448-d20a28015959","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0176o9LaMnEpNiQAwiX5HxA3","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"e1e99503-5f37-47de-a93b-6fd21414708a","timestamp":"2026-02-14T12:29:40.787Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)","newString":"---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n\n```typescript\n// Example: buildMergePrompt\nconst fragmentMap: Record<string, string> = {\n  auto:  \"fragments/merge-auto.md\",\n  merge: \"fragments/merge-direct.md\",\n  pr:    \"fragments/merge-pr.md\",\n};\nconst template = loadPrompt(fragmentMap[this.mergeMode]);\nreturn fillTemplate(template, {\n  BRANCH_NAME: this.branchName(task),\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n});\n```\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. PromptLoader                      — depends_on: []\n3. TaskStatus enum + helpers         — depends_on: []\n4. SpecAgent (Phase 1)               — depends_on: [1, 2]\n5. Orchestrator refactor (Phase 3)   — depends_on: [2, 3]\n6. Test-Writer (Phase 5)             — depends_on: [5]\n7. Entry Point (Phase 4)             — depends_on: [4, 5]\n8. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #2 (PromptLoader), #3 (TaskStatus), #8 (Prompt adaptations)\n  Wave 2: #4 (SpecAgent), #5 (Orchestrator)  — #4 needs #1+#2, #5 needs #2+#3\n  Wave 3: #6 (Test-Writer), #7 (Entry Point) — #6 needs #5, #7 needs #4+#5\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #8 is pure markdown edits with no code dependencies — safe for wave 1\n- #4 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n- Merge agent is part of #5 (Orchestrator) — uses merge-auto.md fragment via PromptLoader\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n#### Configuration (environment variables with defaults)\n\n| Env Var | Default | Description |\n|---------|---------|-------------|\n| `NAPOLI_MAX_CONCURRENCY` | `3` | Maximum parallel worker sandboxes |\n| `NAPOLI_MAX_ITERATIONS` | `0` (infinite) | Total stage dispatches before exiting. `0` = run forever. |\n| `NAPOLI_POLL_INTERVAL` | `30` | Seconds to sleep when no tasks are eligible |\n| `NAPOLI_MERGE_MODE` | `auto` | Merge fragment selection: `auto`, `merge`, or `pr` |\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status\n\n**Crash recovery (worker failure)**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.\n\n**Crash recovery (orchestrator failure)**: If the orchestrator process itself crashes while tickets are `* In Progress`, those tickets remain stuck — `isActionable()` only matches `Needs *` statuses. In v1, a human must manually reset orphaned `In Progress` tickets back to their `Needs *` counterpart to resume processing. A future version could add a startup sweep or timeout-based recovery.\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### Agent Runner Pattern\n\n`runWorkerAgent()`, `runTestWriterAgent()`, and `runMergeAgent()` all follow the same pattern inherited from the existing `executeClaudeCommand()`:\n\n1. Open a PTY session in the Daytona sandbox via the SDK\n2. Invoke `claude -p '<prompt>' --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n3. Stream stdout line-by-line, parse JSON events, log to file\n4. Extract structured output (WORK_RESULT / TEST_RESULT) from the `result` event\n5. Return parsed result\n\nThe only difference between the three is which prompt they receive and which output block they parse.\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Receives one of three merge fragment prompts (selected by `mergeMode` config):\n   - **`merge-auto.md`** (default) — self-contained decision rubric that evaluates the change and chooses direct merge or PR at runtime\n   - **`merge-direct.md`** — always merge directly to main (for trusted, low-risk pipelines)\n   - **`merge-pr.md`** — always create a PR (for repos requiring review)\n3. Executes `git merge --no-ff` or `gh pr create` based on the selected mode's instructions\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe three fragments are **independent, mutually exclusive modes** (ported from Horizon). Each is a complete standalone prompt — `merge-auto.md` does not delegate to the other two. The orchestrator selects which fragment to load via a `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`).\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox, checkout branch\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)\n  5. Return combined result (stage + test summary + merge status)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {{TICKET_CONTEXT}}\n**Branch diff vs main**: {{BRANCH_DIFF}}\n**Is terminal ticket**: {{IS_TERMINAL}}\n{{CHAIN_TICKETS}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nprivate codeProducingStages = new Set([\n  \"Needs Implement\",\n  \"Needs Validate\",\n  \"Needs Oneshot\",\n]);\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `inProgressStatus()` — Status Transition Helper\n\nMaps each actionable `Needs *` status to its corresponding `* In Progress` status:\n\n```typescript\nconst inProgressMap: Record<string, TaskStatus> = {\n  [TaskStatus.NeedsResearch]:      TaskStatus.ResearchInProgress,\n  [TaskStatus.NeedsSpecification]: TaskStatus.SpecificationInProgress,\n  [TaskStatus.NeedsPlan]:          TaskStatus.PlanInProgress,\n  [TaskStatus.NeedsImplement]:     TaskStatus.ImplementInProgress,\n  [TaskStatus.NeedsValidate]:      TaskStatus.ValidateInProgress,\n  [TaskStatus.NeedsOneshot]:       TaskStatus.OneshotInProgress,\n};\n\nfunction inProgressStatus(status: TaskStatus): TaskStatus {\n  return inProgressMap[status] ?? status;\n}\n```\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n\n```typescript\n// Example: buildMergePrompt\nconst fragmentMap: Record<string, string> = {\n  auto:  \"fragments/merge-auto.md\",\n  merge: \"fragments/merge-direct.md\",\n  pr:    \"fragments/merge-pr.md\",\n};\nconst template = loadPrompt(fragmentMap[this.mergeMode]);\nreturn fillTemplate(template, {\n  BRANCH_NAME: this.branchName(task),\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n});\n```\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Self-contained merge agent prompt for `auto` mode. Evaluates the change at runtime and chooses direct merge or PR. Default `mergeMode`. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Standalone merge agent prompt for `merge` mode. Always merges directly to main. |\n| `prompts/fragments/merge-pr.md` | **Existing** — Standalone merge agent prompt for `pr` mode. Always creates a PR. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n","structuredPatch":[{"oldStart":377,"oldLines":6,"newStart":377,"newLines":54,"lines":[" "," ---"," ","+## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)","+","+A simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:","+","+```typescript","+function loadPrompt(name: string): string {","+  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");","+}","+","+function fillTemplate(template: string, vars: Record<string, string>): string {","+  return Object.entries(vars).reduce(","+    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template","+  );","+}","+```","+","+Each `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:","+","+```typescript","+// Example: buildTestWriterPrompt","+const template = loadPrompt(\"agent2-worker-test.md\");","+return fillTemplate(template, {","+  TICKET_CONTEXT: `${task.title}\\n${task.description}`,","+  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),","+  IS_TERMINAL: String(isTerminal),","+  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",","+});","+```","+","+For the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):","+","+```typescript","+// Example: buildMergePrompt","+const fragmentMap: Record<string, string> = {","+  auto:  \"fragments/merge-auto.md\",","+  merge: \"fragments/merge-direct.md\",","+  pr:    \"fragments/merge-pr.md\",","+};","+const template = loadPrompt(fragmentMap[this.mergeMode]);","+return fillTemplate(template, {","+  BRANCH_NAME: this.branchName(task),","+  TICKET_CONTEXT: `${task.title}\\n${task.description}`,","+  TEST_RESULTS: testResult?.summary ?? \"No tests run\",","+});","+```","+","+---","+"," ## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)"," "," ### Continuous Loop with Stage-Aware Dispatch"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"0fec1aec-9e3b-44fe-b448-d20a28015959"}
{"parentUuid":"e1e99503-5f37-47de-a93b-6fd21414708a","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_018QV6wi92p34TvBXGYs3EN9","type":"message","role":"assistant","content":[{"type":"text","text":"Now remove the old location."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":782,"cache_read_input_tokens":62022,"cache_creation":{"ephemeral_5m_input_tokens":782,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xpBGxG4zyLrZUYDSdz","type":"assistant","uuid":"887b349e-83e7-4b26-aa1c-7481aff61f7c","timestamp":"2026-02-14T12:29:43.133Z"}
{"parentUuid":"887b349e-83e7-4b26-aa1c-7481aff61f7c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_018QV6wi92p34TvBXGYs3EN9","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01XdyYoLtHRAZ95w6t3ZVdwT","name":"Read","input":{"file_path":"REDACTED.md","offset":1050,"limit":15},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":782,"cache_read_input_tokens":62022,"cache_creation":{"ephemeral_5m_input_tokens":782,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xpBGxG4zyLrZUYDSdz","type":"assistant","uuid":"66967ac3-9559-41f3-aca7-57dc9ea84843","timestamp":"2026-02-14T12:29:43.777Z"}
{"parentUuid":"66967ac3-9559-41f3-aca7-57dc9ea84843","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01XdyYoLtHRAZ95w6t3ZVdwT","parentToolUseID":"toolu_01XdyYoLtHRAZ95w6t3ZVdwT","uuid":"be15b254-9706-421b-8895-2b1487b35154","timestamp":"2026-02-14T12:29:43.781Z"}
{"parentUuid":"be15b254-9706-421b-8895-2b1487b35154","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01XdyYoLtHRAZ95w6t3ZVdwT","toolUseID":"toolu_01XdyYoLtHRAZ95w6t3ZVdwT","timestamp":"2026-02-14T12:29:43.841Z","uuid":"2af3f96d-2c3a-43c5-9adf-ed3ce9f7a315"}
{"parentUuid":"2af3f96d-2c3a-43c5-9adf-ed3ce9f7a315","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01XdyYoLtHRAZ95w6t3ZVdwT","toolUseID":"toolu_01XdyYoLtHRAZ95w6t3ZVdwT","timestamp":"2026-02-14T12:29:43.841Z","uuid":"1612ab8d-22ae-4e19-b83d-fd1510843b94"}
{"parentUuid":"66967ac3-9559-41f3-aca7-57dc9ea84843","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01XdyYoLtHRAZ95w6t3ZVdwT","type":"tool_result","content":"  1050→- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n  1051→- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n  1052→\n  1053→User gets 2 PRs to compare side-by-side.\n  1054→\n  1055→---\n  1056→\n  1057→## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n  1058→\n  1059→A simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n  1060→\n  1061→```typescript\n  1062→function loadPrompt(name: string): string {\n  1063→  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n  1064→}"}]},"uuid":"a3750e77-1a34-4815-ac48-30c0d2e9039b","timestamp":"2026-02-14T12:29:43.840Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}","numLines":15,"startLine":1050,"totalLines":1143}},"sourceToolAssistantUUID":"66967ac3-9559-41f3-aca7-57dc9ea84843"}
{"parentUuid":"a3750e77-1a34-4815-ac48-30c0d2e9039b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_015noyhUXaxcUhKiTyiRKZB3","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01HBJ7EvtSxx4P32PJ8a4AtQ","name":"Read","input":{"file_path":"REDACTED.md","offset":1053,"limit":55},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":364,"cache_read_input_tokens":62804,"output_tokens":114,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":364},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7xpQJnAxBr23RTcQhj6","type":"assistant","uuid":"edd39781-cecb-42eb-8da9-00322bf05323","timestamp":"2026-02-14T12:29:46.921Z"}
{"parentUuid":"edd39781-cecb-42eb-8da9-00322bf05323","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01HBJ7EvtSxx4P32PJ8a4AtQ","parentToolUseID":"toolu_01HBJ7EvtSxx4P32PJ8a4AtQ","uuid":"51d1463d-b902-4c64-930c-66f6d075d3eb","timestamp":"2026-02-14T12:29:46.926Z"}
{"parentUuid":"51d1463d-b902-4c64-930c-66f6d075d3eb","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01HBJ7EvtSxx4P32PJ8a4AtQ","toolUseID":"toolu_01HBJ7EvtSxx4P32PJ8a4AtQ","timestamp":"2026-02-14T12:29:47.002Z","uuid":"7df4d125-5be3-4904-a442-a77848d6e2fc"}
{"parentUuid":"7df4d125-5be3-4904-a442-a77848d6e2fc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01HBJ7EvtSxx4P32PJ8a4AtQ","toolUseID":"toolu_01HBJ7EvtSxx4P32PJ8a4AtQ","timestamp":"2026-02-14T12:29:47.002Z","uuid":"08ce646d-a51f-4977-a08e-8749f6772b1f"}
{"parentUuid":"edd39781-cecb-42eb-8da9-00322bf05323","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01HBJ7EvtSxx4P32PJ8a4AtQ","type":"tool_result","content":"  1053→User gets 2 PRs to compare side-by-side.\n  1054→\n  1055→---\n  1056→\n  1057→## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n  1058→\n  1059→A simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n  1060→\n  1061→```typescript\n  1062→function loadPrompt(name: string): string {\n  1063→  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n  1064→}\n  1065→\n  1066→function fillTemplate(template: string, vars: Record<string, string>): string {\n  1067→  return Object.entries(vars).reduce(\n  1068→    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  1069→  );\n  1070→}\n  1071→```\n  1072→\n  1073→Each `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n  1074→\n  1075→```typescript\n  1076→// Example: buildTestWriterPrompt\n  1077→const template = loadPrompt(\"agent2-worker-test.md\");\n  1078→return fillTemplate(template, {\n  1079→  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  1080→  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  1081→  IS_TERMINAL: String(isTerminal),\n  1082→  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n  1083→});\n  1084→```\n  1085→\n  1086→For the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n  1087→\n  1088→```typescript\n  1089→// Example: buildMergePrompt\n  1090→const fragmentMap: Record<string, string> = {\n  1091→  auto:  \"fragments/merge-auto.md\",\n  1092→  merge: \"fragments/merge-direct.md\",\n  1093→  pr:    \"fragments/merge-pr.md\",\n  1094→};\n  1095→const template = loadPrompt(fragmentMap[this.mergeMode]);\n  1096→return fillTemplate(template, {\n  1097→  BRANCH_NAME: this.branchName(task),\n  1098→  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  1099→  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n  1100→});\n  1101→```\n  1102→\n  1103→---\n  1104→\n  1105→## Files\n  1106→\n  1107→| File | Change |"}]},"uuid":"956907d5-d28f-458c-9901-c895ab4407e7","timestamp":"2026-02-14T12:29:47.001Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"User gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n\n```typescript\n// Example: buildMergePrompt\nconst fragmentMap: Record<string, string> = {\n  auto:  \"fragments/merge-auto.md\",\n  merge: \"fragments/merge-direct.md\",\n  pr:    \"fragments/merge-pr.md\",\n};\nconst template = loadPrompt(fragmentMap[this.mergeMode]);\nreturn fillTemplate(template, {\n  BRANCH_NAME: this.branchName(task),\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n});\n```\n\n---\n\n## Files\n\n| File | Change |","numLines":55,"startLine":1053,"totalLines":1143}},"sourceToolAssistantUUID":"edd39781-cecb-42eb-8da9-00322bf05323"}
{"parentUuid":"956907d5-d28f-458c-9901-c895ab4407e7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01DLXmvNFPsRMpkRoyJtgmty","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Y3zVBMhiddYbT4Z3LPF4K9","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"User gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n\n```typescript\n// Example: buildMergePrompt\nconst fragmentMap: Record<string, string> = {\n  auto:  \"fragments/merge-auto.md\",\n  merge: \"fragments/merge-direct.md\",\n  pr:    \"fragments/merge-pr.md\",\n};\nconst template = loadPrompt(fragmentMap[this.mergeMode]);\nreturn fillTemplate(template, {\n  BRANCH_NAME: this.branchName(task),\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n});\n```\n\n---\n\n## Files","new_string":"User gets 2 PRs to compare side-by-side.\n\n---\n\n## Files"},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":897,"cache_read_input_tokens":63168,"cache_creation":{"ephemeral_5m_input_tokens":897,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xpdrryoh7EXwmf4ViD","type":"assistant","uuid":"7ec84a3f-3de7-4127-95eb-e6c7b80f1536","timestamp":"2026-02-14T12:29:53.790Z"}
{"parentUuid":"7ec84a3f-3de7-4127-95eb-e6c7b80f1536","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01Y3zVBMhiddYbT4Z3LPF4K9","parentToolUseID":"toolu_01Y3zVBMhiddYbT4Z3LPF4K9","uuid":"7979a275-bb4a-4b0a-9390-7783582a65be","timestamp":"2026-02-14T12:29:53.793Z"}
{"parentUuid":"7979a275-bb4a-4b0a-9390-7783582a65be","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01Y3zVBMhiddYbT4Z3LPF4K9","toolUseID":"toolu_01Y3zVBMhiddYbT4Z3LPF4K9","timestamp":"2026-02-14T12:29:53.840Z","uuid":"8fd81c8c-319c-4168-b768-dc2c2a4b06f9"}
{"parentUuid":"8fd81c8c-319c-4168-b768-dc2c2a4b06f9","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01Y3zVBMhiddYbT4Z3LPF4K9","toolUseID":"toolu_01Y3zVBMhiddYbT4Z3LPF4K9","timestamp":"2026-02-14T12:29:53.840Z","uuid":"930e19ab-a51a-46d2-aabf-b2b026547d7e"}
{"parentUuid":"7ec84a3f-3de7-4127-95eb-e6c7b80f1536","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Y3zVBMhiddYbT4Z3LPF4K9","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"b85cdfe6-1372-4497-8714-b7fd65d61e19","timestamp":"2026-02-14T12:29:53.840Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"User gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n\n```typescript\n// Example: buildMergePrompt\nconst fragmentMap: Record<string, string> = {\n  auto:  \"fragments/merge-auto.md\",\n  merge: \"fragments/merge-direct.md\",\n  pr:    \"fragments/merge-pr.md\",\n};\nconst template = loadPrompt(fragmentMap[this.mergeMode]);\nreturn fillTemplate(template, {\n  BRANCH_NAME: this.branchName(task),\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n});\n```\n\n---\n\n## Files","newString":"User gets 2 PRs to compare side-by-side.\n\n---\n\n## Files","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. PromptLoader                      — depends_on: []\n3. TaskStatus enum + helpers         — depends_on: []\n4. SpecAgent (Phase 1)               — depends_on: [1, 2]\n5. Orchestrator refactor (Phase 3)   — depends_on: [2, 3]\n6. Test-Writer (Phase 5)             — depends_on: [5]\n7. Entry Point (Phase 4)             — depends_on: [4, 5]\n8. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #2 (PromptLoader), #3 (TaskStatus), #8 (Prompt adaptations)\n  Wave 2: #4 (SpecAgent), #5 (Orchestrator)  — #4 needs #1+#2, #5 needs #2+#3\n  Wave 3: #6 (Test-Writer), #7 (Entry Point) — #6 needs #5, #7 needs #4+#5\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #8 is pure markdown edits with no code dependencies — safe for wave 1\n- #4 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n- Merge agent is part of #5 (Orchestrator) — uses merge-auto.md fragment via PromptLoader\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n\n```typescript\n// Example: buildMergePrompt\nconst fragmentMap: Record<string, string> = {\n  auto:  \"fragments/merge-auto.md\",\n  merge: \"fragments/merge-direct.md\",\n  pr:    \"fragments/merge-pr.md\",\n};\nconst template = loadPrompt(fragmentMap[this.mergeMode]);\nreturn fillTemplate(template, {\n  BRANCH_NAME: this.branchName(task),\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n});\n```\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n#### Configuration (environment variables with defaults)\n\n| Env Var | Default | Description |\n|---------|---------|-------------|\n| `NAPOLI_MAX_CONCURRENCY` | `3` | Maximum parallel worker sandboxes |\n| `NAPOLI_MAX_ITERATIONS` | `0` (infinite) | Total stage dispatches before exiting. `0` = run forever. |\n| `NAPOLI_POLL_INTERVAL` | `30` | Seconds to sleep when no tasks are eligible |\n| `NAPOLI_MERGE_MODE` | `auto` | Merge fragment selection: `auto`, `merge`, or `pr` |\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status\n\n**Crash recovery (worker failure)**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.\n\n**Crash recovery (orchestrator failure)**: If the orchestrator process itself crashes while tickets are `* In Progress`, those tickets remain stuck — `isActionable()` only matches `Needs *` statuses. In v1, a human must manually reset orphaned `In Progress` tickets back to their `Needs *` counterpart to resume processing. A future version could add a startup sweep or timeout-based recovery.\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### Agent Runner Pattern\n\n`runWorkerAgent()`, `runTestWriterAgent()`, and `runMergeAgent()` all follow the same pattern inherited from the existing `executeClaudeCommand()`:\n\n1. Open a PTY session in the Daytona sandbox via the SDK\n2. Invoke `claude -p '<prompt>' --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n3. Stream stdout line-by-line, parse JSON events, log to file\n4. Extract structured output (WORK_RESULT / TEST_RESULT) from the `result` event\n5. Return parsed result\n\nThe only difference between the three is which prompt they receive and which output block they parse.\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Receives one of three merge fragment prompts (selected by `mergeMode` config):\n   - **`merge-auto.md`** (default) — self-contained decision rubric that evaluates the change and chooses direct merge or PR at runtime\n   - **`merge-direct.md`** — always merge directly to main (for trusted, low-risk pipelines)\n   - **`merge-pr.md`** — always create a PR (for repos requiring review)\n3. Executes `git merge --no-ff` or `gh pr create` based on the selected mode's instructions\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe three fragments are **independent, mutually exclusive modes** (ported from Horizon). Each is a complete standalone prompt — `merge-auto.md` does not delegate to the other two. The orchestrator selects which fragment to load via a `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`).\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox, checkout branch\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)\n  5. Return combined result (stage + test summary + merge status)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {{TICKET_CONTEXT}}\n**Branch diff vs main**: {{BRANCH_DIFF}}\n**Is terminal ticket**: {{IS_TERMINAL}}\n{{CHAIN_TICKETS}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nprivate codeProducingStages = new Set([\n  \"Needs Implement\",\n  \"Needs Validate\",\n  \"Needs Oneshot\",\n]);\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `inProgressStatus()` — Status Transition Helper\n\nMaps each actionable `Needs *` status to its corresponding `* In Progress` status:\n\n```typescript\nconst inProgressMap: Record<string, TaskStatus> = {\n  [TaskStatus.NeedsResearch]:      TaskStatus.ResearchInProgress,\n  [TaskStatus.NeedsSpecification]: TaskStatus.SpecificationInProgress,\n  [TaskStatus.NeedsPlan]:          TaskStatus.PlanInProgress,\n  [TaskStatus.NeedsImplement]:     TaskStatus.ImplementInProgress,\n  [TaskStatus.NeedsValidate]:      TaskStatus.ValidateInProgress,\n  [TaskStatus.NeedsOneshot]:       TaskStatus.OneshotInProgress,\n};\n\nfunction inProgressStatus(status: TaskStatus): TaskStatus {\n  return inProgressMap[status] ?? status;\n}\n```\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n\n```typescript\n// Example: buildMergePrompt\nconst fragmentMap: Record<string, string> = {\n  auto:  \"fragments/merge-auto.md\",\n  merge: \"fragments/merge-direct.md\",\n  pr:    \"fragments/merge-pr.md\",\n};\nconst template = loadPrompt(fragmentMap[this.mergeMode]);\nreturn fillTemplate(template, {\n  BRANCH_NAME: this.branchName(task),\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n});\n```\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Self-contained merge agent prompt for `auto` mode. Evaluates the change at runtime and chooses direct merge or PR. Default `mergeMode`. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Standalone merge agent prompt for `merge` mode. Always merges directly to main. |\n| `prompts/fragments/merge-pr.md` | **Existing** — Standalone merge agent prompt for `pr` mode. Always creates a PR. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n","structuredPatch":[{"oldStart":1054,"oldLines":54,"newStart":1054,"newLines":6,"lines":[" "," ---"," ","-## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)","-","-A simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:","-","-```typescript","-function loadPrompt(name: string): string {","-  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");","-}","-","-function fillTemplate(template: string, vars: Record<string, string>): string {","-  return Object.entries(vars).reduce(","-    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template","-  );","-}","-```","-","-Each `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:","-","-```typescript","-// Example: buildTestWriterPrompt","-const template = loadPrompt(\"agent2-worker-test.md\");","-return fillTemplate(template, {","-  TICKET_CONTEXT: `${task.title}\\n${task.description}`,","-  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),","-  IS_TERMINAL: String(isTerminal),","-  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",","-});","-```","-","-For the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):","-","-```typescript","-// Example: buildMergePrompt","-const fragmentMap: Record<string, string> = {","-  auto:  \"fragments/merge-auto.md\",","-  merge: \"fragments/merge-direct.md\",","-  pr:    \"fragments/merge-pr.md\",","-};","-const template = loadPrompt(fragmentMap[this.mergeMode]);","-return fillTemplate(template, {","-  BRANCH_NAME: this.branchName(task),","-  TICKET_CONTEXT: `${task.title}\\n${task.description}`,","-  TEST_RESULTS: testResult?.summary ?? \"No tests run\",","-});","-```","-","----","-"," ## Files"," "," | File | Change |"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"7ec84a3f-3de7-4127-95eb-e6c7b80f1536"}
{"parentUuid":"b85cdfe6-1372-4497-8714-b7fd65d61e19","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_017T4QpWjyF8fJ8EuVQpry85","type":"message","role":"assistant","content":[{"type":"text","text":"PromptLoader moved to before Phase 3. Now Minor Nit 2.\n\n### Minor Nit 2: `--dangerously-skip-permissions` for ClaudeSpawner\n\nThe flag is noted on line 369 for ClaudeSpawner (used by the Spec Agent). Worth noting this is intentional — the spec agent only evaluates text, it doesn't execute code."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":732,"cache_read_input_tokens":64065,"cache_creation":{"ephemeral_5m_input_tokens":732,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xq942fNYABZTq2MHWp","type":"assistant","uuid":"4238fe37-5be2-4144-815f-29039c2f58aa","timestamp":"2026-02-14T12:29:58.565Z"}
{"parentUuid":"4238fe37-5be2-4144-815f-29039c2f58aa","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_017T4QpWjyF8fJ8EuVQpry85","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01AiYpriLYM4rwzPZGdapiXW","name":"AskUserQuestion","input":{"questions":[{"question":"Should I add a brief note to the ClaudeSpawner section explaining why --dangerously-skip-permissions is safe for the spec agent (text evaluation only, no code execution)?","header":"Safety note","options":[{"label":"Yes, add note","description":"Add a one-line rationale so future readers understand the security trade-off."},{"label":"No, skip","description":"It's obvious from context — the spec agent only asks questions and produces YAML tickets."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":732,"cache_read_input_tokens":64065,"output_tokens":276,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":732},"inference_geo":"","iterations":[],"speed":"standard"}},"requestId":"req_011CY7xq942fNYABZTq2MHWp","type":"assistant","uuid":"b2cd07b0-8d75-4081-be8f-ede695f549b7","timestamp":"2026-02-14T12:30:01.884Z"}
{"parentUuid":"b2cd07b0-8d75-4081-be8f-ede695f549b7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01AiYpriLYM4rwzPZGdapiXW","parentToolUseID":"toolu_01AiYpriLYM4rwzPZGdapiXW","uuid":"facfff65-6ea4-4ebb-8ec2-d00c7923fc6e","timestamp":"2026-02-14T12:30:01.887Z"}
{"parentUuid":"facfff65-6ea4-4ebb-8ec2-d00c7923fc6e","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01AiYpriLYM4rwzPZGdapiXW","toolUseID":"toolu_01AiYpriLYM4rwzPZGdapiXW","timestamp":"2026-02-14T12:30:25.181Z","uuid":"1c1c03e3-3a84-4552-9dc1-06399ddc5b6c"}
{"parentUuid":"b2cd07b0-8d75-4081-be8f-ede695f549b7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"Should I add a brief note to the ClaudeSpawner section explaining why --dangerously-skip-permissions is safe for the spec agent (text evaluation only, no code execution)?\"=\"No, skip\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_01AiYpriLYM4rwzPZGdapiXW"}]},"uuid":"93d9db95-1f0c-4dea-8a62-e61e6f0668ee","timestamp":"2026-02-14T12:30:25.179Z","toolUseResult":{"questions":[{"question":"Should I add a brief note to the ClaudeSpawner section explaining why --dangerously-skip-permissions is safe for the spec agent (text evaluation only, no code execution)?","header":"Safety note","options":[{"label":"Yes, add note","description":"Add a one-line rationale so future readers understand the security trade-off."},{"label":"No, skip","description":"It's obvious from context — the spec agent only asks questions and produces YAML tickets."}],"multiSelect":false}],"answers":{"Should I add a brief note to the ClaudeSpawner section explaining why --dangerously-skip-permissions is safe for the spec agent (text evaluation only, no code execution)?":"No, skip"}},"sourceToolAssistantUUID":"b2cd07b0-8d75-4081-be8f-ede695f549b7"}
{"parentUuid":"93d9db95-1f0c-4dea-8a62-e61e6f0668ee","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_018L1rmXq5UWwWbNcSpgywTa","type":"message","role":"assistant","content":[{"type":"text","text":"Skipped. Final nit.\n\n### Minor Nit 3: `loadAllTasks()` called twice in `dispatchStage`\n\n`dispatchStage` calls `isTerminal()` which internally calls `loadAllTasks()` again — meaning two full glob scans of `feature_requests/` per dispatch. Minor perf concern for large queues."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":352,"cache_read_input_tokens":64797,"cache_creation":{"ephemeral_5m_input_tokens":352,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xsTDV4JBJP4yNkQDjb","type":"assistant","uuid":"a1ee159c-ab75-4280-88d2-bb2ae4c1f5ea","timestamp":"2026-02-14T12:30:29.828Z"}
{"parentUuid":"a1ee159c-ab75-4280-88d2-bb2ae4c1f5ea","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_018L1rmXq5UWwWbNcSpgywTa","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016UELivbKAfKzfifg7VPFak","name":"AskUserQuestion","input":{"questions":[{"question":"loadAllTasks() is called twice per dispatch (once in dispatchStage, once inside isTerminal). Should we note this as a future optimization, or change the plan to pass the already-loaded task list?","header":"Double load","options":[{"label":"Pass task list to isTerminal","description":"Change isTerminal(task) to isTerminal(task, allTasks) so it reuses the list from filterEligible. Update the plan's code snippets."},{"label":"Note as future optimization","description":"Add a brief comment that this is a known double-read, acceptable for v1 queue sizes. Optimize later if queues grow large."},{"label":"No change needed","description":"File glob on a small local directory is negligible. Not worth documenting or changing."}],"multiSelect":false}]},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":352,"cache_read_input_tokens":64797,"cache_creation":{"ephemeral_5m_input_tokens":352,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xsTDV4JBJP4yNkQDjb","type":"assistant","uuid":"93d07266-e0f9-4ce3-a69b-52dfbc6dbd66","timestamp":"2026-02-14T12:30:34.772Z"}
{"parentUuid":"93d07266-e0f9-4ce3-a69b-52dfbc6dbd66","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_016UELivbKAfKzfifg7VPFak","parentToolUseID":"toolu_016UELivbKAfKzfifg7VPFak","uuid":"5319f455-ba5b-4e7e-b070-3c8d71512d42","timestamp":"2026-02-14T12:30:34.775Z"}
{"parentUuid":"5319f455-ba5b-4e7e-b070-3c8d71512d42","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:AskUserQuestion","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_016UELivbKAfKzfifg7VPFak","toolUseID":"toolu_016UELivbKAfKzfifg7VPFak","timestamp":"2026-02-14T12:31:01.337Z","uuid":"682e99c8-10ca-4070-b58d-c4c658b1abd4"}
{"parentUuid":"93d07266-e0f9-4ce3-a69b-52dfbc6dbd66","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"type":"tool_result","content":"User has answered your questions: \"loadAllTasks() is called twice per dispatch (once in dispatchStage, once inside isTerminal). Should we note this as a future optimization, or change the plan to pass the already-loaded task list?\"=\"Note as future optimization\". You can now continue with the user's answers in mind.","tool_use_id":"toolu_016UELivbKAfKzfifg7VPFak"}]},"uuid":"bcd547bb-fb12-4557-9a89-3335c7638bfc","timestamp":"2026-02-14T12:31:01.334Z","toolUseResult":{"questions":[{"question":"loadAllTasks() is called twice per dispatch (once in dispatchStage, once inside isTerminal). Should we note this as a future optimization, or change the plan to pass the already-loaded task list?","header":"Double load","options":[{"label":"Pass task list to isTerminal","description":"Change isTerminal(task) to isTerminal(task, allTasks) so it reuses the list from filterEligible. Update the plan's code snippets."},{"label":"Note as future optimization","description":"Add a brief comment that this is a known double-read, acceptable for v1 queue sizes. Optimize later if queues grow large."},{"label":"No change needed","description":"File glob on a small local directory is negligible. Not worth documenting or changing."}],"multiSelect":false}],"answers":{"loadAllTasks() is called twice per dispatch (once in dispatchStage, once inside isTerminal). Should we note this as a future optimization, or change the plan to pass the already-loaded task list?":"Note as future optimization"}},"sourceToolAssistantUUID":"93d07266-e0f9-4ce3-a69b-52dfbc6dbd66"}
{"parentUuid":"bcd547bb-fb12-4557-9a89-3335c7638bfc","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01JRmDtDtvmiWowWeHb5invM","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01BPHkNty8cA5nfNL3pR4KrZ","name":"Grep","input":{"pattern":"private async isTerminal","path":"REDACTED.md","output_mode":"content","-n":true},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":532,"cache_read_input_tokens":65149,"cache_creation":{"ephemeral_5m_input_tokens":532,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xv7j3hRkzPpnW1aQWG","type":"assistant","uuid":"65e7ca69-a0ae-4468-b613-5a82496a1747","timestamp":"2026-02-14T12:31:04.774Z"}
{"parentUuid":"65e7ca69-a0ae-4468-b613-5a82496a1747","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01BPHkNty8cA5nfNL3pR4KrZ","parentToolUseID":"toolu_01BPHkNty8cA5nfNL3pR4KrZ","uuid":"c9a54404-e559-49d1-8b6f-d90453f85123","timestamp":"2026-02-14T12:31:04.777Z"}
{"parentUuid":"c9a54404-e559-49d1-8b6f-d90453f85123","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01BPHkNty8cA5nfNL3pR4KrZ","toolUseID":"toolu_01BPHkNty8cA5nfNL3pR4KrZ","timestamp":"2026-02-14T12:31:05.114Z","uuid":"f4e2b62c-e73c-4080-b479-c17487637213"}
{"parentUuid":"f4e2b62c-e73c-4080-b479-c17487637213","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Grep","command":"callback"},"parentToolUseID":"toolu_01BPHkNty8cA5nfNL3pR4KrZ","toolUseID":"toolu_01BPHkNty8cA5nfNL3pR4KrZ","timestamp":"2026-02-14T12:31:05.114Z","uuid":"d00a8c7f-aa0d-4b9f-b76f-92d35102a03a"}
{"parentUuid":"65e7ca69-a0ae-4468-b613-5a82496a1747","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01BPHkNty8cA5nfNL3pR4KrZ","type":"tool_result","content":"571:private async isTerminal(task: TaskRequest): Promise<boolean> {"}]},"uuid":"763fc999-2b3a-41dc-a417-9186b377067c","timestamp":"2026-02-14T12:31:05.112Z","toolUseResult":{"mode":"content","numFiles":0,"filenames":[],"content":"571:private async isTerminal(task: TaskRequest): Promise<boolean> {","numLines":1},"sourceToolAssistantUUID":"65e7ca69-a0ae-4468-b613-5a82496a1747"}
{"parentUuid":"763fc999-2b3a-41dc-a417-9186b377067c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01XXGLitu3Xi9X3jffGzt6Np","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DwNFVtwkQ5cxKiG8UfMtwe","name":"Read","input":{"file_path":"REDACTED.md","offset":569,"limit":12},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":166,"cache_read_input_tokens":65681,"cache_creation":{"ephemeral_5m_input_tokens":166,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xvPqAiMEE2YkqMugqR","type":"assistant","uuid":"84675247-d6ee-4b13-8e75-34b6c662843c","timestamp":"2026-02-14T12:31:08.036Z"}
{"parentUuid":"84675247-d6ee-4b13-8e75-34b6c662843c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01DwNFVtwkQ5cxKiG8UfMtwe","parentToolUseID":"toolu_01DwNFVtwkQ5cxKiG8UfMtwe","uuid":"152cdff8-8f39-4283-a3d1-a0921e974ce4","timestamp":"2026-02-14T12:31:08.040Z"}
{"parentUuid":"152cdff8-8f39-4283-a3d1-a0921e974ce4","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01DwNFVtwkQ5cxKiG8UfMtwe","toolUseID":"toolu_01DwNFVtwkQ5cxKiG8UfMtwe","timestamp":"2026-02-14T12:31:08.098Z","uuid":"3f5172e0-a201-4715-8e67-96552e995af7"}
{"parentUuid":"3f5172e0-a201-4715-8e67-96552e995af7","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Read","command":"callback"},"parentToolUseID":"toolu_01DwNFVtwkQ5cxKiG8UfMtwe","toolUseID":"toolu_01DwNFVtwkQ5cxKiG8UfMtwe","timestamp":"2026-02-14T12:31:08.098Z","uuid":"c376581c-7da5-4cdf-a2a5-d9d8e561a3b9"}
{"parentUuid":"84675247-d6ee-4b13-8e75-34b6c662843c","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DwNFVtwkQ5cxKiG8UfMtwe","type":"tool_result","content":"   569→\n   570→```typescript\n   571→private async isTerminal(task: TaskRequest): Promise<boolean> {\n   572→  const allTasks = await this.loadAllTasks();  // all statuses\n   573→  return !allTasks.some(t =>\n   574→    t.id !== task.id &&\n   575→    t.dependsOn.includes(task.id) &&\n   576→    t.status !== TaskStatus.Done\n   577→  );\n   578→}\n   579→```\n   580→"}]},"uuid":"c1d2879d-a08f-47e8-8ee3-f6091bc23f46","timestamp":"2026-02-14T12:31:08.097Z","toolUseResult":{"type":"text","file":{"filePath":"REDACTED.md","content":"\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n","numLines":12,"startLine":569,"totalLines":1095}},"sourceToolAssistantUUID":"84675247-d6ee-4b13-8e75-34b6c662843c"}
{"parentUuid":"c1d2879d-a08f-47e8-8ee3-f6091bc23f46","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01PBC7iaKA1zEszLLNeT2PmE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01S3M3FiF4pvswVRR5jprxVP","name":"Edit","input":{"replace_all":false,"file_path":"REDACTED.md","old_string":"```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```","new_string":"```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Note**: `isTerminal()` calls `loadAllTasks()` independently, which means a second glob scan when called from `dispatchStage()`. Acceptable for v1 queue sizes; future optimization can pass the pre-loaded task list as a parameter."},"caller":{"type":"direct"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":256,"cache_read_input_tokens":65847,"cache_creation":{"ephemeral_5m_input_tokens":256,"ephemeral_1h_input_tokens":0},"output_tokens":24,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xvcd7LNrRqNNeWEcHC","type":"assistant","uuid":"f2db9f4b-093e-4760-bcdc-9291de8c8b6b","timestamp":"2026-02-14T12:31:13.723Z"}
{"parentUuid":"f2db9f4b-093e-4760-bcdc-9291de8c8b6b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PreToolUse","hookName":"PreToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/pretooluse.py"},"toolUseID":"toolu_01S3M3FiF4pvswVRR5jprxVP","parentToolUseID":"toolu_01S3M3FiF4pvswVRR5jprxVP","uuid":"d27ee63d-15ad-4645-be97-114565eb4817","timestamp":"2026-02-14T12:31:13.725Z"}
{"parentUuid":"d27ee63d-15ad-4645-be97-114565eb4817","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/posttooluse.py"},"parentToolUseID":"toolu_01S3M3FiF4pvswVRR5jprxVP","toolUseID":"toolu_01S3M3FiF4pvswVRR5jprxVP","timestamp":"2026-02-14T12:31:13.769Z","uuid":"29fc4430-121a-4dd5-bbc0-dc1d5aebfef0"}
{"parentUuid":"29fc4430-121a-4dd5-bbc0-dc1d5aebfef0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"PostToolUse","hookName":"PostToolUse:Edit","command":"callback"},"parentToolUseID":"toolu_01S3M3FiF4pvswVRR5jprxVP","toolUseID":"toolu_01S3M3FiF4pvswVRR5jprxVP","timestamp":"2026-02-14T12:31:13.769Z","uuid":"aefa83df-a52f-40cc-97ee-6e4b9a2273d7"}
{"parentUuid":"f2db9f4b-093e-4760-bcdc-9291de8c8b6b","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01S3M3FiF4pvswVRR5jprxVP","type":"tool_result","content":"The file REDACTED.md has been updated successfully."}]},"uuid":"1bc5cf79-609d-4fc5-ab4b-c285fcb7d669","timestamp":"2026-02-14T12:31:13.768Z","toolUseResult":{"filePath":"REDACTED.md","oldString":"```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```","newString":"```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Note**: `isTerminal()` calls `loadAllTasks()` independently, which means a second glob scan when called from `dispatchStage()`. Acceptable for v1 queue sizes; future optimization can pass the pre-loaded task list as a parameter.","originalFile":"<!--\nHORIZON AGENT INSTRUCTIONS:\nThis plan contains 5 major phases with significant new components and core refactoring.\nPlease decompose this into sub-issues for judicious parallel execution where possible.\n\nSub-issues with explicit dependencies:\n1. ClaudeSpawner (Phase 2)           — depends_on: []\n2. PromptLoader                      — depends_on: []\n3. TaskStatus enum + helpers         — depends_on: []\n4. SpecAgent (Phase 1)               — depends_on: [1, 2]\n5. Orchestrator refactor (Phase 3)   — depends_on: [2, 3]\n6. Test-Writer (Phase 5)             — depends_on: [5]\n7. Entry Point (Phase 4)             — depends_on: [4, 5]\n8. Prompt adaptations (agent2-worker*.md) — depends_on: []\n\nExecution waves:\n  Wave 1: #1 (ClaudeSpawner), #2 (PromptLoader), #3 (TaskStatus), #8 (Prompt adaptations)\n  Wave 2: #4 (SpecAgent), #5 (Orchestrator)  — #4 needs #1+#2, #5 needs #2+#3\n  Wave 3: #6 (Test-Writer), #7 (Entry Point) — #6 needs #5, #7 needs #4+#5\n\nNotes:\n- Phase 3 (Orchestrator) is the most complex and touches many files\n- #8 is pure markdown edits with no code dependencies — safe for wave 1\n- #4 cannot be tested without #1 (SpecAgent uses ClaudeSpawner)\n- Merge agent is part of #5 (Orchestrator) — uses merge-auto.md fragment via PromptLoader\n-->\n\n# Plan: Agent Pipeline Enhancement in Napoli-Matcha project\n\n---\n\n## Reference Architecture: Horizon CLI Agent\n\n> **Horizon CLI Agent repo**: `/Users/ob1/projects/startup/horizon-cli-agent`\n>\n> Horizon has a **working implementation** of the 3-agent pipeline (Linear Reader → Worker → Linear Writer) that napoli-matcha is adapting. Use it as a reference for:\n>\n> - **Claude spawning** — `src/lib/claude.ts`: streaming JSON parsing, `claude -p --output-format=stream-json --verbose` invocation. Napoli's `ClaudeSpawner` (Phase 2) is a simplified version of this.\n> - **Prompt loading** — `src/lib/prompts.ts`: loads from `.horizon/prompts/` with fallback to package `prompts/`. Napoli should follow the same pattern but load from `prompts/`.\n> - **6-stage worker pipeline** — `prompts/agent2-worker-*.md`: research → specification → plan → implement → validate (+ oneshot fast-track). These stages are directly portable.\n> - **Orchestrator loop** — `src/lib/claude.ts` + main loop: how agents are dispatched, results collected, and state transitions managed.\n>\n> ### Key Difference: Linear vs Local Queue\n>\n> | Concern | Horizon | Napoli-Matcha |\n> |---------|---------|---------------|\n> | **Ticket storage** | Linear (via MCP tools: `mcp__linear__list_issues`, `mcp__linear__get_issue`, etc.) | Local MD files in `feature_requests/` with YAML frontmatter |\n> | **Status updates** | Linear API (`mcp__linear__update_issue`) | Update YAML `status:` field in the MD file |\n> | **Result posting** | Linear comments (`mcp__linear__create_comment`) | Append results section to the MD file body |\n> | **Sub-issue creation** | Linear API (`mcp__linear__create_issue`) | Write new MD files to `feature_requests/` |\n> | **Agent 1 (Reader)** | Claude agent queries Linear for issues in specific statuses | **Absorbed into TypeScript orchestrator** — `loadAllTasks()` reads `feature_requests/**/AGI-*.md`, `filterEligible()` selects dispatch candidates |\n> | **Agent 3 (Writer)** | Claude agent posts comments + updates Linear issue status | **Absorbed into TypeScript orchestrator** — `writeResults()` updates MD frontmatter + appends result sections, `updateTaskStatus()` sets status |\n>\n> When implementing, **always check the Horizon equivalent first** for patterns, then adapt to local file I/O.\n\n---\n\n## Prompts Directory (`prompts/`)\n\nThe `prompts/` directory contains agent prompts **ported from Horizon**. They follow Horizon's 3-agent architecture but need adaptation for napoli-matcha's local queue system.\n\n### Prompt Mapping & Adaptation Status\n\n| File | Horizon Role | Napoli Role | Adaptation Needed |\n|------|-------------|-------------|-------------------|\n| `agent1-linear-reader.md` | Reads tickets from Linear via MCP | **Removed** — logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) | **N/A** — No longer a Claude agent. Deterministic queue reading doesn't need LLM reasoning. |\n| `agent2-worker.md` | Stage router (dispatches to stage-specific prompts) | **Worker Router** — same role | **LOW** — Update file path references from `.horizon/prompts/` to `prompts/` |\n| `agent2-worker-oneshot.md` | Fast-track for simple tasks (~100 LOC) | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent2-worker-research.md` | Assess complexity, decide oneshot vs staged | Same | **NONE** — Direct port |\n| `agent2-worker-specification.md` | PM/designer perspective, write spec | Same | **NONE** — Direct port |\n| `agent2-worker-plan.md` | Break into implementation phases | Same | **NONE** — Direct port |\n| `agent2-worker-implement.md` | Execute phases, commit, push | Same | **NONE** — Direct port |\n| `agent2-worker-validate.md` | Run tests, verify success criteria | Same | **NONE** — Direct port, fill `{{MERGE_INSTRUCTIONS}}` placeholder |\n| `agent3-linear-writer.md` | Posts results to Linear, updates status | **Removed** — logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) | **N/A** — No longer a Claude agent. WORK_RESULT parsing and MD file updates are deterministic. |\n| `fragments/merge-auto.md` | Decision rubric for merge strategy | Same | **NONE** — Pure git operations, no Linear deps |\n| `fragments/merge-direct.md` | Direct merge path | Same | **NONE** |\n| `fragments/merge-pr.md` | PR creation path | Same | **NONE** |\n\n### New Prompts Needed\n\n| File | Purpose | Phase |\n|------|---------|-------|\n| `agent0-spec.md` | **Spec Agent prompt** — evaluates request against 5 quality criteria, asks clarifying questions or produces structured tickets. See Phase 1 below. | Phase 1: Spec Agent |\n| `agent2-worker-test.md` | **Test-Writer Agent prompt** — reads git diff + ticket context, writes unit tests (all tickets) + integration tests (terminal only). See Phase 5 below. | Phase 5: Test-Writer |\n\n### How Prompts Are Used in the Pipeline\n\n```\nUser request\n  │\n  ▼\nagent0-spec.md (Spec Agent — LOCAL, via ClaudeSpawner)\n  │ Clarification loop until spec meets 5 quality criteria\n  │ Writes tickets to feature_requests/FR-{n}/\n  ▼\nOrchestrator (TypeScript — replaces agent1/agent3)\n  │ loadAllTasks() reads feature_requests/**/AGI-*.md\n  │ filterEligible() selects dispatch candidates\n  │ Dispatches one stage per worker invocation\n  ▼\nagent2-worker.md → agent2-worker-{stage}.md (Worker — IN SANDBOX)\n  │ 6-stage pipeline: research → spec → plan → implement → validate\n  │ (or oneshot fast-track)\n  ▼\nagent2-worker-test.md (Test Writer — IN SAME SANDBOX, after implement/validate/oneshot)\n  │ Writes tests for the implementation, commits to same branch\n  ▼\nOrchestrator (TypeScript)\n  │ Parses WORK_RESULT, updates MD file with results + status\n  │ terminal? → PR + merge. Non-terminal? → push, next ticket.\n```\n\n### Adaptation Guidelines for Horizon → Napoli Prompts\n\nWhen editing prompts that reference Horizon/Linear:\n\n1. **Remove `mcp__linear__*` tool call references** — queue reading and result writing are now handled by the TypeScript orchestrator, not by Claude agents\n2. **Replace Linear status names** — drop the `∞` prefix but **keep the granular stage statuses**. See the **Task Status Model** section below for the full list.\n3. **Keep the WORK_RESULT format** — it's the interface between agents and is Linear-agnostic\n4. **Keep multi-agent conflict handling** — still relevant when multiple orchestrator instances run\n5. **Replace \"Linear issue\" language** with \"ticket\" or \"task\" language\n6. **Keep branch naming conventions** but adapt from `horizon/{issue-id}` to `feat/{task-id}` or `feat/{group}`\n\n---\n\n## Full Pipeline\n\n```\nUser submits request (CLI arg, stdin, or file)\n  │\n  ▼\nSpec Agent (local Claude CLI, interactive clarification loop)\n  ├─ Evaluates request against 5 spec quality criteria\n  ├─ If gaps: asks human targeted questions (loop until clear)\n  ├─ Detects variant requests (\"give me 2 versions\")\n  ├─ Decomposes into structured tickets with dependency graph\n  ├─ If variants: duplicates full dependency chain per variant with independent IDs\n  └─ Writes tickets to feature_requests/FR-{n}/ as MD files (status per start_status judgment)\n  │\n  ▼\nOrchestrator (pure TypeScript, continuous loop)\n  ├─ Reads feature_requests/**/AGI-*.md, topological sort on depends_on\n  ├─ Dispatches eligible tasks to Workers (up to N parallel)\n  ├─ On completion: parses WORK_RESULT, writes to MD\n  ├─ Merge: only for terminal tickets (no downstream group deps)\n  └─ When queue empty: sleep, poll, retry\n  │\n  ▼\nWorkers (Claude in Daytona sandbox, parallel)\n  ├─ Receives structured ticket in prompt\n  ├─ Branch: feat/{group} if grouped, feat/{id} if standalone\n  ├─ Checks out existing group branch (has prior chain commits) or creates new\n  ├─ Implements, commits, pushes\n  ├─ Creates PR only if terminal ticket\n  └─ Outputs structured WORK_RESULT block\n```\n\n---\n\n## Phase 1: Spec Agent (`src/lib/SpecAgent.ts` — NEW)\n\n### Purpose\n\nFront-door quality gate. Takes a vague user request and produces structured, dependency-ordered tickets. Uses the 5 spec quality criteria from the hookify rule as a hard gate — won't generate tickets until the spec is clear.\n\n### Clarification Loop\n\nThe Spec Agent runs as a **stateless retry loop** using `ClaudeSpawner`:\n\n```\nclarify(userRequest: string): Promise<TaskRequest[]>\n  context = userRequest\n  while true:\n    result = ClaudeSpawner.spawn(buildPrompt(context))\n    parsed = parseOutput(result.finalOutput)\n\n    if parsed.type === \"QUESTIONS\":\n      answers = await promptHuman(parsed.questions)\n      context = userRequest + \"\\n\\n## Clarifications\\n\" + answers\n      continue\n\n    if parsed.type === \"TICKETS\":\n      writeTicketsToQueue(parsed.tickets)\n      return parsed.tickets\n```\n\nEach spawn is stateless — all prior context (original request + accumulated answers) is passed in the prompt. Simple, no session management.\n\n### Spec Agent Prompt (`prompts/agent0-spec.md` — NEW)\n\n```\nYou are a Specification Agent. Your job is to evaluate a user's feature request\nand either ask clarifying questions or produce structured tickets.\n\n## Spec Quality Criteria\n\nEvaluate the request against ALL 5 of these standards:\n\n1. **Problem Statement** — Is there a clear description of what's broken, missing, or needed?\n   (not just \"improve X\")\n2. **Success Criteria** — Are there concrete, verifiable conditions for \"done\"?\n3. **User-Facing Behavior** — Is it clear what users will see or experience?\n4. **Boundaries & Constraints** — Is scope defined? What's in/out? Any technical constraints?\n5. **Context & Background** — Is there enough context for why this matters and what exists today?\n\n## Red Flags (require clarification)\n- Vague language (\"improve performance\", \"make it better\", \"clean up\")\n- Implementation details without a problem statement\n- No acceptance criteria\n- Assumes shared context without explaining it\n- Multiple unrelated features in one request\n\n## Variant Requests\n\nIf the user asks for multiple versions/variants (e.g., \"give me 2 versions\",\n\"compare approaches\", \"try it two different ways\"):\n\n- Produce the FULL ticket dependency chain once, then DUPLICATE it N times\n- Each variant gets its own independent IDs and dependency chain\n- Assign a shared `group` name per variant (e.g., \"dashboard-v1\", \"dashboard-v2\")\n- Add a `variant_hint` to each ticket describing the design direction for that variant\n- Variants must have ZERO cross-dependencies — they are fully independent pipelines\n\n## Your Output (EXACTLY one of these two formats)\n\n### If ANY criteria are missing or vague:\n\nQUESTIONS\n---\n1. [Targeted question addressing specific missing criterion]\n2. [Another question if needed]\n---\n\n### If ALL 5 criteria are adequately covered:\n\nTICKETS\n---\n- id: AGI-{n}\n  title: {short imperative title}\n  description: {detailed description with acceptance criteria}\n  repo: {repo URL}\n  depends_on: [{list of AGI-IDs this depends on, or empty}]\n  start_status: {starting stage — see Stage-Skipping Rules below}\n  group: {group name, omit if standalone ticket}\n  variant_hint: {design direction hint, omit if not a variant}\n- id: AGI-{n+1}\n  ...\n---\n\nStage-Skipping Rules (for start_status):\n- \"Needs Research\" — vague scope, unclear requirements, needs codebase exploration\n- \"Needs Specification\" — clear problem/requirements, but UX/design decisions not made\n- \"Needs Plan\" — clear problem + design + acceptance criteria, needs implementation planning\n- \"Needs Implement\" — fully specified with exact files, methods, and implementation steps\n\nRules for ticket decomposition:\n- Each ticket should be a single, independently testable unit of work\n- Order tickets by dependency (foundations first)\n- Use depends_on to encode the execution order\n- Include acceptance criteria in each ticket description\n- For variants: each chain must be fully self-contained\n```\n\n### Human Interaction\n\nUses Node `readline` to prompt the human:\n\n```typescript\nprivate async promptHuman(questions: string[]): Promise<string> {\n  const rl = createInterface({ input: process.stdin, output: process.stdout });\n  const answers: string[] = [];\n  for (const q of questions) {\n    const answer = await new Promise<string>(resolve =>\n      rl.question(`\\n${q}\\n> `, resolve)\n    );\n    answers.push(`Q: ${q}\\nA: ${answer}`);\n  }\n  rl.close();\n  return answers.join(\"\\n\\n\");\n}\n```\n\n### Writing Tickets\n\nThe Spec Agent uses two ID schemes:\n\n- **`FR-{n}`** — Feature Request ID. Tracks the original user request. One per `spec` invocation.\n- **`AGI-{n}`** — Ticket ID. Individual implementation units decomposed from the feature request.\n\nAfter the spec is complete, the Spec Agent creates a directory structure under `feature_requests/`:\n\n```\nfeature_requests/\n  FR-1/\n    request.md              # Original user request + clarification Q&A\n    dashboard-v1/           # Variant group subdirectory\n      AGI-5.md\n      AGI-6.md\n      AGI-7.md\n    dashboard-v2/           # Variant group subdirectory\n      AGI-8.md\n      AGI-9.md\n      AGI-10.md\n  FR-2/\n    request.md\n    AGI-11.md               # No group → lives directly in FR dir\n```\n\n**`request.md`** stores the original request and clarification history:\n\n```markdown\n---\nid: FR-1\ncreated: 2026-02-14T12:00:00Z\n---\n\n## Original Request\nBuild a dashboard with auth, give me 2 versions to compare\n\n## Clarifications\nQ: What auth provider should be used?\nA: JWT with our existing user table\n```\n\n**Ticket MD files** use YAML frontmatter:\n\n```markdown\n---\nid: AGI-8\nfeature_request: FR-1\ntitle: Add auth middleware\ndescription: >-\n  Create Express middleware that validates JWT tokens on protected routes.\n  Success criteria: unauthorized requests return 401, valid tokens pass through.\nrepo: 'https://github.com/user/repo'\ndepends_on: []\ngroup: dashboard-v2\nvariant_hint: >-\n  Use a data-dense table layout. Prioritize information density over whitespace.\nstatus: Needs Plan\n---\n```\n\nThe `status` field is set by the Spec Agent based on its `start_status` judgment. In this example, the auth middleware ticket has clear requirements and acceptance criteria but no implementation plan yet, so it starts at `Needs Plan`.\n\n### Integration with Existing ID Scheme\n\nReads existing `feature_requests/` to find the current max `FR-{n}` and `AGI-{n}` IDs. New IDs start from `max + 1`. The orchestrator globs `feature_requests/**/AGI-*.md` to discover all tickets.\n\n---\n\n## Phase 2: ClaudeSpawner (`src/lib/ClaudeSpawner.ts` — NEW)\n\nSimplified local Claude CLI spawner, shared by the Spec Agent and any future local agent needs.\n\n```typescript\ninterface SpawnResult {\n  finalOutput: string;\n  cost: number;\n  duration: number;\n  exitCode: number;\n}\n\nclass ClaudeSpawner {\n  spawn(prompt: string, model?: string): Promise<SpawnResult>\n}\n```\n\n- Spawns `claude -p --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n- Writes prompt to stdin, closes stdin\n- Parses streaming JSON from stdout\n- Extracts final output from `result` event\n- Logs streaming output to console\n- Returns `SpawnResult`\n\nBased on horizon's `claude.ts` pattern but stripped down (no MCP config, no rate limit retry, no terminal formatting).\n\n---\n\n## Prompt Loading (`src/lib/PromptLoader.ts` — NEW)\n\nA simple `loadPrompt(name)` function reads `.md` files from `prompts/` and fills `{{variable}}` placeholders via string replacement:\n\n```typescript\nfunction loadPrompt(name: string): string {\n  return fs.readFileSync(path.join(\"prompts\", name), \"utf-8\");\n}\n\nfunction fillTemplate(template: string, vars: Record<string, string>): string {\n  return Object.entries(vars).reduce(\n    (s, [key, val]) => s.replaceAll(`{{${key}}}`, val), template\n  );\n}\n```\n\nEach `build*Prompt()` method calls `loadPrompt()` then `fillTemplate()` with the relevant context:\n\n```typescript\n// Example: buildTestWriterPrompt\nconst template = loadPrompt(\"agent2-worker-test.md\");\nreturn fillTemplate(template, {\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  BRANCH_DIFF: execSync(`git diff main...HEAD`).toString(),\n  IS_TERMINAL: String(isTerminal),\n  CHAIN_TICKETS: isTerminal ? this.loadChainTickets(task) : \"\",\n});\n```\n\nFor the merge agent, `buildMergePrompt()` selects one of three merge fragments based on `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`):\n\n```typescript\n// Example: buildMergePrompt\nconst fragmentMap: Record<string, string> = {\n  auto:  \"fragments/merge-auto.md\",\n  merge: \"fragments/merge-direct.md\",\n  pr:    \"fragments/merge-pr.md\",\n};\nconst template = loadPrompt(fragmentMap[this.mergeMode]);\nreturn fillTemplate(template, {\n  BRANCH_NAME: this.branchName(task),\n  TICKET_CONTEXT: `${task.title}\\n${task.description}`,\n  TEST_RESULTS: testResult?.summary ?? \"No tests run\",\n});\n```\n\n---\n\n## Phase 3: Orchestrator (refactor `src/lib/SandboxQueueProcessor.ts`)\n\n### Continuous Loop with Stage-Aware Dispatch\n\nReplace the batch `processQueue()` with a concurrent worker pool that dispatches **one stage per invocation**. A ticket cycles through `Needs Research → Research In Progress → Needs Plan → Plan In Progress → ...` with the orchestrator re-dispatching after each stage completes.\n\n#### Configuration (environment variables with defaults)\n\n| Env Var | Default | Description |\n|---------|---------|-------------|\n| `NAPOLI_MAX_CONCURRENCY` | `3` | Maximum parallel worker sandboxes |\n| `NAPOLI_MAX_ITERATIONS` | `0` (infinite) | Total stage dispatches before exiting. `0` = run forever. |\n| `NAPOLI_POLL_INTERVAL` | `30` | Seconds to sleep when no tasks are eligible |\n| `NAPOLI_MERGE_MODE` | `auto` | Merge fragment selection: `auto`, `merge`, or `pr` |\n\n```typescript\nasync processQueue(): Promise<void> {\n  let iteration = 0;\n  const active = new Map<string, Promise<void>>();\n\n  while (this.maxIterations === 0 || iteration < this.maxIterations) {\n    const allTasks = await this.loadAllTasks();  // every status\n    const eligible = this.filterEligible(allTasks, active);\n\n    if (eligible.length === 0 && active.size === 0) {\n      console.log(`No tasks. Sleeping ${this.pollIntervalSeconds}s...`);\n      await sleep(this.pollIntervalSeconds * 1000);\n      continue;\n    }\n\n    for (const task of eligible) {\n      if (active.size >= this.maxConcurrency) break;\n      const stagePrompt = this.stagePromptMap[task.status];\n      if (!stagePrompt) continue;\n\n      const promise = this.dispatchStage(task, stagePrompt).then(async (result) => {\n        // dispatchStage handles: stage → test-writer → merge agent (if terminal)\n        // merge_status in result determines final status:\n        //   success → Done, pr_created → Awaiting Merge, blocked → Blocked\n        await this.writeResults(task, result);\n        await this.updateTaskStatus(task, result.nextStatus);\n        active.delete(task.id);\n      });\n      active.set(task.id, promise);\n      iteration++;\n    }\n\n    if (active.size > 0) {\n      await Promise.race(active.values());\n    }\n  }\n}\n```\n\n### Independent Worker Per Stage (Horizon Pattern)\n\nEach stage is a **completely independent worker invocation**. There is no session affinity — any available worker can pick up any actionable ticket. The handoff mechanism is the ticket's `status` field in the MD file:\n\n1. Worker A picks up ticket `AGI-5` in `Needs Research`, sets it to `Research In Progress`\n2. Worker A completes research, outputs `WORK_RESULT` with `next_status: \"Needs Plan\"`\n3. Orchestrator updates MD file: `status: Needs Plan`\n4. Worker A is released (sandbox torn down if applicable)\n5. Next loop iteration: Worker B (completely independent) picks up `AGI-5` in `Needs Plan`\n6. Worker B gets a fresh sandbox, reads the ticket context, runs the Plan stage prompt\n7. Repeat until terminal status\n\nThis means:\n- Workers are **stateless** — all context comes from the ticket MD file + repo state\n- Multiple tickets in different stages can run in parallel across different workers\n- A worker crash doesn't lose progress — the ticket stays at its last `In Progress` status\n\n**Crash recovery (worker failure)**: If a worker fails (exit code != 0 or no parseable WORK_RESULT), the orchestrator **retries once** by re-dispatching the same stage. If the retry also fails, the ticket is set to `Blocked` and logged for human attention. The human can investigate, fix the issue, and manually reset the status to the `Needs *` state to retry. No timeout is enforced — Daytona sandbox lifetime limits apply.\n\n**Crash recovery (orchestrator failure)**: If the orchestrator process itself crashes while tickets are `* In Progress`, those tickets remain stuck — `isActionable()` only matches `Needs *` statuses. In v1, a human must manually reset orphaned `In Progress` tickets back to their `Needs *` counterpart to resume processing. A future version could add a startup sweep or timeout-based recovery.\n\n### Spec Agent Sets Initial Stage\n\nThe Spec Agent judges which stage each ticket should **start at** based on how well-specified it is. Not all tickets need to go through every stage:\n\n```typescript\n// In the Spec Agent prompt output, each ticket includes a start_status:\n- id: AGI-{n}\n  title: {title}\n  description: {description}\n  start_status: {one of: \"Needs Research\", \"Needs Specification\", \"Needs Plan\", \"Needs Implement\"}\n```\n\nStage-skipping rules for the Spec Agent:\n\n| Ticket Characteristics | Start Status | Rationale |\n|----------------------|--------------|-----------|\n| Vague request, unclear scope, needs codebase exploration | `Needs Research` | Worker must assess complexity and codebase before anything else |\n| Clear problem + requirements, but no UX/design decisions made | `Needs Specification` | Skip research — go straight to design |\n| Clear problem + clear UX + clear acceptance criteria, but no implementation plan | `Needs Plan` | Skip research + spec — go straight to planning |\n| Fully specified with exact files/methods to change, clear implementation steps | `Needs Implement` | Skip directly to implementation |\n\nThe Spec Agent is in the best position to judge this because it has already done thorough quality assessment (5 criteria, clarification loop with the human). If the human provided a detailed spec with exact implementation steps, forcing it through Research is wasteful.\n\n> **Note**: Tickets never start at `Needs Validate` — validation only makes sense after implementation has occurred.\n\n### `filterEligible(allTasks, active)` — Dependency + Stage Resolution\n\nTakes **all tasks** (every status) as a single list. The `isActionable()` guard inside handles narrowing to dispatch candidates. Dependency checks naturally see all statuses — including `* In Progress` and intervention statuses — preventing premature dispatch after process restart.\n\n```typescript\nprivate filterEligible(\n  allTasks: TaskRequest[],\n  active: Map<string, Promise<void>>\n): TaskRequest[] {\n  return allTasks.filter(task => {\n    if (active.has(task.id)) return false;\n    if (!this.isActionable(task)) return false;\n    return task.dependsOn.every(depId => {\n      if (active.has(depId)) return false;       // dep running in this process → wait\n      const dep = allTasks.find(t => t.id === depId);\n      if (!dep) return true;                      // dep not found at all = satisfied (or deleted)\n      return dep.status === TaskStatus.Done;       // only Done = satisfied\n    });\n  });\n}\n```\n\nThe `processQueue` loop calls this as:\n\n```typescript\nconst allTasks = await this.loadAllTasks();  // every status\nconst eligible = this.filterEligible(allTasks, active);\n```\n\nFour states a dependency can be in:\n- **`Done`** — satisfied, proceed\n- **`* In Progress` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **`Needs *` (any stage)** — found in `allTasks` with status != Done → `false` (wait)\n- **Intervention** (`Blocked`, `Needs Human *`) — found in `allTasks` with status != Done → `false` (wait, human must unblock)\n- **Not found** — task deleted or never existed → `true` (treat as satisfied)\n\nNo variant-specific logic needed — dependencies already keep chains ordered, and independent variant chains naturally parallelize.\n\n### `isTerminal(task)` — Detect Chain-End Tickets (NEW)\n\nA ticket is terminal if no other **non-Done** ticket depends on it. With the stage-aware model, \"non-Done\" means any status that isn't `Done` — including all `Needs *`, all `* In Progress`, and all intervention statuses:\n\n```typescript\nprivate async isTerminal(task: TaskRequest): Promise<boolean> {\n  const allTasks = await this.loadAllTasks();  // all statuses\n  return !allTasks.some(t =>\n    t.id !== task.id &&\n    t.dependsOn.includes(task.id) &&\n    t.status !== TaskStatus.Done\n  );\n}\n```\n\n> **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active.\n\nThis determines:\n- **Terminal**: Create PR, attempt merge to main\n- **Non-terminal**: Just push to group branch, no PR, no merge\n\n### `branchName(task)` — Group-Aware Branch Naming (NEW)\n\n```typescript\nprivate branchName(task: TaskRequest): string {\n  return task.group ? `feat/${task.group}` : `feat/${task.id}`;\n}\n```\n\n### Agent Runner Pattern\n\n`runWorkerAgent()`, `runTestWriterAgent()`, and `runMergeAgent()` all follow the same pattern inherited from the existing `executeClaudeCommand()`:\n\n1. Open a PTY session in the Daytona sandbox via the SDK\n2. Invoke `claude -p '<prompt>' --dangerously-skip-permissions --output-format=stream-json --model <model> --verbose`\n3. Stream stdout line-by-line, parse JSON events, log to file\n4. Extract structured output (WORK_RESULT / TEST_RESULT) from the `result` event\n5. Return parsed result\n\nThe only difference between the three is which prompt they receive and which output block they parse.\n\n### `dispatchStage(task, stagePrompt)` — Stage-Aware Sandbox Logic (renamed from `executeWorker`)\n\nEach invocation handles **one stage**. The orchestrator re-dispatches the ticket for subsequent stages based on `next_status` in the WORK_RESULT.\n\nKey behaviors:\n1. **Stage prompt** selected from `stagePromptMap` based on current `task.status`\n2. **Branch name** passed to worker prompt uses `branchName(task)`\n3. **Sandbox setup is orchestrator-driven** (programmatic, before worker starts):\n   - `createSandbox(task)` clones the repo via Daytona SDK\n   - Checks out `branchName(task)` if it exists on remote (grouped non-first tickets inherit prior chain commits), otherwise creates the branch\n   - Runs `gh auth setup-git` for push access\n   - Worker sees a ready-to-go working directory on the correct branch\n4. **`variant_hint`** included in worker prompt when present\n5. Returns parsed WORK_RESULT including `nextStatus` field\n6. **Research stage** decides the workflow: returns `next_status: \"Needs Specification\"` or `\"Needs Plan\"` (staged) or `\"Needs Oneshot\"` (fast-track)\n7. **Sandboxes**: All worker stages run in Daytona sandboxes. This keeps the orchestrator lightweight (pure polling/dispatch) and avoids local resource contention. Only the Spec Agent (Phase 1, separate entry point) runs locally via ClaudeSpawner.\n8. **Post-stage subagents** (same sandbox, before teardown):\n   - **Test-writer**: Runs after code-producing stages (Implement, Oneshot, Validate). Writes and commits tests.\n   - **Merge agent**: Runs after test-writer for **terminal tickets only**. Uses `merge-auto.md` rubric to decide direct merge vs PR. Outputs `merge_status`.\n\n### `writeResults(task, result)` — Update MD File\n\nParses WORK_RESULT from agent output, **appends** a Results section to the MD body. Does **not** modify frontmatter — status updates are handled exclusively by `updateTaskStatus()`.\n\n```markdown\n## Results\n\n**Completed**: 2026-02-14T12:00:00Z\n**Branch**: feat/dashboard-v2\n\n### Summary\n{parsed from WORK_RESULT}\n\n### Artifacts\n- Commit: abc1234\n- PR: https://github.com/user/repo/pull/43  (only if terminal)\n```\n\n### Merge Agent — Terminal Tickets Only (CHANGED)\n\nMerging is handled by a **dedicated merge subagent** that runs in the same sandbox as the worker, after the test-writer, for terminal tickets only. The orchestrator does **not** run git commands — the merge agent does.\n\nThe merge agent:\n1. Runs in the same sandbox (has full repo state, branch, test results)\n2. Receives one of three merge fragment prompts (selected by `mergeMode` config):\n   - **`merge-auto.md`** (default) — self-contained decision rubric that evaluates the change and chooses direct merge or PR at runtime\n   - **`merge-direct.md`** — always merge directly to main (for trusted, low-risk pipelines)\n   - **`merge-pr.md`** — always create a PR (for repos requiring review)\n3. Executes `git merge --no-ff` or `gh pr create` based on the selected mode's instructions\n4. Outputs `merge_status` in WORK_RESULT: `success`, `pr_created`, or `blocked`\n\nThe three fragments are **independent, mutually exclusive modes** (ported from Horizon). Each is a complete standalone prompt — `merge-auto.md` does not delegate to the other two. The orchestrator selects which fragment to load via a `mergeMode` config (`'auto' | 'merge' | 'pr'`, default `'auto'`).\n\nThe orchestrator maps `merge_status` to the final ticket status:\n- `success` → `Done`\n- `pr_created` → `Awaiting Merge`\n- `blocked` → `Blocked` (merge conflict, orchestrator logs for human attention)\n\nFor non-terminal grouped tickets: the worker just pushes to the shared group branch. No merge agent runs. The next ticket in the chain picks up where it left off.\n\n---\n\n## Phase 4: Entry Point (`src/index.ts`)\n\nTwo modes of operation:\n\n```typescript\nasync function main() {\n  const command = process.argv[2];\n\n  if (command === \"spec\") {\n    const request = process.argv.slice(3).join(\" \") || await readStdin();\n    const specAgent = new SpecAgent(queueDir);\n    await specAgent.clarify(request);\n  } else {\n    const orchestrator = new SandboxQueueProcessor(process.env.DAYTONA_API_KEY!);\n    await orchestrator.processQueue();\n  }\n}\n```\n\nUsage:\n- `npx tsx src/index.ts spec \"Add user authentication\"` → Spec Agent\n- `npx tsx src/index.ts spec \"Build dashboard, give me 2 versions\"` → Spec Agent with variants\n- `npx tsx src/index.ts` → Orchestrator loop\n\n---\n\n## Phase 5: Test-Writer Subagent (deterministic pipeline step)\n\n### Purpose\n\nWorker stages that produce code (Implement, Oneshot, Validate) are followed by a **test-writer step** in the same sandbox. This is not optional — it is a deterministic part of the pipeline that produces tests scoped to the work just completed. Research, Specification, and Plan stages do not trigger the test-writer since they produce analysis and plans, not code.\n\n### Two-Tier Testing Strategy\n\n| Ticket type | Unit tests | Integration tests |\n|-------------|-----------|-------------------|\n| **Non-terminal** (has downstream dependents) | Yes — cover all new/changed public methods and non-trivial private logic | No |\n| **Terminal** (end of chain) | Yes | Yes — cover the full variant/dependency chain's interactions with each other and with pre-existing repo code |\n\n### Execution Flow\n\nThe test-writer runs **inside `dispatchStage()`** (see Phase 3) for code-producing stages, after the worker agent finishes but before the merge agent and sandbox teardown:\n\n```\ndispatchStage(task, stagePrompt):\n  1. Create Daytona sandbox, checkout branch\n  2. Worker agent runs stage prompt, commits, pushes\n  3. If stage is Implement, Oneshot, or Validate:\n     a. Test-writer agent runs in same sandbox\n     b. Reads the git diff (all commits on this branch vs main)\n     c. Reads the ticket description + acceptance criteria\n     d. If terminal: also reads all tickets in the group chain for integration context\n     e. Writes test files to tests/\n     f. Runs `npm test` to verify all tests pass\n     g. Commits test files, pushes to same branch\n  4. If terminal: merge agent runs (see Merge Agent section in Phase 3)\n  5. Return combined result (stage + test summary + merge status)\n```\n\n### Test-Writer Prompt (`prompts/agent2-worker-test.md` — NEW)\n\n```\nYou are a Test-Writer Agent. You have just received a completed implementation in this\nsandbox. Your job is to write tests for the code that was changed.\n\n## Context\n\n**Ticket**: {{TICKET_CONTEXT}}\n**Branch diff vs main**: {{BRANCH_DIFF}}\n**Is terminal ticket**: {{IS_TERMINAL}}\n{{CHAIN_TICKETS}}\n\n## Rules\n\n1. Use `vitest` as the test framework. Place tests in `tests/<feature>.test.ts`.\n2. Follow existing test patterns in the repo (see tests/ for examples).\n3. Write **unit tests** for:\n   - Every new public method on any class\n   - Non-trivial private logic (parsing, state transitions, validation)\n   - Both happy path and at least one meaningful failure case per method\n   - Use descriptive test names: \"returns 401 for expired JWT tokens\"\n4. If this is a **terminal ticket**, also write **integration tests** that:\n   - Exercise the full chain of features built across this variant group\n   - Test interactions between the new code and pre-existing repo code\n   - Cover end-to-end flows from the user's perspective where applicable\n5. Mock external dependencies (network, sandboxes, Claude CLI) — never call real services.\n6. Run `npm test` after writing. If tests fail, fix them before committing.\n7. Commit all test files with message: \"test: add tests for {ticket title}\"\n\n## Output\n\nTEST_RESULT\n---\nfiles_created: [list of test file paths]\nunit_tests: {count}\nintegration_tests: {count}\nall_passing: {true/false}\n---\n```\n\n---\n\n## `TaskRequest` Interface Update\n\n```typescript\ninterface TaskRequest {\n  id: string;\n  featureRequest: string;    // \"FR-1\" — parent feature request\n  file: string;\n  filePath: string;\n  title: string;\n  description: string;\n  repo: string;\n  dependsOn: string[];       // [\"AGI-1\", \"AGI-2\"]\n  group?: string;            // \"dashboard-v1\" — shared branch for variant chain\n  variantHint?: string;      // design direction for this variant\n  status: TaskStatus;\n}\n```\n\n---\n\n## Task Status Model\n\nThe worker pipeline uses **granular per-stage statuses** so the orchestrator knows exactly which stage prompt to dispatch. This replaces Horizon's `∞`-prefixed Linear statuses with plain strings stored in the MD frontmatter `status:` field.\n\n### Status Enum\n\n```typescript\nenum TaskStatus {\n  // Stage: Research\n  NeedsResearch        = \"Needs Research\",\n  ResearchInProgress   = \"Research In Progress\",\n\n  // Stage: Specification (optional — research decides if needed)\n  NeedsSpecification   = \"Needs Specification\",\n  SpecificationInProgress = \"Specification In Progress\",\n\n  // Stage: Plan\n  NeedsPlan            = \"Needs Plan\",\n  PlanInProgress       = \"Plan In Progress\",\n\n  // Stage: Implement\n  NeedsImplement       = \"Needs Implement\",\n  ImplementInProgress  = \"Implement In Progress\",\n\n  // Stage: Validate\n  NeedsValidate        = \"Needs Validate\",\n  ValidateInProgress   = \"Validate In Progress\",\n\n  // Stage: Oneshot (fast-track, decided during research)\n  NeedsOneshot         = \"Needs Oneshot\",\n  OneshotInProgress    = \"Oneshot In Progress\",\n\n  // Terminal\n  Done                 = \"Done\",\n  AwaitingMerge        = \"Awaiting Merge\",\n\n  // Intervention (requires human action)\n  Blocked              = \"Blocked\",\n  NeedsHumanReview     = \"Needs Human Review\",\n  NeedsHumanDecision   = \"Needs Human Decision\",\n}\n```\n\n### Stage Transition Diagram\n\n```\nNeeds Research ──→ Research In Progress\n  │\n  ├─ SIMPLE ──→ Needs Oneshot ──→ Oneshot In Progress ──→ Done / Awaiting Merge\n  │\n  └─ COMPLEX ──┬──→ Needs Specification ──→ Specification In Progress ──→ Needs Plan\n               │\n               └──→ Needs Plan (skip spec if pure backend / no UX)\n                      │\n                      ▼\n                    Plan In Progress ──→ Needs Implement\n                      │\n                      ▼\n                    Implement In Progress ──→ Needs Validate\n                      │\n                      ▼\n                    Validate In Progress ──→ Done / Awaiting Merge\n\nANY STAGE ──→ Blocked / Needs Human Review / Needs Human Decision\n```\n\n### How the Orchestrator Uses Statuses\n\nThe orchestrator dispatches workers based on the current status:\n\n```typescript\nprivate stagePromptMap: Record<string, string> = {\n  \"Needs Research\":        \"agent2-worker-research.md\",\n  \"Needs Specification\":   \"agent2-worker-specification.md\",\n  \"Needs Plan\":            \"agent2-worker-plan.md\",\n  \"Needs Implement\":       \"agent2-worker-implement.md\",\n  \"Needs Validate\":        \"agent2-worker-validate.md\",\n  \"Needs Oneshot\":         \"agent2-worker-oneshot.md\",\n};\n\nprivate codeProducingStages = new Set([\n  \"Needs Implement\",\n  \"Needs Validate\",\n  \"Needs Oneshot\",\n]);\n\nasync dispatchStage(task: TaskRequest, stagePrompt: string): Promise<StageResult> {\n  const sandbox = await this.createSandbox(task);\n  const originalStatus = task.status;  // capture before mutation\n\n  await this.updateTaskStatus(task, this.inProgressStatus(task.status));\n  const stageResult = await this.runWorkerAgent(sandbox, task, stagePrompt);\n\n  // Conditionally run test-writer for code-producing stages\n  let testResult: TestResult | undefined;\n  if (this.codeProducingStages.has(originalStatus)) {\n    const isTerminal = await this.isTerminal(task);\n    testResult = await this.runTestWriterAgent(sandbox, this.buildTestWriterPrompt(task, isTerminal));\n  }\n\n  // Step 3: Merge agent (same sandbox, only for terminal code-producing stages)\n  let mergeResult: MergeResult | undefined;\n  if (this.codeProducingStages.has(originalStatus) && await this.isTerminal(task)) {\n    const mergePrompt = this.buildMergePrompt(task);  // loads merge-auto.md fragment\n    mergeResult = await this.runMergeAgent(sandbox, mergePrompt);\n  }\n\n  return { stage: stageResult, tests: testResult, merge: mergeResult };\n}\n```\n\nKey change from the previous plan: **each worker invocation handles one stage**, not the entire pipeline. The orchestrator re-dispatches the same ticket through successive stages based on the `nextStatus` returned in WORK_RESULT.\n\nFor terminal tickets, the `merge` field in the result determines final status: `success` → `Done`, `pr_created` → `Awaiting Merge`, `blocked` → `Blocked`.\n\n### WORK_RESULT Stage Output\n\nEach stage's worker outputs a `next_status` field that the orchestrator uses to advance the ticket:\n\n```yaml\nWORK_RESULT\n---\nsuccess: true\nstage_completed: research\nworkflow: staged          # or \"oneshot\"\nnext_status: \"Needs Specification\"  # or \"Needs Plan\" if spec not needed, or \"Needs Oneshot\" for fast-track\n---\n```\n\n### Intervention Statuses\n\nWhen a worker cannot proceed, it sets one of three intervention statuses:\n\n| Status | Meaning | Example |\n|--------|---------|---------|\n| `Blocked` | External blocker preventing progress | Merge conflict, missing dependency, CI failure |\n| `Needs Human Review` | Work is done but needs human sign-off before advancing | Risky refactor, security-sensitive change, ambiguous acceptance criteria |\n| `Needs Human Decision` | Multiple valid paths forward, human must choose | Architectural choice, conflicting requirements, scope ambiguity |\n\nIntervention output includes structured context for the human:\n\n```yaml\nWORK_RESULT\n---\nsuccess: false\nstage_completed: research\nnext_status: \"Needs Human Decision\"\nintervention:\n  summary: \"Two valid auth approaches — need human to choose\"\n  options:\n    - \"JWT with refresh tokens — simpler, stateless\"\n    - \"Session-based with Redis — better revocation\"\n  questions:\n    - \"Which approach aligns with your scaling plans?\"\n---\n```\n\n### Orchestrator Handling of Intervention Statuses\n\n```typescript\nprivate isActionable(task: TaskRequest): boolean {\n  return task.status.startsWith(\"Needs \") &&\n    ![\"Needs Human Review\", \"Needs Human Decision\"].includes(task.status);\n}\n```\n\nTickets in intervention statuses are **skipped by the orchestrator** until a human manually updates the status (e.g., back to `Needs Plan` after making a decision). The orchestrator logs them as requiring attention.\n\n### `inProgressStatus()` — Status Transition Helper\n\nMaps each actionable `Needs *` status to its corresponding `* In Progress` status:\n\n```typescript\nconst inProgressMap: Record<string, TaskStatus> = {\n  [TaskStatus.NeedsResearch]:      TaskStatus.ResearchInProgress,\n  [TaskStatus.NeedsSpecification]: TaskStatus.SpecificationInProgress,\n  [TaskStatus.NeedsPlan]:          TaskStatus.PlanInProgress,\n  [TaskStatus.NeedsImplement]:     TaskStatus.ImplementInProgress,\n  [TaskStatus.NeedsValidate]:      TaskStatus.ValidateInProgress,\n  [TaskStatus.NeedsOneshot]:       TaskStatus.OneshotInProgress,\n};\n\nfunction inProgressStatus(status: TaskStatus): TaskStatus {\n  return inProgressMap[status] ?? status;\n}\n```\n\n### Single Task Loader\n\n**`loadAllTasks()`** — Returns tasks in **every** status by globbing `feature_requests/**/AGI-*.md`. Used by `filterEligible()` (with `isActionable()` guard for narrowing), `isTerminal()`, and dependency checks. A single loader keeps the code simple — `isActionable()` handles the dispatch-candidate filtering internally.\n\n## Variant Example: End-to-End\n\nUser: `npx tsx src/index.ts spec \"Build a dashboard with auth, give me 2 versions to compare\"`\n\nSpec Agent creates `feature_requests/FR-1/` with variant subdirs and produces after clarification:\n\n```\n# Variant 1: Minimal card layout\nAGI-5: Auth middleware        (depends_on: [], group: dashboard-v1)\nAGI-6: Dashboard API          (depends_on: [AGI-5], group: dashboard-v1)\nAGI-7: Dashboard UI           (depends_on: [AGI-6], group: dashboard-v1,\n                                variant_hint: \"Minimal card layout, whitespace-heavy\")\n\n# Variant 2: Data-dense table layout\nAGI-8: Auth middleware         (depends_on: [], group: dashboard-v2)\nAGI-9: Dashboard API           (depends_on: [AGI-8], group: dashboard-v2)\nAGI-10: Dashboard UI           (depends_on: [AGI-9], group: dashboard-v2,\n                                variant_hint: \"Dense table layout, information-rich\")\n```\n\nOrchestrator execution (assuming all tickets start at `Needs Plan` — Spec Agent judged them well-specified):\n\n```\nt=0   AGI-5 (Needs Plan) + AGI-8 (Needs Plan) eligible (no deps)\n        → dispatch both in parallel, each gets Plan stage prompt\n        → Worker A: AGI-5 Plan In Progress → outputs next_status: \"Needs Implement\"\n        → Worker B: AGI-8 Plan In Progress → outputs next_status: \"Needs Implement\"\n\nt=1   AGI-5 (Needs Implement) + AGI-8 (Needs Implement) eligible again\n        → dispatch both in parallel, each gets Implement stage prompt\n        → Worker C: AGI-5 creates feat/dashboard-v1 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n        → Worker D: AGI-8 creates feat/dashboard-v2 branch, commits auth, pushes\n           → outputs next_status: \"Needs Validate\"\n\nt=2   AGI-5 (Needs Validate) + AGI-8 (Needs Validate) eligible\n        → dispatch both, Validate stage prompt\n        → Worker E: AGI-5 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-6 depends on AGI-5, status != Done) → no PR, no merge\n        → Worker F: AGI-8 validates → next_status: \"Done\"\n           → isTerminal? No (AGI-9 depends on AGI-8) → no PR, no merge\n\nt=3   AGI-5 Done → AGI-6 (Needs Plan) eligible. AGI-8 Done → AGI-9 (Needs Plan) eligible.\n        → dispatch both for Plan stage\n        ... (same cycle: Plan → Implement → Validate)\n\nt=4   AGI-6 (Needs Implement): checks out feat/dashboard-v1 (has auth commits), adds API, pushes\n      AGI-9 (Needs Implement): checks out feat/dashboard-v2 (has auth commits), adds API, pushes\n\nt=5   AGI-6 validates → Done. AGI-9 validates → Done.\n        → isTerminal? No (AGI-7 depends on AGI-6, AGI-10 depends on AGI-9)\n\nt=6   AGI-7 (Needs Plan) + AGI-10 (Needs Plan) eligible\n        ... Plan → Implement → Validate cycle\n\nt=7   AGI-7 Implement: checks out feat/dashboard-v1, adds UI (card layout), pushes\n      AGI-10 Implement: checks out feat/dashboard-v2, adds UI (table layout), pushes\n\nt=8   AGI-7 validates → Done. AGI-10 validates → Done.\n        → isTerminal? YES (nothing depends on AGI-7 or AGI-10 with status != Done)\n        → AGI-7 creates PR for feat/dashboard-v1\n        → AGI-10 creates PR for feat/dashboard-v2\n        → Orchestrator merges whichever the user approves\n```\n\nKey observations:\n- **Dependencies block on `Done`, not on stage completion** — AGI-6 waits until AGI-5 reaches `Done`, not just until AGI-5 finishes one stage\n- **Group branch accumulates across tickets** — AGI-6's Implement stage checks out `feat/dashboard-v1` which already has AGI-5's commits\n- **Variant chains are fully independent** — dashboard-v1 and dashboard-v2 never interact\n- **`isTerminal` uses `!== Done`** — correctly handles all 16+ statuses without a fragile whitelist\n\nUser gets 2 PRs to compare side-by-side.\n\n---\n\n## Files\n\n| File | Change |\n|------|--------|\n| `src/lib/TaskStatus.ts` | **New** — `TaskStatus` enum + helper functions (`isActionable()`, `inProgressStatus()`, `stagePromptMap`) |\n| `src/lib/PromptLoader.ts` | **New** — `loadPrompt()` + `fillTemplate()` for `{{variable}}` replacement in prompt `.md` files |\n| `src/lib/SpecAgent.ts` | **New** — Spec quality gate + clarification loop + variant chain duplication + ticket writer |\n| `src/lib/ClaudeSpawner.ts` | **New** — Local Claude CLI spawner (simplified from Horizon's `claude.ts`) |\n| `src/lib/SandboxQueueProcessor.ts` | Refactor to continuous loop, **stage-aware dispatch** (one stage per invocation), `stagePromptMap` routing, parallel dispatch, group-aware branching, `isTerminal()`, `branchName()`, `loadAllTasks()`, `filterEligible()` with `isActionable()` guard, `dispatchStage()` with conditional test-writer + merge agent, `buildMergePrompt()`, `runMergeAgent()`, result writing with `nextStatus` + `merge_status` parsing |\n| `src/index.ts` | Two-mode entry: `spec` command vs orchestrator loop |\n| `prompts/agent0-spec.md` | **New** — Spec Agent prompt (5 quality criteria, clarification loop, variant detection) |\n| `prompts/agent2-worker-test.md` | **New** — Test-Writer Agent prompt (unit + integration test generation) |\n| `prompts/agent1-linear-reader.md` | **Removed** — Queue reading logic absorbed into TypeScript orchestrator (`loadAllTasks()`, `filterEligible()`) |\n| `prompts/agent3-linear-writer.md` | **Removed** — Result writing logic absorbed into TypeScript orchestrator (`writeResults()`, `updateTaskStatus()`) |\n| `prompts/agent2-worker.md` | **Minor** — Update file path references from `.horizon/prompts/` to `prompts/`, update status references to use `TaskStatus` enum values |\n| `prompts/fragments/merge-auto.md` | **Existing** — Self-contained merge agent prompt for `auto` mode. Evaluates the change at runtime and chooses direct merge or PR. Default `mergeMode`. |\n| `prompts/fragments/merge-direct.md` | **Existing** — Standalone merge agent prompt for `merge` mode. Always merges directly to main. |\n| `prompts/fragments/merge-pr.md` | **Existing** — Standalone merge agent prompt for `pr` mode. Always creates a PR. |\n\n---\n\n## Verification\n\n1. **Spec Agent (no variants)**: `npx tsx src/index.ts spec \"make it better\"` → asks clarifying questions. Detailed spec → produces tickets with appropriate `start_status` per ticket.\n2. **Spec Agent (with variants)**: `npx tsx src/index.ts spec \"Build dashboard, 2 versions\"` → produces 2 independent ticket chains with groups.\n3. **Spec Agent (stage-skipping)**: Well-specified request with exact implementation steps → tickets start at `Needs Implement`, not `Needs Research`.\n4. **Orchestrator (stage progression)**: Add a `Needs Research` ticket, verify it progresses through: `Research In Progress` → `Needs Plan` → `Plan In Progress` → `Needs Implement` → `Implement In Progress` → `Needs Validate` → `Validate In Progress` → `Done`.\n5. **Orchestrator (independent workers)**: Verify that after Worker A completes Research and sets `Needs Plan`, a fresh Worker B (new sandbox) picks up the ticket and runs the Plan stage.\n6. **Orchestrator (oneshot fast-track)**: Add a simple ticket, verify research stage routes to `Needs Oneshot` → `Oneshot In Progress` → `Done`.\n7. **Orchestrator (intervention statuses)**: Verify that tickets set to `Blocked`, `Needs Human Review`, or `Needs Human Decision` are skipped by the orchestrator and logged as requiring attention. Verify manual status update resumes processing.\n8. **Orchestrator (variant groups)**: Add 2 variant chains, verify:\n   - Chains execute in parallel (AGI-5 and AGI-8 at same time)\n   - Within each chain, tickets execute sequentially (AGI-6 waits for AGI-5)\n   - Non-terminal tickets push to shared branch, no PR\n   - Terminal tickets create PR and attempt merge\n   - Group branch accumulates commits across chain\n9. **Existing tests**: `npm test` passes\n\n","structuredPatch":[{"oldStart":578,"oldLines":6,"newStart":578,"newLines":8,"lines":[" }"," ```"," ","+> **Note**: `isTerminal()` calls `loadAllTasks()` independently, which means a second glob scan when called from `dispatchStage()`. Acceptable for v1 queue sizes; future optimization can pass the pre-loaded task list as a parameter.","+"," > **Why `!== Done` instead of a whitelist**: With 16+ statuses in the `TaskStatus` enum, checking against a whitelist is fragile. The only status that means \"this ticket no longer needs its dependency's branch\" is `Done`. Everything else — `Needs Research`, `Plan In Progress`, `Blocked`, `Needs Human Decision`, etc. — means the dependency chain is still active."," "," This determines:"]}],"userModified":false,"replaceAll":false},"sourceToolAssistantUUID":"f2db9f4b-093e-4760-bcdc-9291de8c8b6b"}
{"parentUuid":"1bc5cf79-609d-4fc5-ab4b-c285fcb7d669","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","message":{"model":"claude-opus-4-6","id":"msg_01NCbGQzM9Vykp8acUBvZyeH","type":"message","role":"assistant","content":[{"type":"text","text":"All 6 issues and 3 minor nits are addressed. Here's the summary:\n\n| # | Issue | Resolution |\n|---|-------|------------|\n| 1 | Orphaned \"In Progress\" on orchestrator crash | Added explicit \"document-only\" note — humans must manually reset |\n| 2 | `codeProducingStages` undefined | Added explicit `Set` definition (Implement, Validate, Oneshot) |\n| 3 | `inProgressStatus()` mapping undefined | Added full mapping in TaskStatus section |\n| 4 | Merge fragment relationship ambiguous | Clarified as three independent modes selected by `mergeMode` config, with code example |\n| 5 | Stale \"vs. previous plan\" table | Removed entirely |\n| 6 | Config values not specified | Added env var table (NAPOLI_MAX_CONCURRENCY, etc.) |\n| N1 | PromptLoader placement | Moved before Phase 3 |\n| N2 | `--dangerously-skip-permissions` safety note | Skipped per your preference |\n| N3 | Double `loadAllTasks()` call | Added future optimization note |"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":424,"cache_read_input_tokens":66103,"cache_creation":{"ephemeral_5m_input_tokens":424,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard","inference_geo":"global"}},"requestId":"req_011CY7xw2kS19iSYPji3ExLe","type":"assistant","uuid":"fd00ad1c-4bff-4c16-aff0-41e92f6141f0","timestamp":"2026-02-14T12:31:22.753Z"}
{"parentUuid":"fd00ad1c-4bff-4c16-aff0-41e92f6141f0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"entire hooks claude-code stop"},"parentToolUseID":"771f35fa-e6c2-4559-817f-8d8d5d7e52e1","toolUseID":"771f35fa-e6c2-4559-817f-8d8d5d7e52e1","timestamp":"2026-02-14T12:31:22.778Z","uuid":"d39f9765-072c-4b7c-a34d-08b9baa7d7ea"}
{"parentUuid":"d39f9765-072c-4b7c-a34d-08b9baa7d7ea","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"progress","data":{"type":"hook_progress","hookEvent":"Stop","hookName":"Stop","command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"},"parentToolUseID":"771f35fa-e6c2-4559-817f-8d8d5d7e52e1","toolUseID":"771f35fa-e6c2-4559-817f-8d8d5d7e52e1","timestamp":"2026-02-14T12:31:22.779Z","uuid":"13c30ed9-94b3-4dc1-a714-1dd36ebbe0ad"}
{"parentUuid":"13c30ed9-94b3-4dc1-a714-1dd36ebbe0ad","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"system","subtype":"stop_hook_summary","hookCount":2,"hookInfos":[{"command":"entire hooks claude-code stop"},{"command":"python3 ${CLAUDE_PLUGIN_ROOT}/hooks/stop.py"}],"hookErrors":[],"preventedContinuation":false,"stopReason":"","hasOutput":true,"level":"suggestion","timestamp":"2026-02-14T12:31:23.206Z","uuid":"c003266c-e9d7-446b-b4e8-650addd3fce0","toolUseID":"771f35fa-e6c2-4559-817f-8d8d5d7e52e1"}
{"parentUuid":"c003266c-e9d7-446b-b4e8-650addd3fce0","isSidechain":false,"userType":"external","cwd":"/Users/ob1/projects/opus-hackathon/napoli-matcha","sessionId":"99490020-6d70-40ae-93a3-ac01b4cc8c0e","version":"2.1.42","gitBranch":"ralph-loop","slug":"fuzzy-fluttering-dolphin","type":"system","subtype":"turn_duration","durationMs":208652,"timestamp":"2026-02-14T12:31:23.208Z","uuid":"dee43cb2-2f08-4897-8315-9d92f004cbc7","isMeta":false}
